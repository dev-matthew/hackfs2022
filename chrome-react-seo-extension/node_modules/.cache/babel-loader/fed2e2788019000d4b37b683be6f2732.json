{"ast":null,"code":"/**\n * Create, import, and export ethereum keys.\n * @author Jack Peterson (jack@tinybike.net)\n */\n\"use strict\";\n\nvar isBrowser = typeof process === \"undefined\" || !process.nextTick || Boolean(process.browser);\n\nvar sjcl = require(\"sjcl\");\n\nvar uuid = require(\"uuid\");\n\nvar secp256k1 = require(\"secp256k1/elliptic\");\n\nvar createKeccakHash = require(\"keccak/js\");\n\nvar scrypt = require(\"scrypt-js\");\n\nfunction isFunction(f) {\n  return typeof f === \"function\";\n}\n\nfunction keccak256(buffer) {\n  return createKeccakHash(\"keccak256\").update(buffer).digest();\n}\n\nmodule.exports = {\n  version: \"1.1.0\",\n  browser: isBrowser,\n  scrypt: null,\n  crypto: isBrowser ? require(\"crypto-browserify\") : require(\"crypto\"),\n  constants: {\n    // Symmetric cipher for private key encryption\n    cipher: \"aes-128-ctr\",\n    // Initialization vector size in bytes\n    ivBytes: 16,\n    // ECDSA private key size in bytes\n    keyBytes: 32,\n    // Key derivation function parameters\n    pbkdf2: {\n      c: 262144,\n      dklen: 32,\n      hash: \"sha256\",\n      prf: \"hmac-sha256\"\n    },\n    scrypt: {\n      memory: 280000000,\n      dklen: 32,\n      n: 262144,\n      r: 8,\n      p: 1\n    }\n  },\n\n  /**\n   * Check whether a string is valid hex.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid hex, false otherwise.\n   */\n  isHex: function (str) {\n    if (str.length % 2 === 0 && str.match(/^[0-9a-f]+$/i)) return true;\n    return false;\n  },\n\n  /**\n   * Check whether a string is valid base-64.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid base-64, false otherwise.\n   */\n  isBase64: function (str) {\n    var index;\n    if (str.length % 4 > 0 || str.match(/[^0-9a-z+\\/=]/i)) return false;\n    index = str.indexOf(\"=\");\n    if (index === -1 || str.slice(index).match(/={1,2}/)) return true;\n    return false;\n  },\n\n  /**\n   * Convert a string to a Buffer.  If encoding is not specified, hex-encoding\n   * will be used if the input is valid hex.  If the input is valid base64 but\n   * not valid hex, base64 will be used.  Otherwise, utf8 will be used.\n   * @param {string} str String to be converted.\n   * @param {string=} enc Encoding of the input string (optional).\n   * @return {Buffer} Buffer (bytearray) containing the input data.\n   */\n  str2buf: function (str, enc) {\n    if (!str || str.constructor !== String) return str;\n    if (!enc && this.isHex(str)) enc = \"hex\";\n    if (!enc && this.isBase64(str)) enc = \"base64\";\n    return Buffer.from(str, enc);\n  },\n\n  /**\n   * Check if the selected cipher is available.\n   * @param {string} cipher Encryption algorithm.\n   * @return {boolean} If available true, otherwise false.\n   */\n  isCipherAvailable: function (cipher) {\n    return this.crypto.getCiphers().some(function (name) {\n      return name === cipher;\n    });\n  },\n\n  /**\n   * Symmetric private key encryption using secret (derived) key.\n   * @param {Buffer|string} plaintext Data to be encrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Encrypted data.\n   */\n  encrypt: function (plaintext, key, iv, algo) {\n    var cipher, ciphertext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    cipher = this.crypto.createCipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    ciphertext = cipher.update(this.str2buf(plaintext));\n    return Buffer.concat([ciphertext, cipher.final()]);\n  },\n\n  /**\n   * Symmetric private key decryption using secret (derived) key.\n   * @param {Buffer|string} ciphertext Data to be decrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Decrypted data.\n   */\n  decrypt: function (ciphertext, key, iv, algo) {\n    var decipher, plaintext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    decipher = this.crypto.createDecipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    plaintext = decipher.update(this.str2buf(ciphertext));\n    return Buffer.concat([plaintext, decipher.final()]);\n  },\n\n  /**\n   * Derive Ethereum address from private key.\n   * @param {Buffer|string} privateKey ECDSA private key.\n   * @return {string} Hex-encoded Ethereum address.\n   */\n  privateKeyToAddress: function (privateKey) {\n    var privateKeyBuffer, publicKey;\n    privateKeyBuffer = this.str2buf(privateKey);\n\n    if (privateKeyBuffer.length < 32) {\n      privateKeyBuffer = Buffer.concat([Buffer.alloc(32 - privateKeyBuffer.length, 0), privateKeyBuffer]);\n    }\n\n    publicKey = Buffer.from(secp256k1.publicKeyCreate(privateKeyBuffer, false).slice(1));\n    return \"0x\" + keccak256(publicKey).slice(-20).toString(\"hex\");\n  },\n\n  /**\n   * Calculate message authentication code from secret (derived) key and\n   * encrypted text.  The MAC is the keccak-256 hash of the byte array\n   * formed by concatenating the second 16 bytes of the derived key with\n   * the ciphertext key's contents.\n   * @param {Buffer|string} derivedKey Secret key derived from password.\n   * @param {Buffer|string} ciphertext Text encrypted with secret key.\n   * @return {string} Hex-encoded MAC.\n   */\n  getMAC: function (derivedKey, ciphertext) {\n    if (derivedKey !== undefined && derivedKey !== null && ciphertext !== undefined && ciphertext !== null) {\n      return keccak256(Buffer.concat([this.str2buf(derivedKey).slice(16, 32), this.str2buf(ciphertext)])).toString(\"hex\");\n    }\n  },\n\n  /**\n   * Used internally.\n   */\n  deriveKeyUsingScrypt: function (password, salt, options, cb) {\n    var n = options.kdfparams.n || this.constants.scrypt.n;\n    var r = options.kdfparams.r || this.constants.scrypt.r;\n    var p = options.kdfparams.p || this.constants.scrypt.p;\n    var dklen = options.kdfparams.dklen || this.constants.scrypt.dklen;\n\n    if (isFunction(cb)) {\n      scrypt.scrypt(password, salt, n, r, p, dklen).then(function (key) {\n        cb(Buffer.from(key));\n      }).catch(cb);\n    } else {\n      return Buffer.from(scrypt.syncScrypt(password, salt, n, r, p, dklen));\n    }\n  },\n\n  /**\n   * Derive secret key from password with key dervation function.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Secret key derived from password.\n   */\n  deriveKey: function (password, salt, options, cb) {\n    var prf,\n        self = this;\n\n    if (typeof password === \"undefined\" || password === null || !salt) {\n      throw new Error(\"Must provide password and salt to derive a key\");\n    }\n\n    options = options || {};\n    options.kdfparams = options.kdfparams || {}; // convert strings to buffers\n\n    password = this.str2buf(password, \"utf8\");\n    salt = this.str2buf(salt); // use scrypt as key derivation function\n\n    if (options.kdf === \"scrypt\") {\n      return this.deriveKeyUsingScrypt(password, salt, options, cb);\n    } // use default key derivation function (PBKDF2)\n\n\n    prf = options.kdfparams.prf || this.constants.pbkdf2.prf;\n    if (prf === \"hmac-sha256\") prf = \"sha256\";\n\n    if (!isFunction(cb)) {\n      if (!this.crypto.pbkdf2Sync) {\n        return Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(password.toString(\"utf8\"), sjcl.codec.hex.toBits(salt.toString(\"hex\")), options.kdfparams.c || self.constants.pbkdf2.c, (options.kdfparams.dklen || self.constants.pbkdf2.dklen) * 8)), \"hex\");\n      }\n\n      return this.crypto.pbkdf2Sync(password, salt, options.kdfparams.c || this.constants.pbkdf2.c, options.kdfparams.dklen || this.constants.pbkdf2.dklen, prf);\n    }\n\n    if (!this.crypto.pbkdf2) {\n      setTimeout(function () {\n        cb(Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(password.toString(\"utf8\"), sjcl.codec.hex.toBits(salt.toString(\"hex\")), options.kdfparams.c || self.constants.pbkdf2.c, (options.kdfparams.dklen || self.constants.pbkdf2.dklen) * 8)), \"hex\"));\n      }, 0);\n    } else {\n      this.crypto.pbkdf2(password, salt, options.kdfparams.c || this.constants.pbkdf2.c, options.kdfparams.dklen || this.constants.pbkdf2.dklen, prf, function (ex, derivedKey) {\n        if (ex) return cb(ex);\n        cb(derivedKey);\n      });\n    }\n  },\n\n  /**\n   * Generate random numbers for private key, initialization vector,\n   * and salt (for key derivation).\n   * @param {Object=} params Encryption options (defaults: constants).\n   * @param {string=} params.keyBytes Private key size in bytes.\n   * @param {string=} params.ivBytes Initialization vector size in bytes.\n   * @param {function=} cb Callback function (optional).\n   * @return {Object<string,Buffer>} Private key, IV and salt.\n   */\n  create: function (params, cb) {\n    var keyBytes,\n        ivBytes,\n        self = this;\n    params = params || {};\n    keyBytes = params.keyBytes || this.constants.keyBytes;\n    ivBytes = params.ivBytes || this.constants.ivBytes;\n\n    function checkBoundsAndCreateObject(randomBytes) {\n      var privateKey = randomBytes.slice(0, keyBytes);\n      if (!secp256k1.privateKeyVerify(privateKey)) return self.create(params, cb);\n      return {\n        privateKey: privateKey,\n        iv: randomBytes.slice(keyBytes, keyBytes + ivBytes),\n        salt: randomBytes.slice(keyBytes + ivBytes)\n      };\n    } // synchronous key generation if callback not provided\n\n\n    if (!isFunction(cb)) {\n      return checkBoundsAndCreateObject(this.crypto.randomBytes(keyBytes + ivBytes + keyBytes));\n    } // asynchronous key generation\n\n\n    this.crypto.randomBytes(keyBytes + ivBytes + keyBytes, function (err, randomBytes) {\n      if (err) return cb(err);\n      cb(checkBoundsAndCreateObject(randomBytes));\n    });\n  },\n\n  /**\n   * Assemble key data object in secret-storage format.\n   * @param {Buffer} derivedKey Password-derived secret key.\n   * @param {Buffer} privateKey Private key.\n   * @param {Buffer} salt Randomly generated salt.\n   * @param {Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @return {Object}\n   */\n  marshal: function (derivedKey, privateKey, salt, iv, options) {\n    var ciphertext, keyObject, algo;\n    options = options || {};\n    options.kdfparams = options.kdfparams || {};\n    algo = options.cipher || this.constants.cipher; // encrypt using first 16 bytes of derived key\n\n    ciphertext = this.encrypt(privateKey, derivedKey.slice(0, 16), iv, algo).toString(\"hex\");\n    keyObject = {\n      address: this.privateKeyToAddress(privateKey).slice(2),\n      crypto: {\n        cipher: options.cipher || this.constants.cipher,\n        ciphertext: ciphertext,\n        cipherparams: {\n          iv: iv.toString(\"hex\")\n        },\n        mac: this.getMAC(derivedKey, ciphertext)\n      },\n      id: uuid.v4(),\n      // random 128-bit UUID\n      version: 3\n    };\n\n    if (options.kdf === \"scrypt\") {\n      keyObject.crypto.kdf = \"scrypt\";\n      keyObject.crypto.kdfparams = {\n        dklen: options.kdfparams.dklen || this.constants.scrypt.dklen,\n        n: options.kdfparams.n || this.constants.scrypt.n,\n        r: options.kdfparams.r || this.constants.scrypt.r,\n        p: options.kdfparams.p || this.constants.scrypt.p,\n        salt: salt.toString(\"hex\")\n      };\n    } else {\n      keyObject.crypto.kdf = \"pbkdf2\";\n      keyObject.crypto.kdfparams = {\n        c: options.kdfparams.c || this.constants.pbkdf2.c,\n        dklen: options.kdfparams.dklen || this.constants.pbkdf2.dklen,\n        prf: options.kdfparams.prf || this.constants.pbkdf2.prf,\n        salt: salt.toString(\"hex\")\n      };\n    }\n\n    return keyObject;\n  },\n\n  /**\n   * Export private key to keystore secret-storage format.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} privateKey Private key.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {string|Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object}\n   */\n  dump: function (password, privateKey, salt, iv, options, cb) {\n    options = options || {};\n    iv = this.str2buf(iv);\n    privateKey = this.str2buf(privateKey); // synchronous if no callback provided\n\n    if (!isFunction(cb)) {\n      return this.marshal(this.deriveKey(password, salt, options), privateKey, salt, iv, options);\n    } // asynchronous if callback provided\n\n\n    this.deriveKey(password, salt, options, function (derivedKey) {\n      cb(this.marshal(derivedKey, privateKey, salt, iv, options));\n    }.bind(this));\n  },\n\n  /**\n   * Recover plaintext private key from secret-storage key object.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {Object} keyObject Keystore object.\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Plaintext private key.\n   */\n  recover: function (password, keyObject, cb) {\n    var keyObjectCrypto,\n        iv,\n        salt,\n        ciphertext,\n        algo,\n        self = this;\n    keyObjectCrypto = keyObject.Crypto || keyObject.crypto; // verify that message authentication codes match, then decrypt\n\n    function verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo) {\n      var key;\n\n      if (self.getMAC(derivedKey, ciphertext) !== keyObjectCrypto.mac) {\n        throw new Error(\"message authentication code mismatch\");\n      }\n\n      if (keyObject.version === \"1\") {\n        key = keccak256(derivedKey.slice(0, 16)).slice(0, 16);\n      } else {\n        key = derivedKey.slice(0, 16);\n      }\n\n      return self.decrypt(ciphertext, key, iv, algo);\n    }\n\n    iv = this.str2buf(keyObjectCrypto.cipherparams.iv);\n    salt = this.str2buf(keyObjectCrypto.kdfparams.salt);\n    ciphertext = this.str2buf(keyObjectCrypto.ciphertext);\n    algo = keyObjectCrypto.cipher;\n\n    if (keyObjectCrypto.kdf === \"pbkdf2\" && keyObjectCrypto.kdfparams.prf !== \"hmac-sha256\") {\n      throw new Error(\"PBKDF2 only supported with HMAC-SHA256\");\n    } // derive secret key from password\n\n\n    if (!isFunction(cb)) {\n      return verifyAndDecrypt(this.deriveKey(password, salt, keyObjectCrypto), salt, iv, ciphertext, algo);\n    }\n\n    this.deriveKey(password, salt, keyObjectCrypto, function (derivedKey) {\n      try {\n        cb(verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo));\n      } catch (exc) {\n        cb(exc);\n      }\n    });\n  },\n\n  /**\n   * Generate filename for a keystore file.\n   * @param {string} address Ethereum address.\n   * @return {string} Keystore filename.\n   */\n  generateKeystoreFilename: function (address) {\n    var filename = \"UTC--\" + new Date().toISOString() + \"--\" + address; // Windows does not permit \":\" in filenames, replace all with \"-\"\n\n    if (process.platform === \"win32\") filename = filename.split(\":\").join(\"-\");\n    return filename;\n  },\n\n  /**\n   * Export formatted JSON to keystore file.\n   * @param {Object} keyObject Keystore object.\n   * @param {string=} keystore Path to keystore folder (default: \"keystore\").\n   * @param {function=} cb Callback function (optional).\n   * @return {string} JSON filename (Node.js) or JSON string (browser).\n   */\n  exportToFile: function (keyObject, keystore, cb) {\n    var outfile, outpath, json, fs;\n    keystore = keystore || \"keystore\";\n    outfile = this.generateKeystoreFilename(keyObject.address);\n    json = JSON.stringify(keyObject);\n\n    if (this.browser) {\n      if (!isFunction(cb)) return json;\n      return cb(json);\n    }\n\n    outpath = require(\"path\").join(keystore, outfile);\n    fs = require(\"fs\");\n\n    if (!isFunction(cb)) {\n      fs.writeFileSync(outpath, json);\n      return outpath;\n    }\n\n    fs.writeFile(outpath, json, function (err) {\n      if (err) return cb(err);\n      cb(outpath);\n    });\n  },\n\n  /**\n   * Import key data object from keystore JSON file.\n   * (Note: Node.js only!)\n   * @param {string} address Ethereum address to import.\n   * @param {string=} datadir Ethereum data directory (default: ~/.ethereum).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object} Keystore data file's contents.\n   */\n  importFromFile: function (address, datadir, cb) {\n    var keystore, filepath, path, fs;\n    if (this.browser) throw new Error(\"method only available in Node.js\");\n    path = require(\"path\");\n    fs = require(\"fs\");\n    address = address.replace(\"0x\", \"\");\n    address = address.toLowerCase();\n\n    function findKeyfile(keystore, address, files) {\n      var i,\n          len,\n          filepath = null;\n\n      for (i = 0, len = files.length; i < len; ++i) {\n        if (files[i].indexOf(address) > -1) {\n          filepath = path.join(keystore, files[i]);\n\n          if (fs.lstatSync(filepath).isDirectory()) {\n            filepath = path.join(filepath, files[i]);\n          }\n\n          break;\n        }\n      }\n\n      return filepath;\n    }\n\n    datadir = datadir || path.join(process.env.HOME, \".ethereum\");\n    keystore = path.join(datadir, \"keystore\");\n\n    if (!isFunction(cb)) {\n      filepath = findKeyfile(keystore, address, fs.readdirSync(keystore));\n\n      if (!filepath) {\n        throw new Error(\"could not find key file for address \" + address);\n      }\n\n      return JSON.parse(fs.readFileSync(filepath));\n    }\n\n    fs.readdir(keystore, function (ex, files) {\n      var filepath;\n      if (ex) return cb(ex);\n      filepath = findKeyfile(keystore, address, files);\n\n      if (!filepath) {\n        return cb(new Error(\"could not find key file for address \" + address));\n      }\n\n      return cb(JSON.parse(fs.readFileSync(filepath)));\n    });\n  }\n};","map":{"version":3,"names":["isBrowser","process","nextTick","Boolean","browser","sjcl","require","uuid","secp256k1","createKeccakHash","scrypt","isFunction","f","keccak256","buffer","update","digest","module","exports","version","crypto","constants","cipher","ivBytes","keyBytes","pbkdf2","c","dklen","hash","prf","memory","n","r","p","isHex","str","length","match","isBase64","index","indexOf","slice","str2buf","enc","constructor","String","Buffer","from","isCipherAvailable","getCiphers","some","name","encrypt","plaintext","key","iv","algo","ciphertext","Error","createCipheriv","concat","final","decrypt","decipher","createDecipheriv","privateKeyToAddress","privateKey","privateKeyBuffer","publicKey","alloc","publicKeyCreate","toString","getMAC","derivedKey","undefined","deriveKeyUsingScrypt","password","salt","options","cb","kdfparams","then","catch","syncScrypt","deriveKey","self","kdf","pbkdf2Sync","codec","hex","fromBits","misc","toBits","setTimeout","ex","create","params","checkBoundsAndCreateObject","randomBytes","privateKeyVerify","err","marshal","keyObject","address","cipherparams","mac","id","v4","dump","bind","recover","keyObjectCrypto","Crypto","verifyAndDecrypt","exc","generateKeystoreFilename","filename","Date","toISOString","platform","split","join","exportToFile","keystore","outfile","outpath","json","fs","JSON","stringify","writeFileSync","writeFile","importFromFile","datadir","filepath","path","replace","toLowerCase","findKeyfile","files","i","len","lstatSync","isDirectory","env","HOME","readdirSync","parse","readFileSync","readdir"],"sources":["/Users/matthewfogel/Desktop/hackfs2022/chrome-react-seo-extension/node_modules/keythereum/index.js"],"sourcesContent":["/**\n * Create, import, and export ethereum keys.\n * @author Jack Peterson (jack@tinybike.net)\n */\n\n\"use strict\";\n\nvar isBrowser = typeof process === \"undefined\" || !process.nextTick || Boolean(process.browser);\n\nvar sjcl = require(\"sjcl\");\nvar uuid = require(\"uuid\");\nvar secp256k1 = require(\"secp256k1/elliptic\");\nvar createKeccakHash = require(\"keccak/js\");\nvar scrypt = require(\"scrypt-js\");\n\nfunction isFunction(f) {\n  return typeof f === \"function\";\n}\n\nfunction keccak256(buffer) {\n  return createKeccakHash(\"keccak256\").update(buffer).digest();\n}\n\nmodule.exports = {\n\n  version: \"1.1.0\",\n\n  browser: isBrowser,\n\n  scrypt: null,\n\n  crypto: isBrowser ? require(\"crypto-browserify\") : require(\"crypto\"),\n\n  constants: {\n\n    // Symmetric cipher for private key encryption\n    cipher: \"aes-128-ctr\",\n\n    // Initialization vector size in bytes\n    ivBytes: 16,\n\n    // ECDSA private key size in bytes\n    keyBytes: 32,\n\n    // Key derivation function parameters\n    pbkdf2: {\n      c: 262144,\n      dklen: 32,\n      hash: \"sha256\",\n      prf: \"hmac-sha256\"\n    },\n    scrypt: {\n      memory: 280000000,\n      dklen: 32,\n      n: 262144,\n      r: 8,\n      p: 1\n    }\n  },\n\n  /**\n   * Check whether a string is valid hex.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid hex, false otherwise.\n   */\n  isHex: function (str) {\n    if (str.length % 2 === 0 && str.match(/^[0-9a-f]+$/i)) return true;\n    return false;\n  },\n\n  /**\n   * Check whether a string is valid base-64.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid base-64, false otherwise.\n   */\n  isBase64: function (str) {\n    var index;\n    if (str.length % 4 > 0 || str.match(/[^0-9a-z+\\/=]/i)) return false;\n    index = str.indexOf(\"=\");\n    if (index === -1 || str.slice(index).match(/={1,2}/)) return true;\n    return false;\n  },\n\n  /**\n   * Convert a string to a Buffer.  If encoding is not specified, hex-encoding\n   * will be used if the input is valid hex.  If the input is valid base64 but\n   * not valid hex, base64 will be used.  Otherwise, utf8 will be used.\n   * @param {string} str String to be converted.\n   * @param {string=} enc Encoding of the input string (optional).\n   * @return {Buffer} Buffer (bytearray) containing the input data.\n   */\n  str2buf: function (str, enc) {\n    if (!str || str.constructor !== String) return str;\n    if (!enc && this.isHex(str)) enc = \"hex\";\n    if (!enc && this.isBase64(str)) enc = \"base64\";\n    return Buffer.from(str, enc);\n  },\n\n  /**\n   * Check if the selected cipher is available.\n   * @param {string} cipher Encryption algorithm.\n   * @return {boolean} If available true, otherwise false.\n   */\n  isCipherAvailable: function (cipher) {\n    return this.crypto.getCiphers().some(function (name) { return name === cipher; });\n  },\n\n  /**\n   * Symmetric private key encryption using secret (derived) key.\n   * @param {Buffer|string} plaintext Data to be encrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Encrypted data.\n   */\n  encrypt: function (plaintext, key, iv, algo) {\n    var cipher, ciphertext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    cipher = this.crypto.createCipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    ciphertext = cipher.update(this.str2buf(plaintext));\n    return Buffer.concat([ciphertext, cipher.final()]);\n  },\n\n  /**\n   * Symmetric private key decryption using secret (derived) key.\n   * @param {Buffer|string} ciphertext Data to be decrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Decrypted data.\n   */\n  decrypt: function (ciphertext, key, iv, algo) {\n    var decipher, plaintext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    decipher = this.crypto.createDecipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    plaintext = decipher.update(this.str2buf(ciphertext));\n    return Buffer.concat([plaintext, decipher.final()]);\n  },\n\n  /**\n   * Derive Ethereum address from private key.\n   * @param {Buffer|string} privateKey ECDSA private key.\n   * @return {string} Hex-encoded Ethereum address.\n   */\n  privateKeyToAddress: function (privateKey) {\n    var privateKeyBuffer, publicKey;\n    privateKeyBuffer = this.str2buf(privateKey);\n    if (privateKeyBuffer.length < 32) {\n      privateKeyBuffer = Buffer.concat([\n        Buffer.alloc(32 - privateKeyBuffer.length, 0),\n        privateKeyBuffer\n      ]);\n    }\n    publicKey = Buffer.from(\n      secp256k1.publicKeyCreate(privateKeyBuffer, false).slice(1)\n    );\n    return \"0x\" + keccak256(publicKey).slice(-20).toString(\"hex\");\n  },\n\n  /**\n   * Calculate message authentication code from secret (derived) key and\n   * encrypted text.  The MAC is the keccak-256 hash of the byte array\n   * formed by concatenating the second 16 bytes of the derived key with\n   * the ciphertext key's contents.\n   * @param {Buffer|string} derivedKey Secret key derived from password.\n   * @param {Buffer|string} ciphertext Text encrypted with secret key.\n   * @return {string} Hex-encoded MAC.\n   */\n  getMAC: function (derivedKey, ciphertext) {\n    if (derivedKey !== undefined && derivedKey !== null && ciphertext !== undefined && ciphertext !== null) {\n      return keccak256(Buffer.concat([\n        this.str2buf(derivedKey).slice(16, 32),\n        this.str2buf(ciphertext)\n      ])).toString(\"hex\");\n    }\n  },\n\n  /**\n   * Used internally.\n   */\n  deriveKeyUsingScrypt: function (password, salt, options, cb) {\n    var n = options.kdfparams.n || this.constants.scrypt.n;\n    var r = options.kdfparams.r || this.constants.scrypt.r;\n    var p = options.kdfparams.p || this.constants.scrypt.p;\n    var dklen = options.kdfparams.dklen || this.constants.scrypt.dklen;\n    if (isFunction(cb)) {\n      scrypt\n        .scrypt(password, salt, n, r, p, dklen)\n        .then(function (key) {\n          cb(Buffer.from(key));\n        })\n        .catch(cb);\n    } else {\n      return Buffer.from(scrypt.syncScrypt(password, salt, n, r, p, dklen));\n    }\n  },\n\n  /**\n   * Derive secret key from password with key dervation function.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Secret key derived from password.\n   */\n  deriveKey: function (password, salt, options, cb) {\n    var prf, self = this;\n    if (typeof password === \"undefined\" || password === null || !salt) {\n      throw new Error(\"Must provide password and salt to derive a key\");\n    }\n    options = options || {};\n    options.kdfparams = options.kdfparams || {};\n\n    // convert strings to buffers\n    password = this.str2buf(password, \"utf8\");\n    salt = this.str2buf(salt);\n\n    // use scrypt as key derivation function\n    if (options.kdf === \"scrypt\") {\n      return this.deriveKeyUsingScrypt(password, salt, options, cb);\n    }\n\n    // use default key derivation function (PBKDF2)\n    prf = options.kdfparams.prf || this.constants.pbkdf2.prf;\n    if (prf === \"hmac-sha256\") prf = \"sha256\";\n    if (!isFunction(cb)) {\n      if (!this.crypto.pbkdf2Sync) {\n        return Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(\n          password.toString(\"utf8\"),\n          sjcl.codec.hex.toBits(salt.toString(\"hex\")),\n          options.kdfparams.c || self.constants.pbkdf2.c,\n          (options.kdfparams.dklen || self.constants.pbkdf2.dklen)*8\n        )), \"hex\");\n      }\n      return this.crypto.pbkdf2Sync(\n        password,\n        salt,\n        options.kdfparams.c || this.constants.pbkdf2.c,\n        options.kdfparams.dklen || this.constants.pbkdf2.dklen,\n        prf\n      );\n    }\n    if (!this.crypto.pbkdf2) {\n      setTimeout(function () {\n        cb(Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(\n          password.toString(\"utf8\"),\n          sjcl.codec.hex.toBits(salt.toString(\"hex\")),\n          options.kdfparams.c || self.constants.pbkdf2.c,\n          (options.kdfparams.dklen || self.constants.pbkdf2.dklen)*8\n        )), \"hex\"));\n      }, 0);\n    } else {\n      this.crypto.pbkdf2(\n        password,\n        salt,\n        options.kdfparams.c || this.constants.pbkdf2.c,\n        options.kdfparams.dklen || this.constants.pbkdf2.dklen,\n        prf,\n        function (ex, derivedKey) {\n          if (ex) return cb(ex);\n          cb(derivedKey);\n        }\n      );\n    }\n  },\n\n  /**\n   * Generate random numbers for private key, initialization vector,\n   * and salt (for key derivation).\n   * @param {Object=} params Encryption options (defaults: constants).\n   * @param {string=} params.keyBytes Private key size in bytes.\n   * @param {string=} params.ivBytes Initialization vector size in bytes.\n   * @param {function=} cb Callback function (optional).\n   * @return {Object<string,Buffer>} Private key, IV and salt.\n   */\n  create: function (params, cb) {\n    var keyBytes, ivBytes, self = this;\n    params = params || {};\n    keyBytes = params.keyBytes || this.constants.keyBytes;\n    ivBytes = params.ivBytes || this.constants.ivBytes;\n\n    function checkBoundsAndCreateObject(randomBytes) {\n      var privateKey = randomBytes.slice(0, keyBytes);\n      if (!secp256k1.privateKeyVerify(privateKey)) return self.create(params, cb);\n      return {\n        privateKey: privateKey,\n        iv: randomBytes.slice(keyBytes, keyBytes + ivBytes),\n        salt: randomBytes.slice(keyBytes + ivBytes)\n      };\n    }\n\n    // synchronous key generation if callback not provided\n    if (!isFunction(cb)) {\n      return checkBoundsAndCreateObject(this.crypto.randomBytes(keyBytes + ivBytes + keyBytes));\n    }\n\n    // asynchronous key generation\n    this.crypto.randomBytes(keyBytes + ivBytes + keyBytes, function (err, randomBytes) {\n      if (err) return cb(err);\n      cb(checkBoundsAndCreateObject(randomBytes));\n    });\n  },\n\n  /**\n   * Assemble key data object in secret-storage format.\n   * @param {Buffer} derivedKey Password-derived secret key.\n   * @param {Buffer} privateKey Private key.\n   * @param {Buffer} salt Randomly generated salt.\n   * @param {Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @return {Object}\n   */\n  marshal: function (derivedKey, privateKey, salt, iv, options) {\n    var ciphertext, keyObject, algo;\n    options = options || {};\n    options.kdfparams = options.kdfparams || {};\n    algo = options.cipher || this.constants.cipher;\n\n    // encrypt using first 16 bytes of derived key\n    ciphertext = this.encrypt(privateKey, derivedKey.slice(0, 16), iv, algo).toString(\"hex\");\n\n    keyObject = {\n      address: this.privateKeyToAddress(privateKey).slice(2),\n      crypto: {\n        cipher: options.cipher || this.constants.cipher,\n        ciphertext: ciphertext,\n        cipherparams: { iv: iv.toString(\"hex\") },\n        mac: this.getMAC(derivedKey, ciphertext)\n      },\n      id: uuid.v4(), // random 128-bit UUID\n      version: 3\n    };\n\n    if (options.kdf === \"scrypt\") {\n      keyObject.crypto.kdf = \"scrypt\";\n      keyObject.crypto.kdfparams = {\n        dklen: options.kdfparams.dklen || this.constants.scrypt.dklen,\n        n: options.kdfparams.n || this.constants.scrypt.n,\n        r: options.kdfparams.r || this.constants.scrypt.r,\n        p: options.kdfparams.p || this.constants.scrypt.p,\n        salt: salt.toString(\"hex\")\n      };\n\n    } else {\n      keyObject.crypto.kdf = \"pbkdf2\";\n      keyObject.crypto.kdfparams = {\n        c: options.kdfparams.c || this.constants.pbkdf2.c,\n        dklen: options.kdfparams.dklen || this.constants.pbkdf2.dklen,\n        prf: options.kdfparams.prf || this.constants.pbkdf2.prf,\n        salt: salt.toString(\"hex\")\n      };\n    }\n\n    return keyObject;\n  },\n\n  /**\n   * Export private key to keystore secret-storage format.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} privateKey Private key.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {string|Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object}\n   */\n  dump: function (password, privateKey, salt, iv, options, cb) {\n    options = options || {};\n    iv = this.str2buf(iv);\n    privateKey = this.str2buf(privateKey);\n\n    // synchronous if no callback provided\n    if (!isFunction(cb)) {\n      return this.marshal(this.deriveKey(password, salt, options), privateKey, salt, iv, options);\n    }\n\n    // asynchronous if callback provided\n    this.deriveKey(password, salt, options, function (derivedKey) {\n      cb(this.marshal(derivedKey, privateKey, salt, iv, options));\n    }.bind(this));\n  },\n\n  /**\n   * Recover plaintext private key from secret-storage key object.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {Object} keyObject Keystore object.\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Plaintext private key.\n   */\n  recover: function (password, keyObject, cb) {\n    var keyObjectCrypto, iv, salt, ciphertext, algo, self = this;\n    keyObjectCrypto = keyObject.Crypto || keyObject.crypto;\n\n    // verify that message authentication codes match, then decrypt\n    function verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo) {\n      var key;\n      if (self.getMAC(derivedKey, ciphertext) !== keyObjectCrypto.mac) {\n        throw new Error(\"message authentication code mismatch\");\n      }\n      if (keyObject.version === \"1\") {\n        key = keccak256(derivedKey.slice(0, 16)).slice(0, 16);\n      } else {\n        key = derivedKey.slice(0, 16);\n      }\n      return self.decrypt(ciphertext, key, iv, algo);\n    }\n\n    iv = this.str2buf(keyObjectCrypto.cipherparams.iv);\n    salt = this.str2buf(keyObjectCrypto.kdfparams.salt);\n    ciphertext = this.str2buf(keyObjectCrypto.ciphertext);\n    algo = keyObjectCrypto.cipher;\n\n    if (keyObjectCrypto.kdf === \"pbkdf2\" && keyObjectCrypto.kdfparams.prf !== \"hmac-sha256\") {\n      throw new Error(\"PBKDF2 only supported with HMAC-SHA256\");\n    }\n\n    // derive secret key from password\n    if (!isFunction(cb)) {\n      return verifyAndDecrypt(this.deriveKey(password, salt, keyObjectCrypto), salt, iv, ciphertext, algo);\n    }\n    this.deriveKey(password, salt, keyObjectCrypto, function (derivedKey) {\n      try {\n        cb(verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo));\n      } catch (exc) {\n        cb(exc);\n      }\n    });\n  },\n\n  /**\n   * Generate filename for a keystore file.\n   * @param {string} address Ethereum address.\n   * @return {string} Keystore filename.\n   */\n  generateKeystoreFilename: function (address) {\n    var filename = \"UTC--\" + new Date().toISOString() + \"--\" + address;\n\n    // Windows does not permit \":\" in filenames, replace all with \"-\"\n    if (process.platform === \"win32\") filename = filename.split(\":\").join(\"-\");\n\n    return filename;\n  },\n\n  /**\n   * Export formatted JSON to keystore file.\n   * @param {Object} keyObject Keystore object.\n   * @param {string=} keystore Path to keystore folder (default: \"keystore\").\n   * @param {function=} cb Callback function (optional).\n   * @return {string} JSON filename (Node.js) or JSON string (browser).\n   */\n  exportToFile: function (keyObject, keystore, cb) {\n    var outfile, outpath, json, fs;\n    keystore = keystore || \"keystore\";\n    outfile = this.generateKeystoreFilename(keyObject.address);\n    json = JSON.stringify(keyObject);\n    if (this.browser) {\n      if (!isFunction(cb)) return json;\n      return cb(json);\n    }\n    outpath = require(\"path\").join(keystore, outfile);\n    fs = require(\"fs\");\n    if (!isFunction(cb)) {\n      fs.writeFileSync(outpath, json);\n      return outpath;\n    }\n    fs.writeFile(outpath, json, function (err) {\n      if (err) return cb(err);\n      cb(outpath);\n    });\n  },\n\n  /**\n   * Import key data object from keystore JSON file.\n   * (Note: Node.js only!)\n   * @param {string} address Ethereum address to import.\n   * @param {string=} datadir Ethereum data directory (default: ~/.ethereum).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object} Keystore data file's contents.\n   */\n  importFromFile: function (address, datadir, cb) {\n    var keystore, filepath, path, fs;\n    if (this.browser) throw new Error(\"method only available in Node.js\");\n    path = require(\"path\");\n    fs = require(\"fs\");\n    address = address.replace(\"0x\", \"\");\n    address = address.toLowerCase();\n\n    function findKeyfile(keystore, address, files) {\n      var i, len, filepath = null;\n      for (i = 0, len = files.length; i < len; ++i) {\n        if (files[i].indexOf(address) > -1) {\n          filepath = path.join(keystore, files[i]);\n          if (fs.lstatSync(filepath).isDirectory()) {\n            filepath = path.join(filepath, files[i]);\n          }\n          break;\n        }\n      }\n      return filepath;\n    }\n\n    datadir = datadir || path.join(process.env.HOME, \".ethereum\");\n    keystore = path.join(datadir, \"keystore\");\n    if (!isFunction(cb)) {\n      filepath = findKeyfile(keystore, address, fs.readdirSync(keystore));\n      if (!filepath) {\n        throw new Error(\"could not find key file for address \" + address);\n      }\n      return JSON.parse(fs.readFileSync(filepath));\n    }\n    fs.readdir(keystore, function (ex, files) {\n      var filepath;\n      if (ex) return cb(ex);\n      filepath = findKeyfile(keystore, address, files);\n      if (!filepath) {\n        return cb(new Error(\"could not find key file for address \" + address));\n      }\n      return cb(JSON.parse(fs.readFileSync(filepath)));\n    });\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}