"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWaku = exports.defaultOptions = exports.Compression = exports.KeyStoreType = void 0;
const js_waku_1 = require("js-waku");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const crypto_1 = require("./crypto");
const Message_1 = __importDefault(require("./Message"));
const utils_1 = require("./utils");
const helpers_1 = require("../test/helpers");
const Stream_1 = __importDefault(require("./Stream"));
const store_1 = require("./store");
const conversations_1 = require("./conversations");
const Text_1 = require("./codecs/Text");
const MessageContent_1 = require("./MessageContent");
const Compression_1 = require("./Compression");
const messaging_1 = require("./proto/messaging");
Object.defineProperty(exports, "Compression", { enumerable: true, get: function () { return messaging_1.Compression; } });
const proto = __importStar(require("./proto/messaging"));
const ContactBundle_1 = __importDefault(require("./ContactBundle"));
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
const NODES_LIST_URL = 'https://nodes.xmtp.com/';
// Default maximum allowed content size
const MaxContentSize = 100 * 1024 * 1024; // 100M
var KeyStoreType;
(function (KeyStoreType) {
    KeyStoreType[KeyStoreType["networkTopicStoreV1"] = 0] = "networkTopicStoreV1";
    KeyStoreType[KeyStoreType["localStorage"] = 1] = "localStorage";
})(KeyStoreType = exports.KeyStoreType || (exports.KeyStoreType = {}));
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
function defaultOptions(opts) {
    const _defaultOptions = {
        keyStoreType: KeyStoreType.networkTopicStoreV1,
        env: 'dev',
        waitForPeersTimeoutMs: 10000,
        codecs: [new Text_1.TextCodec()],
        maxContentSize: MaxContentSize,
    };
    if (opts === null || opts === void 0 ? void 0 : opts.codecs) {
        opts.codecs = _defaultOptions.codecs.concat(opts.codecs);
    }
    return Object.assign(Object.assign({}, _defaultOptions), opts);
}
exports.defaultOptions = defaultOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
class Client {
    constructor(waku, keys) {
        this.waku = waku;
        this.contacts = new Set();
        this.knownPublicKeyBundles = new Map();
        this.keys = keys;
        this.address = keys.identityKey.publicKey.walletSignatureAddress();
        this._conversations = new conversations_1.Conversations(this);
        this._codecs = new Map();
        this._maxContentSize = MaxContentSize;
        this._disconnectWatcher = this.createDisconnectWatcher();
    }
    /**
     * @type {Conversations}
     */
    get conversations() {
        return this._conversations;
    }
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = defaultOptions(opts);
            const waku = yield createWaku(options);
            const keyStore = createKeyStoreFromConfig(options, wallet, waku);
            const keys = yield loadOrCreateKeys(wallet, keyStore);
            const client = new Client(waku, keys);
            options.codecs.forEach((codec) => {
                client.registerCodec(codec);
            });
            client._maxContentSize = options.maxContentSize;
            yield client.publishUserContact();
            return client;
        });
    }
    // gracefully shut down the client
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            clearInterval(this._disconnectWatcher);
            return this.waku.stop();
        });
    }
    // publish the key bundle into the contact topic
    publishUserContact() {
        return __awaiter(this, void 0, void 0, function* () {
            const pub = this.keys.getPublicKeyBundle();
            yield (0, utils_1.publishUserContact)(this.waku, pub, this.address);
        });
    }
    // retrieve a key bundle from given user's contact topic
    getUserContactFromNetwork(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            // have to avoid undefined to not trip TS's strictNullChecks on recipientKey
            let recipientKey = null;
            yield this.waku.store.queryHistory([(0, utils_1.buildUserContactTopic)(peerAddress)], {
                pageSize: 5,
                pageDirection: js_waku_1.PageDirection.BACKWARD,
                callback: (msgs) => {
                    for (const msg of msgs) {
                        if (!msg.payload)
                            continue;
                        const bundle = ContactBundle_1.default.fromBytes(msg.payload);
                        const keyBundle = bundle.keyBundle;
                        const address = keyBundle === null || keyBundle === void 0 ? void 0 : keyBundle.walletSignatureAddress();
                        if (address === peerAddress) {
                            recipientKey = keyBundle;
                            break;
                        }
                    }
                    return recipientKey !== null;
                },
            });
            return recipientKey === null ? undefined : recipientKey;
        });
    }
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingBundle = this.knownPublicKeyBundles.get(peerAddress);
            if (existingBundle) {
                return existingBundle;
            }
            const newBundle = yield this.getUserContactFromNetwork(peerAddress);
            if (newBundle) {
                this.knownPublicKeyBundles.set(peerAddress, newBundle);
            }
            return newBundle;
        });
    }
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyBundle = yield this.getUserContact(peerAddress);
            return keyBundle !== undefined;
        });
    }
    /**
     * Send a message to the wallet identified by @peerAddress
     */
    sendMessage(peerAddress, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            const recipient = yield this.getUserContact(peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${peerAddress} is not registered`);
            }
            if (!this.contacts.has(peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(peerAddress),
                    (0, utils_1.buildDirectMessageTopic)(this.address, peerAddress),
                ];
                if (peerAddress !== this.address) {
                    topics.push((0, utils_1.buildUserIntroTopic)(this.address));
                }
                this.contacts.add(peerAddress);
            }
            else {
                topics = [(0, utils_1.buildDirectMessageTopic)(this.address, peerAddress)];
            }
            const timestamp = (options === null || options === void 0 ? void 0 : options.timestamp) || new Date();
            const msg = yield this.encodeMessage(recipient, timestamp, content, options);
            yield Promise.all(topics.map((topic) => __awaiter(this, void 0, void 0, function* () {
                const wakuMsg = yield js_waku_1.WakuMessage.fromBytes(msg.toBytes(), topic, {
                    timestamp,
                });
                return this.sendWakuMessage(wakuMsg);
            })));
        });
    }
    sendWakuMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const ack = yield this.waku.lightPush.push(msg);
            if ((ack === null || ack === void 0 ? void 0 : ack.isSuccess) === false) {
                throw new Error(`Failed to send message with error: ${ack === null || ack === void 0 ? void 0 : ack.info}`);
            }
        });
    }
    registerCodec(codec) {
        const id = codec.contentType;
        const key = `${id.authorityId}/${id.typeId}`;
        this._codecs.set(key, codec);
    }
    codecFor(contentType) {
        const key = `${contentType.authorityId}/${contentType.typeId}`;
        const codec = this._codecs.get(key);
        if (!codec) {
            return undefined;
        }
        if (contentType.versionMajor > codec.contentType.versionMajor) {
            return undefined;
        }
        return codec;
    }
    encodeMessage(recipient, timestamp, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const codec = this.codecFor(contentType);
            if (!codec) {
                throw new Error('unknown content type ' + contentType);
            }
            const encoded = codec.encode(content, this);
            if (options === null || options === void 0 ? void 0 : options.contentFallback) {
                encoded.fallback = options.contentFallback;
            }
            if (options === null || options === void 0 ? void 0 : options.compression) {
                encoded.compression = options.compression;
            }
            yield (0, Compression_1.compress)(encoded);
            const payload = proto.EncodedContent.encode(encoded).finish();
            return Message_1.default.encode(this.keys, recipient, payload, timestamp);
        });
    }
    decodeMessage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield Message_1.default.decode(this.keys, payload);
            if (message.error) {
                return message;
            }
            if (!message.decrypted) {
                throw new Error('decrypted bytes missing');
            }
            const encoded = proto.EncodedContent.decode(message.decrypted);
            yield (0, Compression_1.decompress)(encoded, this._maxContentSize);
            if (!encoded.type) {
                throw new Error('missing content type');
            }
            const contentType = new MessageContent_1.ContentTypeId(encoded.type);
            const codec = this.codecFor(contentType);
            if (codec) {
                message.content = codec.decode(encoded, this);
                message.contentType = contentType;
            }
            else {
                message.error = new Error('unknown content type ' + contentType);
                if (encoded.fallback) {
                    message.content = encoded.fallback;
                    message.contentType = MessageContent_1.ContentTypeFallback;
                }
            }
            return message;
        });
    }
    streamIntroductionMessages() {
        return Stream_1.default.create(this, (0, utils_1.buildUserIntroTopic)(this.address), noTransformation);
    }
    streamConversationMessages(peerAddress) {
        const topic = (0, utils_1.buildDirectMessageTopic)(peerAddress, this.address);
        return Stream_1.default.create(this, topic, noTransformation, filterForTopic(topic));
    }
    // list stored messages from this wallet's introduction topic
    listIntroductionMessages(opts) {
        return this.listMessages((0, utils_1.buildUserIntroTopic)(this.address), opts);
    }
    // list stored messages from conversation topic with the peer
    listConversationMessages(peerAddress, opts) {
        return this.listMessages((0, utils_1.buildDirectMessageTopic)(peerAddress, this.address), Object.assign(Object.assign({}, opts), { checkAddresses: true }));
    }
    // list stored messages from the specified topic
    listMessages(topic, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!opts) {
                opts = {};
            }
            if (!opts.startTime) {
                opts.startTime = new Date(0);
            }
            if (!opts.endTime) {
                opts.endTime = new Date(new Date().toUTCString());
            }
            if (!opts.pageSize) {
                opts.pageSize = 10;
            }
            let wakuMsgs = yield this.waku.store.queryHistory([topic], {
                pageSize: opts.pageSize,
                pageDirection: js_waku_1.PageDirection.FORWARD,
                timeFilter: {
                    startTime: opts.startTime,
                    endTime: opts.endTime,
                },
            });
            wakuMsgs = wakuMsgs.filter((wakuMsg) => wakuMsg === null || wakuMsg === void 0 ? void 0 : wakuMsg.payload);
            let msgs = yield Promise.all(wakuMsgs.map((wakuMsg) => this.decodeMessage(wakuMsg.payload)));
            if (opts === null || opts === void 0 ? void 0 : opts.checkAddresses) {
                msgs = msgs.filter(filterForTopic(topic));
            }
            return msgs;
        });
    }
    createDisconnectWatcher() {
        return setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const connectionsToClose = [];
            for (const connections of this.waku.libp2p.connectionManager.connections.values()) {
                for (const connection of connections) {
                    if (!connection.streams.length) {
                        console.log(`Closing connection to ${connection.remoteAddr}`);
                        connectionsToClose.push(connection.close());
                    }
                }
            }
            yield Promise.allSettled(connectionsToClose);
        }), 10 * 1000);
    }
}
exports.default = Client;
function createKeyStoreFromConfig(opts, wallet, waku) {
    switch (opts.keyStoreType) {
        case KeyStoreType.networkTopicStoreV1:
            return createNetworkPrivateKeyStore(wallet, waku);
        case KeyStoreType.localStorage:
            return createLocalPrivateKeyStore(wallet);
    }
}
// Create Encrypted store which uses the Network to store KeyBundles
function createNetworkPrivateKeyStore(wallet, waku) {
    return new store_1.EncryptedStore(wallet, new store_1.PrivateTopicStore(waku));
}
// Create Encrypted store which uses LocalStorage to store KeyBundles
function createLocalPrivateKeyStore(wallet) {
    return new store_1.EncryptedStore(wallet, new store_1.LocalStorageStore());
}
// attempt to load pre-existing key bundle from storage,
// otherwise create new key-bundle, store it and return it
function loadOrCreateKeys(wallet, store) {
    return __awaiter(this, void 0, void 0, function* () {
        let keys = yield store.loadPrivateKeyBundle();
        if (keys) {
            return keys;
        }
        keys = yield crypto_1.PrivateKeyBundle.generate(wallet);
        yield store.storePrivateKeyBundle(keys);
        return keys;
    });
}
// initialize connection to the network
function createWaku({ bootstrapAddrs, env, waitForPeersTimeoutMs, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const bootstrap = (bootstrapAddrs === null || bootstrapAddrs === void 0 ? void 0 : bootstrapAddrs.length)
            ? {
                peers: bootstrapAddrs,
            }
            : {
                getPeers: () => getNodeList(env),
            };
        const waku = yield js_waku_1.Waku.create({
            libp2p: {
                config: {
                    pubsub: {
                        enabled: true,
                        emitSelf: true,
                    },
                },
            },
            bootstrap,
        });
        // Wait for peer connection.
        try {
            yield (0, utils_1.promiseWithTimeout)(waitForPeersTimeoutMs, () => waku.waitForRemotePeer(), 'timeout connecting to peers');
        }
        catch (err) {
            yield waku.stop();
            throw err;
        }
        // There's a race happening here even with waitForConnectedPeer; waiting
        // a few ms seems to be enough, but it would be great to fix this upstream.
        yield (0, helpers_1.sleep)(200);
        return waku;
    });
}
exports.createWaku = createWaku;
function getNodeList(env) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield (0, cross_fetch_1.default)(NODES_LIST_URL);
        const nodesList = yield res.json();
        return Object.values(nodesList[env]);
    });
}
function noTransformation(msg) {
    return msg;
}
function filterForTopic(topic) {
    return (msg) => {
        const senderAddress = msg.senderAddress;
        const recipientAddress = msg.recipientAddress;
        return (senderAddress !== undefined &&
            recipientAddress !== undefined &&
            (0, utils_1.buildDirectMessageTopic)(senderAddress, recipientAddress) === topic);
    };
}
//# sourceMappingURL=Client.js.map