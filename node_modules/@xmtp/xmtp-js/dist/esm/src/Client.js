var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Waku, WakuMessage, PageDirection } from 'js-waku';
import fetch from 'cross-fetch';
import { PrivateKeyBundle } from './crypto';
import Message from './Message';
import { buildDirectMessageTopic, buildUserContactTopic, buildUserIntroTopic, promiseWithTimeout, publishUserContact, } from './utils';
import { sleep } from '../test/helpers';
import Stream from './Stream';
import { EncryptedStore, LocalStorageStore, PrivateTopicStore } from './store';
import { Conversations } from './conversations';
import { ContentTypeText, TextCodec } from './codecs/Text';
import { ContentTypeId, ContentTypeFallback, } from './MessageContent';
import { decompress, compress } from './Compression';
import { Compression } from './proto/messaging';
import * as proto from './proto/messaging';
import ContactBundle from './ContactBundle';
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
const NODES_LIST_URL = 'https://nodes.xmtp.com/';
// Default maximum allowed content size
const MaxContentSize = 100 * 1024 * 1024; // 100M
export var KeyStoreType;
(function (KeyStoreType) {
    KeyStoreType[KeyStoreType["networkTopicStoreV1"] = 0] = "networkTopicStoreV1";
    KeyStoreType[KeyStoreType["localStorage"] = 1] = "localStorage";
})(KeyStoreType || (KeyStoreType = {}));
// Parameters for the send functions
export { Compression };
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export function defaultOptions(opts) {
    const _defaultOptions = {
        keyStoreType: KeyStoreType.networkTopicStoreV1,
        env: 'dev',
        waitForPeersTimeoutMs: 10000,
        codecs: [new TextCodec()],
        maxContentSize: MaxContentSize,
    };
    if (opts === null || opts === void 0 ? void 0 : opts.codecs) {
        opts.codecs = _defaultOptions.codecs.concat(opts.codecs);
    }
    return Object.assign(Object.assign({}, _defaultOptions), opts);
}
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    constructor(waku, keys) {
        this.waku = waku;
        this.contacts = new Set();
        this.knownPublicKeyBundles = new Map();
        this.keys = keys;
        this.address = keys.identityKey.publicKey.walletSignatureAddress();
        this._conversations = new Conversations(this);
        this._codecs = new Map();
        this._maxContentSize = MaxContentSize;
        this._disconnectWatcher = this.createDisconnectWatcher();
    }
    /**
     * @type {Conversations}
     */
    get conversations() {
        return this._conversations;
    }
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = defaultOptions(opts);
            const waku = yield createWaku(options);
            const keyStore = createKeyStoreFromConfig(options, wallet, waku);
            const keys = yield loadOrCreateKeys(wallet, keyStore);
            const client = new Client(waku, keys);
            options.codecs.forEach((codec) => {
                client.registerCodec(codec);
            });
            client._maxContentSize = options.maxContentSize;
            yield client.publishUserContact();
            return client;
        });
    }
    // gracefully shut down the client
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            clearInterval(this._disconnectWatcher);
            return this.waku.stop();
        });
    }
    // publish the key bundle into the contact topic
    publishUserContact() {
        return __awaiter(this, void 0, void 0, function* () {
            const pub = this.keys.getPublicKeyBundle();
            yield publishUserContact(this.waku, pub, this.address);
        });
    }
    // retrieve a key bundle from given user's contact topic
    getUserContactFromNetwork(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            // have to avoid undefined to not trip TS's strictNullChecks on recipientKey
            let recipientKey = null;
            yield this.waku.store.queryHistory([buildUserContactTopic(peerAddress)], {
                pageSize: 5,
                pageDirection: PageDirection.BACKWARD,
                callback: (msgs) => {
                    for (const msg of msgs) {
                        if (!msg.payload)
                            continue;
                        const bundle = ContactBundle.fromBytes(msg.payload);
                        const keyBundle = bundle.keyBundle;
                        const address = keyBundle === null || keyBundle === void 0 ? void 0 : keyBundle.walletSignatureAddress();
                        if (address === peerAddress) {
                            recipientKey = keyBundle;
                            break;
                        }
                    }
                    return recipientKey !== null;
                },
            });
            return recipientKey === null ? undefined : recipientKey;
        });
    }
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingBundle = this.knownPublicKeyBundles.get(peerAddress);
            if (existingBundle) {
                return existingBundle;
            }
            const newBundle = yield this.getUserContactFromNetwork(peerAddress);
            if (newBundle) {
                this.knownPublicKeyBundles.set(peerAddress, newBundle);
            }
            return newBundle;
        });
    }
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyBundle = yield this.getUserContact(peerAddress);
            return keyBundle !== undefined;
        });
    }
    /**
     * Send a message to the wallet identified by @peerAddress
     */
    sendMessage(peerAddress, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            const recipient = yield this.getUserContact(peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${peerAddress} is not registered`);
            }
            if (!this.contacts.has(peerAddress)) {
                topics = [
                    buildUserIntroTopic(peerAddress),
                    buildDirectMessageTopic(this.address, peerAddress),
                ];
                if (peerAddress !== this.address) {
                    topics.push(buildUserIntroTopic(this.address));
                }
                this.contacts.add(peerAddress);
            }
            else {
                topics = [buildDirectMessageTopic(this.address, peerAddress)];
            }
            const timestamp = (options === null || options === void 0 ? void 0 : options.timestamp) || new Date();
            const msg = yield this.encodeMessage(recipient, timestamp, content, options);
            yield Promise.all(topics.map((topic) => __awaiter(this, void 0, void 0, function* () {
                const wakuMsg = yield WakuMessage.fromBytes(msg.toBytes(), topic, {
                    timestamp,
                });
                return this.sendWakuMessage(wakuMsg);
            })));
        });
    }
    sendWakuMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const ack = yield this.waku.lightPush.push(msg);
            if ((ack === null || ack === void 0 ? void 0 : ack.isSuccess) === false) {
                throw new Error(`Failed to send message with error: ${ack === null || ack === void 0 ? void 0 : ack.info}`);
            }
        });
    }
    registerCodec(codec) {
        const id = codec.contentType;
        const key = `${id.authorityId}/${id.typeId}`;
        this._codecs.set(key, codec);
    }
    codecFor(contentType) {
        const key = `${contentType.authorityId}/${contentType.typeId}`;
        const codec = this._codecs.get(key);
        if (!codec) {
            return undefined;
        }
        if (contentType.versionMajor > codec.contentType.versionMajor) {
            return undefined;
        }
        return codec;
    }
    encodeMessage(recipient, timestamp, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || ContentTypeText;
            const codec = this.codecFor(contentType);
            if (!codec) {
                throw new Error('unknown content type ' + contentType);
            }
            const encoded = codec.encode(content, this);
            if (options === null || options === void 0 ? void 0 : options.contentFallback) {
                encoded.fallback = options.contentFallback;
            }
            if (options === null || options === void 0 ? void 0 : options.compression) {
                encoded.compression = options.compression;
            }
            yield compress(encoded);
            const payload = proto.EncodedContent.encode(encoded).finish();
            return Message.encode(this.keys, recipient, payload, timestamp);
        });
    }
    decodeMessage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield Message.decode(this.keys, payload);
            if (message.error) {
                return message;
            }
            if (!message.decrypted) {
                throw new Error('decrypted bytes missing');
            }
            const encoded = proto.EncodedContent.decode(message.decrypted);
            yield decompress(encoded, this._maxContentSize);
            if (!encoded.type) {
                throw new Error('missing content type');
            }
            const contentType = new ContentTypeId(encoded.type);
            const codec = this.codecFor(contentType);
            if (codec) {
                message.content = codec.decode(encoded, this);
                message.contentType = contentType;
            }
            else {
                message.error = new Error('unknown content type ' + contentType);
                if (encoded.fallback) {
                    message.content = encoded.fallback;
                    message.contentType = ContentTypeFallback;
                }
            }
            return message;
        });
    }
    streamIntroductionMessages() {
        return Stream.create(this, buildUserIntroTopic(this.address), noTransformation);
    }
    streamConversationMessages(peerAddress) {
        const topic = buildDirectMessageTopic(peerAddress, this.address);
        return Stream.create(this, topic, noTransformation, filterForTopic(topic));
    }
    // list stored messages from this wallet's introduction topic
    listIntroductionMessages(opts) {
        return this.listMessages(buildUserIntroTopic(this.address), opts);
    }
    // list stored messages from conversation topic with the peer
    listConversationMessages(peerAddress, opts) {
        return this.listMessages(buildDirectMessageTopic(peerAddress, this.address), Object.assign(Object.assign({}, opts), { checkAddresses: true }));
    }
    // list stored messages from the specified topic
    listMessages(topic, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!opts) {
                opts = {};
            }
            if (!opts.startTime) {
                opts.startTime = new Date(0);
            }
            if (!opts.endTime) {
                opts.endTime = new Date(new Date().toUTCString());
            }
            if (!opts.pageSize) {
                opts.pageSize = 10;
            }
            let wakuMsgs = yield this.waku.store.queryHistory([topic], {
                pageSize: opts.pageSize,
                pageDirection: PageDirection.FORWARD,
                timeFilter: {
                    startTime: opts.startTime,
                    endTime: opts.endTime,
                },
            });
            wakuMsgs = wakuMsgs.filter((wakuMsg) => wakuMsg === null || wakuMsg === void 0 ? void 0 : wakuMsg.payload);
            let msgs = yield Promise.all(wakuMsgs.map((wakuMsg) => this.decodeMessage(wakuMsg.payload)));
            if (opts === null || opts === void 0 ? void 0 : opts.checkAddresses) {
                msgs = msgs.filter(filterForTopic(topic));
            }
            return msgs;
        });
    }
    createDisconnectWatcher() {
        return setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const connectionsToClose = [];
            for (const connections of this.waku.libp2p.connectionManager.connections.values()) {
                for (const connection of connections) {
                    if (!connection.streams.length) {
                        console.log(`Closing connection to ${connection.remoteAddr}`);
                        connectionsToClose.push(connection.close());
                    }
                }
            }
            yield Promise.allSettled(connectionsToClose);
        }), 10 * 1000);
    }
}
function createKeyStoreFromConfig(opts, wallet, waku) {
    switch (opts.keyStoreType) {
        case KeyStoreType.networkTopicStoreV1:
            return createNetworkPrivateKeyStore(wallet, waku);
        case KeyStoreType.localStorage:
            return createLocalPrivateKeyStore(wallet);
    }
}
// Create Encrypted store which uses the Network to store KeyBundles
function createNetworkPrivateKeyStore(wallet, waku) {
    return new EncryptedStore(wallet, new PrivateTopicStore(waku));
}
// Create Encrypted store which uses LocalStorage to store KeyBundles
function createLocalPrivateKeyStore(wallet) {
    return new EncryptedStore(wallet, new LocalStorageStore());
}
// attempt to load pre-existing key bundle from storage,
// otherwise create new key-bundle, store it and return it
function loadOrCreateKeys(wallet, store) {
    return __awaiter(this, void 0, void 0, function* () {
        let keys = yield store.loadPrivateKeyBundle();
        if (keys) {
            return keys;
        }
        keys = yield PrivateKeyBundle.generate(wallet);
        yield store.storePrivateKeyBundle(keys);
        return keys;
    });
}
// initialize connection to the network
export function createWaku({ bootstrapAddrs, env, waitForPeersTimeoutMs, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const bootstrap = (bootstrapAddrs === null || bootstrapAddrs === void 0 ? void 0 : bootstrapAddrs.length)
            ? {
                peers: bootstrapAddrs,
            }
            : {
                getPeers: () => getNodeList(env),
            };
        const waku = yield Waku.create({
            libp2p: {
                config: {
                    pubsub: {
                        enabled: true,
                        emitSelf: true,
                    },
                },
            },
            bootstrap,
        });
        // Wait for peer connection.
        try {
            yield promiseWithTimeout(waitForPeersTimeoutMs, () => waku.waitForRemotePeer(), 'timeout connecting to peers');
        }
        catch (err) {
            yield waku.stop();
            throw err;
        }
        // There's a race happening here even with waitForConnectedPeer; waiting
        // a few ms seems to be enough, but it would be great to fix this upstream.
        yield sleep(200);
        return waku;
    });
}
function getNodeList(env) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetch(NODES_LIST_URL);
        const nodesList = yield res.json();
        return Object.values(nodesList[env]);
    });
}
function noTransformation(msg) {
    return msg;
}
function filterForTopic(topic) {
    return (msg) => {
        const senderAddress = msg.senderAddress;
        const recipientAddress = msg.recipientAddress;
        return (senderAddress !== undefined &&
            recipientAddress !== undefined &&
            buildDirectMessageTopic(senderAddress, recipientAddress) === topic);
    };
}
//# sourceMappingURL=Client.js.map