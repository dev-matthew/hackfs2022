var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { sleep } from './utils';
const DISCONNECT_LOOP_INTERVAL = 1000;
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
export default class Stream {
    constructor(client, topic, messageTransformer, messageFilter) {
        this.messages = [];
        this.resolvers = [];
        this.topic = topic;
        this.client = client;
        this.callback = this.newMessageCallback(messageTransformer, messageFilter);
    }
    // returns new closure to handle incoming Waku messages
    newMessageCallback(transformer, filter) {
        return (wakuMsg) => __awaiter(this, void 0, void 0, function* () {
            if (!wakuMsg.payload) {
                return;
            }
            const msg = yield this.client.decodeMessage(wakuMsg.payload);
            // If there is a filter on the stream, and the filter returns false, ignore the message
            if (filter && !filter(msg)) {
                return;
            }
            // is there a Promise already pending?
            const resolver = this.resolvers.pop();
            if (resolver) {
                // yes, resolve it
                resolver({ value: transformer(msg) });
            }
            else {
                // no, push the message into the queue
                this.messages.unshift(transformer(msg));
            }
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.callback) {
                throw new Error('Missing callback for stream');
            }
            this.unsubscribeFn = yield this.client.waku.filter.subscribe(this.callback, [this.topic]);
            yield this.listenForDisconnect();
        });
    }
    listenForDisconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            const peer = yield this.client.waku.filter.randomPeer;
            // Save the callback function on the class so we can clean up later
            this._disconnectCallback = (connection) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (connection.remotePeer.toB58String() === ((_a = peer === null || peer === void 0 ? void 0 : peer.id) === null || _a === void 0 ? void 0 : _a.toB58String())) {
                    console.log(`Connection to peer ${connection.remoteAddr} lost`);
                    while (true) {
                        try {
                            if (!this.callback) {
                                return;
                            }
                            this.unsubscribeFn = yield this.client.waku.filter.subscribe(this.callback, [this.topic]);
                            console.log(`Connection to peer ${connection.remoteAddr} restored`);
                            return;
                        }
                        catch (e) {
                            console.warn(`Error reconnecting to ${connection.remoteAddr}`);
                            yield sleep(DISCONNECT_LOOP_INTERVAL);
                        }
                    }
                }
            });
            this.client.waku.libp2p.connectionManager.on('peer:disconnect', this._disconnectCallback);
        });
    }
    static create(client, topic, messageTransformer, messageFilter) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = new Stream(client, topic, messageTransformer, messageFilter);
            yield stream.start();
            return stream;
        });
    }
    // To make Stream proper Async Iterable
    [Symbol.asyncIterator]() {
        return this;
    }
    // return should be called if the interpreter detects that the stream won't be used anymore,
    // e.g. a for/of loop was exited via a break. It can also be called explicitly.
    // https://tc39.es/ecma262/#table-iterator-interface-optional-properties
    // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.
    return() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disconnectCallback) {
                this.client.waku.libp2p.connectionManager.off('peer:disconnect', this._disconnectCallback);
            }
            if (!this.callback) {
                return { value: undefined, done: true };
            }
            if (this.unsubscribeFn) {
                yield this.unsubscribeFn();
            }
            this.callback = undefined;
            this.resolvers.forEach((resolve) => resolve({ value: undefined, done: true }));
            return { value: undefined, done: true };
        });
    }
    // To make Stream proper Async Iterator
    // Note that next() will still provide whatever messages were already pending
    // even after the stream was closed via return().
    next() {
        // Is there a message already pending?
        const msg = this.messages.pop();
        if (msg) {
            // yes, return resolved promise
            return Promise.resolve({ value: msg });
        }
        if (!this.callback) {
            return Promise.resolve({ value: undefined, done: true });
        }
        // otherwise return empty Promise and queue its resolver
        return new Promise((resolve) => this.resolvers.unshift(resolve));
    }
}
//# sourceMappingURL=Stream.js.map