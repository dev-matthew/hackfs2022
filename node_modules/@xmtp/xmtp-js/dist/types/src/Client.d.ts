import { Waku } from 'js-waku';
import { PublicKeyBundle, PrivateKeyBundle } from './crypto';
import Message from './Message';
import Stream from './Stream';
import { Signer } from 'ethers';
import { Conversations } from './conversations';
import { ContentTypeId, ContentCodec } from './MessageContent';
import { Compression } from './proto/messaging';
declare type Nodes = {
    [k: string]: string;
};
declare type NodesList = {
    dev: Nodes;
    production: Nodes;
};
export declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    pageSize?: number;
    startTime?: Date;
    endTime?: Date;
};
export declare enum KeyStoreType {
    networkTopicStoreV1 = 0,
    localStorage = 1
}
export { Compression };
export declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: Compression;
    timestamp?: Date;
};
/**
 * Network startup options
 */
declare type NetworkOptions = {
    /** List of multiaddrs for boot nodes */
    bootstrapAddrs?: string[];
    env: keyof NodesList;
    /**
     * How long we should wait for the initial peer connection
     * to declare the startup as successful or failed
     */
    waitForPeersTimeoutMs: number;
};
declare type ContentOptions = {
    codecs: ContentCodec<any>[];
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /** Specify the keyStore which should be used for loading or saving privateKeyBundles */
    keyStoreType: KeyStoreType;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
export declare type ClientOptions = NetworkOptions & KeyStoreOptions & ContentOptions;
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export declare function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    waku: Waku;
    address: string;
    keys: PrivateKeyBundle;
    private contacts;
    private knownPublicKeyBundles;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    private _disconnectWatcher;
    constructor(waku: Waku, keys: PrivateKeyBundle);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer, opts?: Partial<ClientOptions>): Promise<Client>;
    close(): Promise<void>;
    private publishUserContact;
    getUserContactFromNetwork(peerAddress: string): Promise<PublicKeyBundle | undefined>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | undefined>;
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress: string): Promise<boolean>;
    /**
     * Send a message to the wallet identified by @peerAddress
     */
    sendMessage(peerAddress: string, content: any, options?: SendOptions): Promise<void>;
    private sendWakuMessage;
    registerCodec(codec: ContentCodec<any>): void;
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    encodeMessage(recipient: PublicKeyBundle, timestamp: Date, content: any, options?: SendOptions): Promise<Message>;
    decodeMessage(payload: Uint8Array): Promise<Message>;
    streamIntroductionMessages(): Promise<Stream<Message>>;
    streamConversationMessages(peerAddress: string): Promise<Stream<Message>>;
    listIntroductionMessages(opts?: ListMessagesOptions): Promise<Message[]>;
    listConversationMessages(peerAddress: string, opts?: ListMessagesOptions): Promise<Message[]>;
    private listMessages;
    private createDisconnectWatcher;
}
export declare function createWaku({ bootstrapAddrs, env, waitForPeersTimeoutMs, }: NetworkOptions): Promise<Waku>;
