var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import nodeCrypto from "crypto";
import * as secp from "@noble/secp256k1";
import * as sha3 from "js-sha3";
import { concat } from "uint8arrays/concat";
import * as symmetric from "./waku_message/symmetric";
import { PrivateKeySize } from "./waku_message/version_1";
const crypto = {
    node: nodeCrypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined,
};
export function getSubtle() {
    if (crypto.web) {
        return crypto.web.subtle;
    }
    else if (crypto.node) {
        return crypto.node.webcrypto.subtle;
    }
    else {
        throw new Error("The environment doesn't have Crypto Subtle API (if in the browser, be sure to use to be in a secure context, ie, https)");
    }
}
export const randomBytes = secp.utils.randomBytes;
export const sha256 = secp.utils.sha256;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
export function generatePrivateKey() {
    return randomBytes(PrivateKeySize);
}
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
export function generateSymmetricKey() {
    return randomBytes(symmetric.KeySize);
}
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
export const getPublicKey = secp.getPublicKey;
/**
 * ECDSA Sign a message with the given private key.
 *
 *  @param message The message to sign, usually a hash.
 *  @param privateKey The ECDSA private key to use to sign the message.
 *
 *  @returns The signature and the recovery id concatenated.
 */
export function sign(message, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const [signature, recoveryId] = yield secp.sign(message, privateKey, {
            recovered: true,
            der: false,
        });
        return concat([signature, [recoveryId]], signature.length + 1);
    });
}
export function keccak256(input) {
    return new Uint8Array(sha3.keccak256.arrayBuffer(input));
}
export function compressPublicKey(publicKey) {
    if (publicKey.length === 64) {
        publicKey = concat([[4], publicKey], 65);
    }
    const point = secp.Point.fromHex(publicKey);
    return point.toRawBytes(true);
}
/**
 * Verify an ECDSA signature.
 */
export function verifySignature(signature, message, publicKey) {
    try {
        const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
        return secp.verify(_signature, message, publicKey);
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=crypto.js.map