var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from "debug";
import { Multiaddr } from "multiaddr";
import { DnsNodeDiscovery } from "./dns";
import { getPredefinedBootstrapNodes, getPseudoRandomSubset } from "./index";
const dbg = debug("waku:discovery:bootstrap");
/**
 * Parse options and expose function to return bootstrap peer addresses.
 *
 * @throws if an invalid combination of options is passed, see [[BootstrapOptions]] for details.
 */
export class Bootstrap {
    constructor(opts) {
        var _a;
        const maxPeers = (_a = opts.maxPeers) !== null && _a !== void 0 ? _a : Bootstrap.DefaultMaxPeers;
        if (opts.default) {
            dbg("Use hosted list of peers.");
            this.getBootstrapPeers = () => {
                return Promise.resolve(getPredefinedBootstrapNodes(undefined, maxPeers));
            };
        }
        else if (opts.peers !== undefined && opts.peers.length > 0) {
            const allPeers = opts.peers.map((node) => {
                if (typeof node === "string") {
                    return new Multiaddr(node);
                }
                else {
                    return node;
                }
            });
            const peers = getPseudoRandomSubset(allPeers, maxPeers);
            dbg("Use provided list of peers (reduced to maxPeers)", allPeers.map((ma) => ma.toString()));
            this.getBootstrapPeers = () => Promise.resolve(peers);
        }
        else if (typeof opts.getPeers === "function") {
            dbg("Bootstrap: Use provided getPeers function.");
            const getPeers = opts.getPeers;
            this.getBootstrapPeers = () => __awaiter(this, void 0, void 0, function* () {
                const allPeers = yield getPeers();
                return getPseudoRandomSubset(allPeers, maxPeers).map((node) => new Multiaddr(node));
            });
        }
        else if (opts.enrUrl) {
            const wantedNodeCapabilityCount = opts.wantedNodeCapabilityCount;
            if (!wantedNodeCapabilityCount)
                throw "`wantedNodeCapabilityCount` must be defined when using `enrUrl`";
            const enrUrl = opts.enrUrl;
            dbg("Use provided EIP-1459 ENR Tree URL.");
            const dns = DnsNodeDiscovery.dnsOverHttp();
            this.getBootstrapPeers = () => __awaiter(this, void 0, void 0, function* () {
                const enrs = yield dns.getPeers([enrUrl], wantedNodeCapabilityCount);
                dbg(`Found ${enrs.length} peers`);
                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();
            });
        }
        else {
            dbg("No bootstrap method specified, no peer will be returned");
            this.getBootstrapPeers = undefined;
        }
    }
}
Bootstrap.DefaultMaxPeers = 1;
//# sourceMappingURL=bootstrap.js.map