var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { endpoints as defaultEndpoints, query, } from "dns-query";
import { bytesToUtf8 } from "../utils";
const { cloudflare, google, opendns } = defaultEndpoints;
export class DnsOverHttps {
    /**
     * Create new Dns-Over-Http DNS client.
     *
     * @param endpoints The endpoints for Dns-Over-Https queries.
     * See [dns-query](https://www.npmjs.com/package/dns-query) for details.
     * Defaults to cloudflare, google and opendns.
     *
     * @throws {code: string} If DNS query fails.
     */
    constructor(endpoints = [cloudflare, google, opendns]) {
        this.endpoints = endpoints;
    }
    /**
     * Resolves a TXT record
     *
     * @param domain The domain name
     *
     * @throws if the result is provided in byte form which cannot be decoded
     * to UTF-8
     */
    resolveTXT(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield query({
                questions: [{ type: "TXT", name: domain }],
            });
            const answers = response.answers;
            const data = answers.map((a) => a.data);
            const result = [];
            data.forEach((d) => {
                if (typeof d === "string") {
                    result.push(d);
                }
                else if (Array.isArray(d)) {
                    d.forEach((sd) => {
                        if (typeof sd === "string") {
                            result.push(sd);
                        }
                        else {
                            result.push(bytesToUtf8(sd));
                        }
                    });
                }
                else {
                    result.push(bytesToUtf8(d));
                }
            });
            return result;
        });
    }
}
//# sourceMappingURL=dns_over_https.js.map