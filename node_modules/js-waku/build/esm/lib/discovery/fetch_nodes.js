var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { debug } from "debug";
const dbg = debug("waku:discovery:fetch_nodes");
/**
 * Fetch nodes using passed [[getNode]] until all wanted capabilities are
 * fulfilled or the number of [[getNode]] call exceeds the sum of
 * [[wantedNodeCapabilityCount]] plus [[errorTolerance]].
 */
export default function fetchNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, errorTolerance, getNode) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        const wanted = {
            relay: (_a = wantedNodeCapabilityCount.relay) !== null && _a !== void 0 ? _a : 0,
            store: (_b = wantedNodeCapabilityCount.store) !== null && _b !== void 0 ? _b : 0,
            filter: (_c = wantedNodeCapabilityCount.filter) !== null && _c !== void 0 ? _c : 0,
            lightPush: (_d = wantedNodeCapabilityCount.lightPush) !== null && _d !== void 0 ? _d : 0,
        };
        const maxSearches = wanted.relay + wanted.store + wanted.filter + wanted.lightPush;
        const actual = {
            relay: 0,
            store: 0,
            filter: 0,
            lightPush: 0,
        };
        let totalSearches = 0;
        const peers = [];
        while (!isSatisfied(wanted, actual) &&
            totalSearches < maxSearches + errorTolerance) {
            const peer = yield getNode();
            if (peer && isNewPeer(peer, peers)) {
                // ENRs without a waku2 key are ignored.
                if (peer.waku2) {
                    if (helpsSatisfyCapabilities(peer.waku2, wanted, actual)) {
                        addCapabilities(peer.waku2, actual);
                        peers.push(peer);
                    }
                }
                dbg(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
            }
            totalSearches++;
        }
        return peers;
    });
}
function isSatisfied(wanted, actual) {
    return (actual.relay >= wanted.relay &&
        actual.store >= wanted.store &&
        actual.filter >= wanted.filter &&
        actual.lightPush >= wanted.lightPush);
}
function isNewPeer(peer, peers) {
    if (!peer.nodeId)
        return false;
    for (const existingPeer of peers) {
        if (peer.nodeId === existingPeer.nodeId) {
            return false;
        }
    }
    return true;
}
function addCapabilities(node, total) {
    if (node.relay)
        total.relay += 1;
    if (node.store)
        total.store += 1;
    if (node.filter)
        total.filter += 1;
    if (node.lightPush)
        total.lightPush += 1;
}
/**
 * Checks if the proposed ENR [[node]] helps satisfy the [[wanted]] capabilities,
 * considering the [[actual]] capabilities of nodes retrieved so far..
 *
 * @throws If the function is called when the wanted capabilities are already fulfilled.
 */
function helpsSatisfyCapabilities(node, wanted, actual) {
    if (isSatisfied(wanted, actual)) {
        throw "Internal Error: Waku2 wanted capabilities are already fulfilled";
    }
    const missing = missingCapabilities(wanted, actual);
    return ((missing.relay && node.relay) ||
        (missing.store && node.store) ||
        (missing.filter && node.filter) ||
        (missing.lightPush && node.lightPush));
}
/**
 * Return a [[Waku2]] Object for which capabilities are set to true if they are
 * [[wanted]] yet missing from [[actual]].
 */
function missingCapabilities(wanted, actual) {
    return {
        relay: actual.relay < wanted.relay,
        store: actual.store < wanted.store,
        filter: actual.filter < wanted.filter,
        lightPush: actual.lightPush < wanted.lightPush,
    };
}
//# sourceMappingURL=fetch_nodes.js.map