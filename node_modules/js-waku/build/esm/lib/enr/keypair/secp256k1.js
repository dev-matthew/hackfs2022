var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as secp from "@noble/secp256k1";
import { compressPublicKey, randomBytes } from "../../crypto";
import { KeypairType } from "./types";
export class Secp256k1Keypair {
    constructor(privateKey, publicKey) {
        let pub = publicKey;
        if (pub) {
            pub = compressPublicKey(pub);
        }
        if ((this._privateKey = privateKey) && !this.privateKeyVerify()) {
            throw new Error("Invalid private key");
        }
        if ((this._publicKey = pub) && !this.publicKeyVerify()) {
            throw new Error("Invalid public key");
        }
        this.type = KeypairType.secp256k1;
    }
    static generate() {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKey = randomBytes(32);
            const publicKey = secp.getPublicKey(privateKey);
            return new Secp256k1Keypair(privateKey, publicKey);
        });
    }
    privateKeyVerify(key = this._privateKey) {
        if (key) {
            return secp.utils.isValidPrivateKey(key);
        }
        return true;
    }
    publicKeyVerify(key = this._publicKey) {
        if (key) {
            try {
                secp.Point.fromHex(key);
                return true;
            }
            catch (_a) {
                return false;
            }
        }
        return true;
    }
    get privateKey() {
        if (!this._privateKey) {
            throw new Error();
        }
        return this._privateKey;
    }
    get publicKey() {
        if (!this._publicKey) {
            throw new Error();
        }
        return this._publicKey;
    }
    hasPrivateKey() {
        return !!this._privateKey;
    }
}
//# sourceMappingURL=secp256k1.js.map