var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { Noise } from "@chainsafe/libp2p-noise";
import debug from "debug";
import Libp2p from "libp2p";
import Libp2pBootstrap from "libp2p-bootstrap";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Mplex from "libp2p-mplex";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Websockets from "libp2p-websockets";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import filters from "libp2p-websockets/src/filters";
import PingService from "libp2p/src/ping";
import { multiaddr } from "multiaddr";
import PeerId from "peer-id";
import { Bootstrap } from "./discovery";
import { FilterCodec, WakuFilter } from "./waku_filter";
import { LightPushCodec, WakuLightPush } from "./waku_light_push";
import { WakuMessage } from "./waku_message";
import { RelayCodecs, WakuRelay } from "./waku_relay";
import { RelayPingContentTopic } from "./waku_relay/constants";
import { StoreCodecs, WakuStore } from "./waku_store";
const websocketsTransportKey = Websockets.prototype[Symbol.toStringTag];
export const DefaultPingKeepAliveValueSecs = 0;
export const DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
export const DefaultPubSubTopic = "/waku/2/default-waku/proto";
const dbg = debug("waku:waku");
export var Protocols;
(function (Protocols) {
    Protocols["Relay"] = "relay";
    Protocols["Store"] = "store";
    Protocols["LightPush"] = "lightpush";
    Protocols["Filter"] = "filter";
})(Protocols || (Protocols = {}));
export class Waku {
    constructor(options, libp2p, store, lightPush, filter) {
        var _a;
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.filter = filter;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on("peer:connect", (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on("peer:disconnect", (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        (_a = options === null || options === void 0 ? void 0 : options.decryptionKeys) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Create and start new waku node.
     */
    static create(options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Get an object in case options or libp2p are undefined
            const libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);
            // Default for Websocket filter is `all`:
            // Returns all TCP and DNS based addresses, both with ws or wss.
            libp2pOpts.config = Object.assign({
                transport: {
                    [websocketsTransportKey]: {
                        filter: filters.all,
                    },
                },
            }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);
            // Pass pubsub topic to relay
            if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
                libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
            }
            libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);
            // Default transport for libp2p is Websockets
            libp2pOpts.modules = Object.assign({
                transport: [Websockets],
            }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);
            // streamMuxer, connection encryption and pubsub are overridden
            // as those are the only ones currently supported by Waku nodes.
            libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                streamMuxer: [Mplex],
                connEncryption: [new Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],
                pubsub: WakuRelay,
            });
            if (options === null || options === void 0 ? void 0 : options.bootstrap) {
                const bootstrap = new Bootstrap(options === null || options === void 0 ? void 0 : options.bootstrap);
                if (bootstrap.getBootstrapPeers !== undefined) {
                    try {
                        const list = yield bootstrap.getBootstrapPeers();
                        // Note: this overrides any other peer discover
                        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                            peerDiscovery: [Libp2pBootstrap],
                        });
                        libp2pOpts.config.peerDiscovery = {
                            [Libp2pBootstrap.tag]: {
                                list,
                                enabled: true,
                            },
                        };
                    }
                    catch (e) {
                        dbg("Failed to retrieve bootstrap nodes", e);
                    }
                }
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore: modules property is correctly set thanks to voodoo
            const libp2p = yield Libp2p.create(libp2pOpts);
            const wakuStore = new WakuStore(libp2p, {
                pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,
            });
            const wakuLightPush = new WakuLightPush(libp2p);
            const wakuFilter = new WakuFilter(libp2p);
            yield libp2p.start();
            return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush, wakuFilter);
        });
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     * @param protocols Waku protocols we expect from the peer; Default to Relay
     */
    dial(peer, protocols) {
        return __awaiter(this, void 0, void 0, function* () {
            const _protocols = protocols !== null && protocols !== void 0 ? protocols : [Protocols.Relay];
            const codecs = [];
            if (_protocols.includes(Protocols.Relay)) {
                RelayCodecs.forEach((codec) => codecs.push(codec));
            }
            if (_protocols.includes(Protocols.Store)) {
                for (const codec of Object.values(StoreCodecs)) {
                    codecs.push(codec);
                }
            }
            if (_protocols.includes(Protocols.LightPush)) {
                codecs.push(LightPushCodec);
            }
            if (_protocols.includes(Protocols.Filter)) {
                codecs.push(FilterCodec);
            }
            return this.libp2p.dialProtocol(peer, codecs);
        });
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === "string") {
            peer = PeerId.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === "string") {
                return multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.libp2p.stop();
        });
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.relay.addDecryptionKey(key, options);
        this.store.addDecryptionKey(key, options);
        this.filter.addDecryptionKey(key, options);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
        this.filter.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     *
     * @throws if libp2p is not listening on localhost.
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === "") {
            throw "Not listening on localhost";
        }
        return localMultiaddr + "/p2p/" + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait for a remote peer to be ready given the passed protocols.
     * Useful when using the [[CreateOptions.bootstrap]] with [[Waku.create]].
     *
     * @param protocols The protocols that need to be enabled by remote peers.
     * @param timeoutMs A timeout value in milliseconds..
     *
     * @returns A promise that **resolves** if all desired protocols are fulfilled by
     * remote nodes, **rejects** if the timeoutMs is reached.
     *
     * @default Remote peer must have Waku Relay enabled and no time out is applied.
     */
    waitForRemotePeer(protocols, timeoutMs) {
        return __awaiter(this, void 0, void 0, function* () {
            protocols = protocols !== null && protocols !== void 0 ? protocols : [Protocols.Relay];
            const promises = [];
            if (protocols.includes(Protocols.Relay)) {
                const peers = this.relay.getPeers();
                if (peers.size == 0) {
                    // No peer yet available, wait for a subscription
                    const promise = new Promise((resolve) => {
                        this.libp2p.pubsub.once("pubsub:subscription-change", () => {
                            // Remote peer subscribed to topic, now wait for a heartbeat
                            // so that the mesh is updated and the remote peer added to it
                            this.libp2p.pubsub.once("gossipsub:heartbeat", resolve);
                        });
                    });
                    promises.push(promise);
                }
            }
            if (protocols.includes(Protocols.Store)) {
                const storePromise = (() => __awaiter(this, void 0, void 0, function* () {
                    var e_1, _a;
                    try {
                        for (var _b = __asyncValues(this.store.peers), _c; _c = yield _b.next(), !_c.done;) {
                            const peer = _c.value;
                            dbg("Store peer found", peer.id.toB58String());
                            break;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }))();
                promises.push(storePromise);
            }
            if (protocols.includes(Protocols.LightPush)) {
                const lightPushPromise = (() => __awaiter(this, void 0, void 0, function* () {
                    var e_2, _d;
                    try {
                        for (var _e = __asyncValues(this.lightPush.peers), _f; _f = yield _e.next(), !_f.done;) {
                            const peer = _f.value;
                            dbg("Light Push peer found", peer.id.toB58String());
                            break;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_d = _e.return)) yield _d.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }))();
                promises.push(lightPushPromise);
            }
            if (protocols.includes(Protocols.Filter)) {
                const filterPromise = (() => __awaiter(this, void 0, void 0, function* () {
                    var e_3, _g;
                    try {
                        for (var _h = __asyncValues(this.filter.peers), _j; _j = yield _h.next(), !_j.done;) {
                            const peer = _j.value;
                            dbg("Filter peer found", peer.id.toB58String());
                            break;
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_g = _h.return)) yield _g.call(_h);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }))();
                promises.push(filterPromise);
            }
            if (timeoutMs) {
                yield rejectOnTimeout(Promise.all(promises), timeoutMs, "Timed out waiting for a remote peer.");
            }
            else {
                yield Promise.all(promises);
            }
        });
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            const pingService = new PingService(this.libp2p);
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                pingService.ping(peerId).catch((e) => {
                    dbg(`Ping failed (${peerIdStr})`, e);
                });
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                WakuMessage.fromBytes(new Uint8Array(), RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
const awaitTimeout = (ms, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms));
const rejectOnTimeout = (promise, timeoutMs, rejectReason) => Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
//# sourceMappingURL=waku.js.map