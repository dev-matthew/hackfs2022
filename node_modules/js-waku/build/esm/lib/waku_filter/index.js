var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import debug from "debug";
import lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { getPeersForProtocol, selectRandomPeer } from "../select_peer";
import { hexToBytes } from "../utils";
import { DefaultPubSubTopic } from "../waku";
import { WakuMessage } from "../waku_message";
import { FilterRPC } from "./filter_rpc";
export const FilterCodec = "/vac/waku/filter/2.0.0-beta1";
const log = debug("waku:filter");
/**
 * Implements client side of the [Waku v2 Filter protocol](https://rfc.vac.dev/spec/12/).
 *
 * Note this currently only works in NodeJS when the Waku node is listening on a port, see:
 * - https://github.com/status-im/go-waku/issues/245
 * - https://github.com/status-im/nwaku/issues/948
 */
export class WakuFilter {
    constructor(libp2p) {
        this.libp2p = libp2p;
        this.subscriptions = new Map();
        this.decryptionKeys = new Map();
        this.libp2p.handle(FilterCodec, this.onRequest.bind(this));
    }
    /**
     * @param contentTopics Array of ContentTopics to subscribe to. If empty, no messages will be returned from the filter.
     * @param callback A function that will be called on each message returned by the filter.
     * @param opts The FilterSubscriptionOpts used to narrow which messages are returned, and which peer to connect to.
     * @returns Unsubscribe function that can be used to end the subscription.
     */
    subscribe(callback, contentTopics, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const topic = (opts === null || opts === void 0 ? void 0 : opts.pubsubTopic) || DefaultPubSubTopic;
            const contentFilters = contentTopics.map((contentTopic) => ({
                contentTopic,
            }));
            const request = FilterRPC.createRequest(topic, contentFilters, undefined, true);
            const peer = yield this.getPeer(opts === null || opts === void 0 ? void 0 : opts.peerId);
            const stream = yield this.newStream(peer);
            try {
                yield pipe([request.encode()], lp.encode(), stream);
            }
            catch (e) {
                log("Error subscribing to peer ", peer.id.toB58String(), "for content topics", contentTopics, ": ", e);
                throw e;
            }
            this.addCallback(request.requestId, callback);
            return () => __awaiter(this, void 0, void 0, function* () {
                yield this.unsubscribe(topic, contentFilters, request.requestId, peer);
                this.removeCallback(request.requestId);
            });
        });
    }
    onRequest({ stream }) {
        return __awaiter(this, void 0, void 0, function* () {
            log("Receiving message push");
            try {
                yield pipe(stream.source, lp.decode(), (source) => { var source_1, source_1_1; return __awaiter(this, void 0, void 0, function* () {
                    var e_1, _a;
                    var _b, _c;
                    try {
                        for (source_1 = __asyncValues(source); source_1_1 = yield source_1.next(), !source_1_1.done;) {
                            const bytes = source_1_1.value;
                            const res = FilterRPC.decode(bytes.slice());
                            if ((_c = (_b = res.push) === null || _b === void 0 ? void 0 : _b.messages) === null || _c === void 0 ? void 0 : _c.length) {
                                yield this.pushMessages(res.requestId, res.push.messages);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield _a.call(source_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }); });
            }
            catch (e) {
                log("Error decoding message", e);
            }
        });
    }
    pushMessages(requestId, messages) {
        return __awaiter(this, void 0, void 0, function* () {
            const callback = this.subscriptions.get(requestId);
            if (!callback) {
                log(`No callback registered for request ID ${requestId}`);
                return;
            }
            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
                return {
                    key,
                    method,
                    contentTopics,
                };
            });
            for (const message of messages) {
                const decoded = yield WakuMessage.decodeProto(message, decryptionKeys);
                if (!decoded) {
                    log("Not able to decode message");
                    continue;
                }
                callback(decoded);
            }
        });
    }
    addCallback(requestId, callback) {
        this.subscriptions.set(requestId, callback);
    }
    removeCallback(requestId) {
        this.subscriptions.delete(requestId);
    }
    unsubscribe(topic, contentFilters, requestId, peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const unsubscribeRequest = FilterRPC.createRequest(topic, contentFilters, requestId, false);
            const stream = yield this.newStream(peer);
            try {
                yield pipe([unsubscribeRequest.encode()], lp.encode(), stream.sink);
            }
            catch (e) {
                log("Error unsubscribing", e);
                throw e;
            }
        });
    }
    newStream(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = this.libp2p.connectionManager.get(peer.id);
            if (!connection) {
                throw new Error("Failed to get a connection to the peer");
            }
            const { stream } = yield connection.newStream(FilterCodec);
            return stream;
        });
    }
    getPeer(peerId) {
        return __awaiter(this, void 0, void 0, function* () {
            let peer;
            if (peerId) {
                peer = yield this.libp2p.peerStore.get(peerId);
                if (!peer) {
                    throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toB58String()}`);
                }
            }
            else {
                peer = yield this.randomPeer;
                if (!peer) {
                    throw new Error("Failed to find known peer that registers waku filter protocol");
                }
            }
            return peer;
        });
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[subscribe]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set(hexToBytes(key), options !== null && options !== void 0 ? options : {});
    }
    /**
     * Delete a decryption key so that it cannot be used in future [[subscribe]] calls
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(hexToBytes(key));
    }
    get peers() {
        return getPeersForProtocol(this.libp2p, [FilterCodec]);
    }
    get randomPeer() {
        return selectRandomPeer(this.peers);
    }
}
//# sourceMappingURL=index.js.map