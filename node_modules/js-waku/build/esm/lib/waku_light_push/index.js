var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import concat from "it-concat";
import lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { PushResponse } from "../../proto/waku/v2/light_push";
import { getPeersForProtocol, selectRandomPeer } from "../select_peer";
import { DefaultPubSubTopic } from "../waku";
import { PushRPC } from "./push_rpc";
export const LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";
export { PushResponse };
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
export class WakuLightPush {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = DefaultPubSubTopic;
        }
    }
    push(message, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let peer;
            if (opts === null || opts === void 0 ? void 0 : opts.peerId) {
                peer = yield this.libp2p.peerStore.get(opts.peerId);
                if (!peer)
                    throw "Peer is unknown";
            }
            else {
                peer = yield this.randomPeer;
            }
            if (!peer)
                throw "No peer available";
            if (!peer.protocols.includes(LightPushCodec))
                throw "Peer does not register waku light push protocol";
            const connection = this.libp2p.connectionManager.get(peer.id);
            if (!connection)
                throw "Failed to get a connection to the peer";
            const { stream } = yield connection.newStream(LightPushCodec);
            try {
                const pubSubTopic = (opts === null || opts === void 0 ? void 0 : opts.pubSubTopic)
                    ? opts.pubSubTopic
                    : this.pubSubTopic;
                const query = PushRPC.createRequest(message, pubSubTopic);
                const res = yield pipe([query.encode()], lp.encode(), stream, lp.decode(), concat);
                try {
                    const response = PushRPC.decode(res.slice()).response;
                    if (!response) {
                        console.log("No response in PushRPC");
                        return null;
                    }
                    return response;
                }
                catch (err) {
                    console.log("Failed to decode push reply", err);
                }
            }
            catch (err) {
                console.log("Failed to send waku light push request", err);
            }
            return null;
        });
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * light push protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return getPeersForProtocol(this.libp2p, [LightPushCodec]);
    }
    /**
     * Returns a random peer that supports light push protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return selectRandomPeer(this.peers);
    }
}
//# sourceMappingURL=index.js.map