var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from "debug";
import Long from "long";
import { Reader } from "protobufjs/minimal";
import * as proto from "../../proto/waku/v2/message";
import { bytesToUtf8, utf8ToBytes } from "../utils";
import * as version_1 from "./version_1";
const DefaultVersion = 0;
const dbg = debug("waku:message");
export var DecryptionMethod;
(function (DecryptionMethod) {
    DecryptionMethod["Asymmetric"] = "asymmetric";
    DecryptionMethod["Symmetric"] = "symmetric";
})(DecryptionMethod || (DecryptionMethod = {}));
export class WakuMessage {
    constructor(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with an utf-8 string as payload.
     */
    static fromUtf8String(utf8, contentTopic, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = utf8ToBytes(utf8);
            return WakuMessage.fromBytes(payload, contentTopic, opts);
        });
    }
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static fromBytes(payload, contentTopic, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});
            let _payload = payload;
            let version = DefaultVersion;
            let sig;
            if (encPublicKey && symKey) {
                throw "Pass either `encPublicKey` or `symKey`, not both.";
            }
            if (encPublicKey) {
                const enc = yield version_1.clearEncode(_payload, sigPrivKey);
                _payload = yield version_1.encryptAsymmetric(enc.payload, encPublicKey);
                sig = enc.sig;
                version = 1;
            }
            else if (symKey) {
                const enc = yield version_1.clearEncode(_payload, sigPrivKey);
                _payload = yield version_1.encryptSymmetric(enc.payload, symKey);
                sig = enc.sig;
                version = 1;
            }
            return new WakuMessage({
                payload: _payload,
                timestampDeprecated: timestamp.valueOf() / 1000,
                // milliseconds 10^-3 to nanoseconds 10^-9
                timestamp: Long.fromNumber(timestamp.valueOf()).mul(1000000),
                version,
                contentTopic,
            }, sig === null || sig === void 0 ? void 0 : sig.publicKey, sig === null || sig === void 0 ? void 0 : sig.signature);
        });
    }
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static decode(bytes, decryptionKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const protoBuf = proto.WakuMessage.decode(Reader.create(bytes));
            return WakuMessage.decodeProto(protoBuf, decryptionKeys);
        });
    }
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static decodeProto(protoBuf, decryptionKeys) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (protoBuf.payload === undefined) {
                dbg("Payload is undefined");
                return;
            }
            const payload = protoBuf.payload;
            let signaturePublicKey;
            let signature;
            if (protoBuf.version === 1 && protoBuf.payload) {
                if (decryptionKeys === undefined) {
                    dbg("Payload is encrypted but no private keys have been provided.");
                    return;
                }
                // Returns a bunch of `undefined` and hopefully one decrypted result
                const allResults = yield Promise.all(decryptionKeys.map(({ key, method, contentTopics }) => __awaiter(this, void 0, void 0, function* () {
                    if (!contentTopics ||
                        (protoBuf.contentTopic &&
                            contentTopics.includes(protoBuf.contentTopic))) {
                        switch (method) {
                            case DecryptionMethod.Asymmetric:
                                try {
                                    return yield version_1.decryptAsymmetric(payload, key);
                                }
                                catch (e) {
                                    dbg("Failed to decrypt message using asymmetric encryption despite decryption method being specified", e);
                                    return;
                                }
                            case DecryptionMethod.Symmetric:
                                try {
                                    return yield version_1.decryptSymmetric(payload, key);
                                }
                                catch (e) {
                                    dbg("Failed to decrypt message using asymmetric encryption despite decryption method being specified", e);
                                    return;
                                }
                            default:
                                try {
                                    return yield version_1.decryptSymmetric(payload, key);
                                }
                                catch (e) {
                                    dbg("Failed to decrypt message using symmetric encryption", e);
                                    try {
                                        return yield version_1.decryptAsymmetric(payload, key);
                                    }
                                    catch (e) {
                                        dbg("Failed to decrypt message using asymmetric encryption", e);
                                        return;
                                    }
                                }
                        }
                    }
                    else {
                        // No key available for this content topic
                        return;
                    }
                })));
                const isDefined = (dec) => {
                    return !!dec;
                };
                const decodedResults = allResults.filter(isDefined);
                if (decodedResults.length === 0) {
                    dbg("Failed to decrypt payload.");
                    return;
                }
                const dec = decodedResults[0];
                const res = yield version_1.clearDecode(dec);
                if (!res) {
                    dbg("Failed to decode payload.");
                    return;
                }
                Object.assign(protoBuf, { payload: res.payload });
                signaturePublicKey = (_a = res.sig) === null || _a === void 0 ? void 0 : _a.publicKey;
                signature = (_b = res.sig) === null || _b === void 0 ? void 0 : _b.signature;
            }
            return new WakuMessage(protoBuf, signaturePublicKey, signature);
        });
    }
    encode() {
        return proto.WakuMessage.encode(this.proto).finish();
    }
    get payloadAsUtf8() {
        if (!this.payload) {
            return "";
        }
        try {
            return bytesToUtf8(this.payload);
        }
        catch (e) {
            dbg("Could not decode byte as UTF-8", e);
            return "";
        }
    }
    get payload() {
        if (this.proto.payload) {
            return new Uint8Array(this.proto.payload);
        }
        return;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get version() {
        return this.proto.version;
    }
    get timestamp() {
        // In the case we receive a value that is bigger than JS's max number,
        // we catch the error and return undefined.
        try {
            if (this.proto.timestamp) {
                // nanoseconds 10^-9 to milliseconds 10^-3
                const timestamp = this.proto.timestamp.div(1000000).toNumber();
                return new Date(timestamp);
            }
            if (this.proto.timestampDeprecated) {
                return new Date(this.proto.timestampDeprecated * 1000);
            }
        }
        catch (e) {
            return;
        }
        return;
    }
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey() {
        return this._signaturePublicKey;
    }
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature() {
        return this._signature;
    }
}
//# sourceMappingURL=index.js.map