var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as secp from "@noble/secp256k1";
import { concat } from "uint8arrays/concat";
import { keccak256, randomBytes, sign } from "../crypto";
import { hexToBytes } from "../utils";
import * as ecies from "./ecies";
import * as symmetric from "./symmetric";
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
export const PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
export function clearEncode(messagePayload, sigPrivKey) {
    return __awaiter(this, void 0, void 0, function* () {
        let envelope = new Uint8Array([0]); // No flags
        envelope = addPayloadSizeField(envelope, messagePayload);
        envelope = concat([envelope, messagePayload]);
        // Calculate padding:
        let rawSize = FlagsLength +
            computeSizeOfPayloadSizeField(messagePayload) +
            messagePayload.length;
        if (sigPrivKey) {
            rawSize += SignatureLength;
        }
        const remainder = rawSize % PaddingTarget;
        const paddingSize = PaddingTarget - remainder;
        const pad = randomBytes(paddingSize);
        if (!validateDataIntegrity(pad, paddingSize)) {
            throw new Error("failed to generate random padding of size " + paddingSize);
        }
        envelope = concat([envelope, pad]);
        let sig;
        if (sigPrivKey) {
            envelope[0] |= IsSignedMask;
            const hash = keccak256(envelope);
            const bytesSignature = yield sign(hash, sigPrivKey);
            envelope = concat([envelope, bytesSignature]);
            sig = {
                signature: bytesSignature,
                publicKey: secp.getPublicKey(sigPrivKey, false),
            };
        }
        return { payload: envelope, sig };
    });
}
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
export function clearDecode(message) {
    const sizeOfPayloadSizeField = getSizeOfPayloadSizeField(message);
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = getPayloadSize(message, sizeOfPayloadSizeField);
    const payloadStart = 1 + sizeOfPayloadSizeField;
    const payload = message.slice(payloadStart, payloadStart + payloadSize);
    const isSigned = isMessageSigned(message);
    let sig;
    if (isSigned) {
        const signature = getSignature(message);
        const hash = getHash(message, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
function getSizeOfPayloadSizeField(message) {
    const messageDataView = new DataView(message.buffer);
    return messageDataView.getUint8(0) & FlagMask;
}
function getPayloadSize(message, sizeOfPayloadSizeField) {
    let payloadSizeBytes = message.slice(1, 1 + sizeOfPayloadSizeField);
    // int 32 == 4 bytes
    if (sizeOfPayloadSizeField < 4) {
        // If less than 4 bytes pad right (Little Endian).
        payloadSizeBytes = concat([payloadSizeBytes, new Uint8Array(4 - sizeOfPayloadSizeField)], 4);
    }
    const payloadSizeDataView = new DataView(payloadSizeBytes.buffer);
    return payloadSizeDataView.getInt32(0, true);
}
function isMessageSigned(message) {
    const messageDataView = new DataView(message.buffer);
    return (messageDataView.getUint8(0) & IsSignedMask) == IsSignedMask;
}
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result  can be set to `WakuMessage.payload`.
 *
 * @internal
 */
export function encryptAsymmetric(data, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return ecies.encrypt(hexToBytes(publicKey), data);
    });
}
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The returned data is expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
export function decryptAsymmetric(payload, privKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return ecies.decrypt(privKey, payload);
    });
}
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
export function encryptSymmetric(data, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const iv = symmetric.generateIv();
        // Returns `cipher | tag`
        const cipher = yield symmetric.encrypt(iv, hexToBytes(key), data);
        return concat([cipher, iv]);
    });
}
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
export function decryptSymmetric(payload, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const ivStart = payload.length - symmetric.IvSize;
        const cipher = payload.slice(0, ivStart);
        const iv = payload.slice(ivStart);
        return symmetric.decrypt(iv, hexToBytes(key), cipher);
    });
}
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = computeSizeOfPayloadSizeField(payload);
    let field = new Uint8Array(4);
    const fieldDataView = new DataView(field.buffer);
    fieldDataView.setUint32(0, payload.length, true);
    field = field.slice(0, fieldSize);
    msg = concat([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function computeSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return expectedSize <= 3 || value.findIndex((i) => i !== 0) !== -1;
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return keccak256(message.slice(0, message.length - SignatureLength));
    }
    return keccak256(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recoveryDataView = new DataView(signature.slice(64).buffer);
    const recovery = recoveryDataView.getUint8(0);
    const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
    return secp.recoverPublicKey(messageHash, _signature, recovery, 
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: compressed: false
    false);
}
//# sourceMappingURL=version_1.js.map