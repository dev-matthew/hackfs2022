var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from "debug";
import concat from "it-concat";
import lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { getPeersForProtocol, selectRandomPeer } from "../select_peer";
import { hexToBytes } from "../utils";
import { DefaultPubSubTopic } from "../waku";
import { WakuMessage } from "../waku_message";
import { HistoryRPC, PageDirection } from "./history_rpc";
const dbg = debug("waku:store");
export var StoreCodecs;
(function (StoreCodecs) {
    StoreCodecs["V2Beta3"] = "/vac/waku/store/2.0.0-beta3";
    StoreCodecs["V2Beta4"] = "/vac/waku/store/2.0.0-beta4";
})(StoreCodecs || (StoreCodecs = {}));
export const DefaultPageSize = 10;
export { PageDirection };
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 *
 * The Waku Store protocol can be used to retrieved historical messages.
 */
export class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = DefaultPubSubTopic;
        }
        this.decryptionKeys = new Map();
    }
    /**
     * Do a query to a Waku Store to retrieve historical/missed messages.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     * @param options Optional parameters.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    queryHistory(contentTopics, options) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            let startTime, endTime;
            if (options === null || options === void 0 ? void 0 : options.timeFilter) {
                startTime = options.timeFilter.startTime;
                endTime = options.timeFilter.endTime;
            }
            const opts = Object.assign({
                pubSubTopic: this.pubSubTopic,
                pageDirection: PageDirection.BACKWARD,
                pageSize: DefaultPageSize,
            }, options, { contentTopics, startTime, endTime });
            dbg("Querying history with the following options", Object.assign({ peerId: (_a = options === null || options === void 0 ? void 0 : options.peerId) === null || _a === void 0 ? void 0 : _a.toB58String() }, options));
            let peer;
            if (opts.peerId) {
                peer = yield this.libp2p.peerStore.get(opts.peerId);
                if (!peer)
                    throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
            }
            else {
                peer = yield this.randomPeer;
                if (!peer)
                    throw "Failed to find known peer that registers waku store protocol";
            }
            let storeCodec = "";
            for (const codec of Object.values(StoreCodecs)) {
                if (peer.protocols.includes(codec)) {
                    storeCodec = codec;
                    // Do not break as we want to keep the last value
                }
            }
            dbg(`Use store codec ${storeCodec}`);
            if (!storeCodec)
                throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
            Object.assign(opts, { storeCodec });
            const connection = this.libp2p.connectionManager.get(peer.id);
            if (!connection)
                throw "Failed to get a connection to the peer";
            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
                return {
                    key,
                    method,
                    contentTopics,
                };
            });
            // Add the decryption keys passed to this function against the
            // content topics also passed to this function.
            if (opts.decryptionKeys) {
                opts.decryptionKeys.forEach((key) => {
                    decryptionKeys.push({
                        key: hexToBytes(key),
                        contentTopics: contentTopics.length ? contentTopics : undefined,
                        method: undefined,
                    });
                });
            }
            const messages = [];
            let cursor = undefined;
            while (true) {
                const { stream } = yield connection.newStream(storeCodec);
                const queryOpts = Object.assign(opts, { cursor });
                const historyRpcQuery = HistoryRPC.createQuery(queryOpts);
                dbg("Querying store peer", connection.remoteAddr.toString());
                const res = yield pipe([historyRpcQuery.encode()], lp.encode(), stream, lp.decode(), concat);
                const reply = historyRpcQuery.decode(res.slice());
                const response = reply.response;
                if (!response) {
                    throw "History response misses response field";
                }
                if (response.error) {
                    throw "History response contains an Error" + response.error;
                }
                if (!response.messages || !response.messages.length) {
                    // No messages left (or stored)
                    console.log("No messages present in HistoryRPC response");
                    return messages;
                }
                dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
                const pageMessages = [];
                yield Promise.all(response.messages.map((protoMsg) => __awaiter(this, void 0, void 0, function* () {
                    const msg = yield WakuMessage.decodeProto(protoMsg, decryptionKeys);
                    if (msg) {
                        messages.push(msg);
                        pageMessages.push(msg);
                    }
                })));
                let abort = false;
                if (opts.callback) {
                    abort = Boolean(opts.callback(pageMessages));
                }
                const responsePageSize = (_b = response.pagingInfo) === null || _b === void 0 ? void 0 : _b.pageSize;
                const queryPageSize = (_d = (_c = historyRpcQuery.query) === null || _c === void 0 ? void 0 : _c.pagingInfo) === null || _d === void 0 ? void 0 : _d.pageSize;
                if (abort ||
                    // Response page size smaller than query, meaning this is the last page
                    (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                    return messages;
                }
                cursor = (_e = response.pagingInfo) === null || _e === void 0 ? void 0 : _e.cursor;
                if (cursor === undefined) {
                    // If the server does not return cursor then there is an issue,
                    // Need to abort or we end up in an infinite loop
                    console.log("No cursor returned by peer.");
                    return messages;
                }
            }
        });
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set(hexToBytes(key), options !== null && options !== void 0 ? options : {});
    }
    /**cursorV2Beta4
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(hexToBytes(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        const codecs = [];
        for (const codec of Object.values(StoreCodecs)) {
            codecs.push(codec);
        }
        return getPeersForProtocol(this.libp2p, codecs);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return selectRandomPeer(this.peers);
    }
}
//# sourceMappingURL=index.js.map