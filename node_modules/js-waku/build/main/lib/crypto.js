"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignature = exports.compressPublicKey = exports.keccak256 = exports.sign = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.sha256 = exports.randomBytes = exports.getSubtle = void 0;
const crypto_1 = __importDefault(require("crypto"));
const secp = __importStar(require("@noble/secp256k1"));
const sha3 = __importStar(require("js-sha3"));
const concat_1 = require("uint8arrays/concat");
const symmetric = __importStar(require("./waku_message/symmetric"));
const version_1_1 = require("./waku_message/version_1");
const crypto = {
    node: crypto_1.default,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined,
};
function getSubtle() {
    if (crypto.web) {
        return crypto.web.subtle;
    }
    else if (crypto.node) {
        return crypto.node.webcrypto.subtle;
    }
    else {
        throw new Error("The environment doesn't have Crypto Subtle API (if in the browser, be sure to use to be in a secure context, ie, https)");
    }
}
exports.getSubtle = getSubtle;
exports.randomBytes = secp.utils.randomBytes;
exports.sha256 = secp.utils.sha256;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
function generatePrivateKey() {
    return (0, exports.randomBytes)(version_1_1.PrivateKeySize);
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
function generateSymmetricKey() {
    return (0, exports.randomBytes)(symmetric.KeySize);
}
exports.generateSymmetricKey = generateSymmetricKey;
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
exports.getPublicKey = secp.getPublicKey;
/**
 * ECDSA Sign a message with the given private key.
 *
 *  @param message The message to sign, usually a hash.
 *  @param privateKey The ECDSA private key to use to sign the message.
 *
 *  @returns The signature and the recovery id concatenated.
 */
async function sign(message, privateKey) {
    const [signature, recoveryId] = await secp.sign(message, privateKey, {
        recovered: true,
        der: false,
    });
    return (0, concat_1.concat)([signature, [recoveryId]], signature.length + 1);
}
exports.sign = sign;
function keccak256(input) {
    return new Uint8Array(sha3.keccak256.arrayBuffer(input));
}
exports.keccak256 = keccak256;
function compressPublicKey(publicKey) {
    if (publicKey.length === 64) {
        publicKey = (0, concat_1.concat)([[4], publicKey], 65);
    }
    const point = secp.Point.fromHex(publicKey);
    return point.toRawBytes(true);
}
exports.compressPublicKey = compressPublicKey;
/**
 * Verify an ECDSA signature.
 */
function verifySignature(signature, message, publicKey) {
    try {
        const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
        return secp.verify(_signature, message, publicKey);
    }
    catch {
        return false;
    }
}
exports.verifySignature = verifySignature;
//# sourceMappingURL=crypto.js.map