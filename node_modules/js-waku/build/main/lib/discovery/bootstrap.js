"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrap = void 0;
const debug_1 = __importDefault(require("debug"));
const multiaddr_1 = require("multiaddr");
const dns_1 = require("./dns");
const index_1 = require("./index");
const dbg = (0, debug_1.default)("waku:discovery:bootstrap");
/**
 * Parse options and expose function to return bootstrap peer addresses.
 *
 * @throws if an invalid combination of options is passed, see [[BootstrapOptions]] for details.
 */
class Bootstrap {
    constructor(opts) {
        const maxPeers = opts.maxPeers ?? Bootstrap.DefaultMaxPeers;
        if (opts.default) {
            dbg("Use hosted list of peers.");
            this.getBootstrapPeers = () => {
                return Promise.resolve((0, index_1.getPredefinedBootstrapNodes)(undefined, maxPeers));
            };
        }
        else if (opts.peers !== undefined && opts.peers.length > 0) {
            const allPeers = opts.peers.map((node) => {
                if (typeof node === "string") {
                    return new multiaddr_1.Multiaddr(node);
                }
                else {
                    return node;
                }
            });
            const peers = (0, index_1.getPseudoRandomSubset)(allPeers, maxPeers);
            dbg("Use provided list of peers (reduced to maxPeers)", allPeers.map((ma) => ma.toString()));
            this.getBootstrapPeers = () => Promise.resolve(peers);
        }
        else if (typeof opts.getPeers === "function") {
            dbg("Bootstrap: Use provided getPeers function.");
            const getPeers = opts.getPeers;
            this.getBootstrapPeers = async () => {
                const allPeers = await getPeers();
                return (0, index_1.getPseudoRandomSubset)(allPeers, maxPeers).map((node) => new multiaddr_1.Multiaddr(node));
            };
        }
        else if (opts.enrUrl) {
            const wantedNodeCapabilityCount = opts.wantedNodeCapabilityCount;
            if (!wantedNodeCapabilityCount)
                throw "`wantedNodeCapabilityCount` must be defined when using `enrUrl`";
            const enrUrl = opts.enrUrl;
            dbg("Use provided EIP-1459 ENR Tree URL.");
            const dns = dns_1.DnsNodeDiscovery.dnsOverHttp();
            this.getBootstrapPeers = async () => {
                const enrs = await dns.getPeers([enrUrl], wantedNodeCapabilityCount);
                dbg(`Found ${enrs.length} peers`);
                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();
            };
        }
        else {
            dbg("No bootstrap method specified, no peer will be returned");
            this.getBootstrapPeers = undefined;
        }
    }
}
exports.Bootstrap = Bootstrap;
Bootstrap.DefaultMaxPeers = 1;
//# sourceMappingURL=bootstrap.js.map