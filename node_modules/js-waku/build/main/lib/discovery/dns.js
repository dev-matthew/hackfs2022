"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DnsNodeDiscovery = void 0;
const debug_1 = require("debug");
const enr_1 = require("../enr");
const dns_over_https_1 = require("./dns_over_https");
const enrtree_1 = require("./enrtree");
const fetch_nodes_1 = __importDefault(require("./fetch_nodes"));
const dbg = (0, debug_1.debug)("waku:discovery:dns");
class DnsNodeDiscovery {
    constructor(dns) {
        this._errorTolerance = 10;
        this._DNSTreeCache = {};
        this.dns = dns;
    }
    static dnsOverHttp(endpoints) {
        const dnsClient = new dns_over_https_1.DnsOverHttps(endpoints);
        return new DnsNodeDiscovery(dnsClient);
    }
    /**
     * Returns a list of verified peers listed in an EIP-1459 DNS tree. Method may
     * return fewer peers than requested if [[wantedNodeCapabilityCount]] requires
     * larger quantity of peers than available or the number of errors/duplicate
     * peers encountered by randomized search exceeds the sum of the fields of
     * [[wantedNodeCapabilityCount]] plus the [[_errorTolerance]] factor.
     */
    async getPeers(enrTreeUrls, wantedNodeCapabilityCount) {
        const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
        const { publicKey, domain } = enrtree_1.ENRTree.parseTree(enrTreeUrls[networkIndex]);
        const context = {
            domain,
            publicKey,
            visits: {},
        };
        const peers = await (0, fetch_nodes_1.default)(wantedNodeCapabilityCount, this._errorTolerance, () => this._search(domain, context));
        dbg("retrieved peers: ", peers);
        return peers;
    }
    /**
     * Runs a recursive, randomized descent of the DNS tree to retrieve a single
     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
     */
    async _search(subdomain, context) {
        try {
            const entry = await this._getTXTRecord(subdomain, context);
            context.visits[subdomain] = true;
            let next;
            let branches;
            const entryType = getEntryType(entry);
            try {
                switch (entryType) {
                    case enrtree_1.ENRTree.ROOT_PREFIX:
                        next = enrtree_1.ENRTree.parseAndVerifyRoot(entry, context.publicKey);
                        return await this._search(next, context);
                    case enrtree_1.ENRTree.BRANCH_PREFIX:
                        branches = enrtree_1.ENRTree.parseBranch(entry);
                        next = selectRandomPath(branches, context);
                        return await this._search(next, context);
                    case enrtree_1.ENRTree.RECORD_PREFIX:
                        return enr_1.ENR.decodeTxt(entry);
                    default:
                        return null;
                }
            }
            catch (error) {
                dbg(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
                return null;
            }
        }
        catch (error) {
            dbg(`Failed to retrieve TXT record at subdomain ${subdomain}: ${error}`);
            return null;
        }
    }
    /**
     * Retrieves the TXT record stored at a location from either
     * this DNS tree cache or via DNS query.
     *
     * @throws if the TXT Record contains non-UTF-8 values.
     */
    async _getTXTRecord(subdomain, context) {
        if (this._DNSTreeCache[subdomain]) {
            return this._DNSTreeCache[subdomain];
        }
        // Location is either the top level tree entry host or a subdomain of it.
        const location = subdomain !== context.domain
            ? `${subdomain}.${context.domain}`
            : context.domain;
        const response = await this.dns.resolveTXT(location);
        if (!response.length)
            throw new Error("Received empty result array while fetching TXT record");
        if (!response[0].length)
            throw new Error("Received empty TXT record");
        // Branch entries can be an array of strings of comma delimited subdomains, with
        // some subdomain strings split across the array elements
        const result = response.join("");
        this._DNSTreeCache[subdomain] = result;
        return result;
    }
}
exports.DnsNodeDiscovery = DnsNodeDiscovery;
function getEntryType(entry) {
    if (entry.startsWith(enrtree_1.ENRTree.ROOT_PREFIX))
        return enrtree_1.ENRTree.ROOT_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.BRANCH_PREFIX))
        return enrtree_1.ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.RECORD_PREFIX))
        return enrtree_1.ENRTree.RECORD_PREFIX;
    return "";
}
/**
 * Returns a randomly selected subdomain string from the list provided by a branch
 * entry record.
 *
 * The client must track subdomains which are already resolved to avoid
 * going into an infinite loop b/c branch entries can contain
 * circular references. It’s in the client’s best interest to traverse the
 * tree in random order.
 */
function selectRandomPath(branches, context) {
    // Identify domains already visited in this traversal of the DNS tree.
    // Then filter against them to prevent cycles.
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
        if (context.visits[subdomain]) {
            circularRefs[idx] = true;
        }
    }
    // If all possible paths are circular...
    if (Object.keys(circularRefs).length === branches.length) {
        throw new Error("Unresolvable circular path detected");
    }
    // Randomly select a viable path
    let index;
    do {
        index = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index]);
    return branches[index];
}
//# sourceMappingURL=dns.js.map