"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENR = void 0;
const RLP = __importStar(require("@ethersproject/rlp"));
const debug_1 = __importDefault(require("debug"));
const multiaddr_1 = require("multiaddr");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const convert_1 = __importDefault(require("multiaddr/src/convert"));
const from_string_1 = require("uint8arrays/from-string");
const to_string_1 = require("uint8arrays/to-string");
const varint_1 = require("varint");
const crypto_1 = require("../crypto");
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const keypair_1 = require("./keypair");
const multiaddrs_codec_1 = require("./multiaddrs_codec");
const v4 = __importStar(require("./v4"));
const waku2_codec_1 = require("./waku2_codec");
const dbg = (0, debug_1.default)("waku:enr");
class ENR extends Map {
    constructor(kvs = {}, seq = BigInt(1), signature = null) {
        super(Object.entries(kvs));
        this.seq = seq;
        this.signature = signature;
    }
    static async create(kvs = {}, seq = BigInt(1), signature = null) {
        const enr = new ENR(kvs, seq, signature);
        try {
            const publicKey = enr.publicKey;
            if (publicKey) {
                const keypair = (0, keypair_1.createKeypair)(enr.keypairType, undefined, publicKey);
                enr.peerId = await (0, keypair_1.createPeerIdFromKeypair)(keypair);
            }
        }
        catch (e) {
            dbg("Could not calculate peer id for ENR", e);
        }
        return enr;
    }
    static createV4(publicKey, kvs = {}) {
        // EIP-778 specifies that the key must be in compressed format, 33 bytes
        if (publicKey.length !== 33) {
            publicKey = (0, crypto_1.compressPublicKey)(publicKey);
        }
        return ENR.create({
            ...kvs,
            id: (0, utils_1.utf8ToBytes)("v4"),
            secp256k1: publicKey,
        });
    }
    static createFromPeerId(peerId, kvs = {}) {
        const keypair = (0, keypair_1.createKeypairFromPeerId)(peerId);
        switch (keypair.type) {
            case keypair_1.KeypairType.secp256k1:
                return ENR.createV4(keypair.publicKey, kvs);
            default:
                throw new Error();
        }
    }
    static async decodeFromValues(decoded) {
        if (!Array.isArray(decoded)) {
            throw new Error("Decoded ENR must be an array");
        }
        if (decoded.length % 2 !== 0) {
            throw new Error("Decoded ENR must have an even number of elements");
        }
        const [signature, seq, ...kvs] = decoded;
        if (!signature || Array.isArray(signature)) {
            throw new Error("Decoded ENR invalid signature: must be a byte array");
        }
        if (!seq || Array.isArray(seq)) {
            throw new Error("Decoded ENR invalid sequence number: must be a byte array");
        }
        const obj = {};
        for (let i = 0; i < kvs.length; i += 2) {
            try {
                obj[(0, utils_1.bytesToUtf8)(kvs[i])] = kvs[i + 1];
            }
            catch (e) {
                dbg("Failed to decode ENR key to UTF-8, skipping it", kvs[i], e);
            }
        }
        // If seq is an empty array, translate as value 0
        const hexSeq = "0x" + (seq.length ? (0, utils_1.bytesToHex)(seq) : "00");
        const enr = await ENR.create(obj, BigInt(hexSeq), signature);
        const rlpEncodedBytes = (0, utils_1.hexToBytes)(RLP.encode([seq, ...kvs]));
        if (!enr.verify(rlpEncodedBytes, signature)) {
            throw new Error("Unable to verify ENR signature");
        }
        return enr;
    }
    static decode(encoded) {
        const decoded = RLP.decode(encoded).map(utils_1.hexToBytes);
        return ENR.decodeFromValues(decoded);
    }
    static decodeTxt(encoded) {
        if (!encoded.startsWith(this.RECORD_PREFIX)) {
            throw new Error(`"string encoded ENR must start with '${this.RECORD_PREFIX}'`);
        }
        return ENR.decode((0, from_string_1.fromString)(encoded.slice(4), "base64url"));
    }
    set(k, v) {
        this.signature = null;
        this.seq++;
        return super.set(k, v);
    }
    get id() {
        const id = this.get("id");
        if (!id)
            throw new Error("id not found.");
        return (0, utils_1.bytesToUtf8)(id);
    }
    get keypairType() {
        switch (this.id) {
            case "v4":
                return keypair_1.KeypairType.secp256k1;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get publicKey() {
        switch (this.id) {
            case "v4":
                return this.get("secp256k1");
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get keypair() {
        if (this.publicKey) {
            const publicKey = this.publicKey;
            return (0, keypair_1.createKeypair)(this.keypairType, undefined, publicKey);
        }
        return;
    }
    get nodeId() {
        switch (this.id) {
            case "v4":
                return this.publicKey ? v4.nodeId(this.publicKey) : undefined;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get ip() {
        const raw = this.get("ip");
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip4.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip(ip) {
        if (ip) {
            this.set("ip", convert_1.default.toBytes(multiaddr_1.protocols.names.ip4.code, ip));
        }
        else {
            this.delete("ip");
        }
    }
    get tcp() {
        const raw = this.get("tcp");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp(port) {
        if (port === undefined) {
            this.delete("tcp");
        }
        else {
            this.set("tcp", convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp() {
        const raw = this.get("udp");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp(port) {
        if (port === undefined) {
            this.delete("udp");
        }
        else {
            this.set("udp", convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    get ip6() {
        const raw = this.get("ip6");
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip6.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip6(ip) {
        if (ip) {
            this.set("ip6", convert_1.default.toBytes(multiaddr_1.protocols.names.ip6.code, ip));
        }
        else {
            this.delete("ip6");
        }
    }
    get tcp6() {
        const raw = this.get("tcp6");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp6(port) {
        if (port === undefined) {
            this.delete("tcp6");
        }
        else {
            this.set("tcp6", convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp6() {
        const raw = this.get("udp6");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp6(port) {
        if (port === undefined) {
            this.delete("udp6");
        }
        else {
            this.set("udp6", convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    /**
     * Get the `multiaddrs` field from ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[getLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
     */
    get multiaddrs() {
        const raw = this.get("multiaddrs");
        if (raw)
            return (0, multiaddrs_codec_1.decodeMultiaddrs)(raw);
        return;
    }
    /**
     * Set the `multiaddrs` field on the ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[setLocationMultiaddr]] should be preferred.
     * The multiaddresses stored in this field must be location multiaddresses,
     * ie, without a peer id.
     */
    set multiaddrs(multiaddrs) {
        if (multiaddrs === undefined) {
            this.delete("multiaddrs");
        }
        else {
            const multiaddrsBuf = (0, multiaddrs_codec_1.encodeMultiaddrs)(multiaddrs);
            this.set("multiaddrs", multiaddrsBuf);
        }
    }
    getLocationMultiaddr(protocol) {
        if (protocol === "udp") {
            return (this.getLocationMultiaddr("udp4") || this.getLocationMultiaddr("udp6"));
        }
        if (protocol === "tcp") {
            return (this.getLocationMultiaddr("tcp4") || this.getLocationMultiaddr("tcp6"));
        }
        const isIpv6 = protocol.endsWith("6");
        const ipVal = this.get(isIpv6 ? "ip6" : "ip");
        if (!ipVal) {
            return undefined;
        }
        const isUdp = protocol.startsWith("udp");
        const isTcp = protocol.startsWith("tcp");
        let protoName, protoVal;
        if (isUdp) {
            protoName = "udp";
            protoVal = isIpv6 ? this.get("udp6") : this.get("udp");
        }
        else if (isTcp) {
            protoName = "tcp";
            protoVal = isIpv6 ? this.get("tcp6") : this.get("tcp");
        }
        else {
            return undefined;
        }
        if (!protoVal) {
            return undefined;
        }
        // Create raw multiaddr buffer
        // multiaddr length is:
        //  1 byte for the ip protocol (ip4 or ip6)
        //  N bytes for the ip address
        //  1 or 2 bytes for the protocol as buffer (tcp or udp)
        //  2 bytes for the port
        const ipMa = multiaddr_1.protocols.names[isIpv6 ? "ip6" : "ip4"];
        const ipByteLen = ipMa.size / 8;
        const protoMa = multiaddr_1.protocols.names[protoName];
        const protoBuf = (0, varint_1.encode)(protoMa.code);
        const maBuf = new Uint8Array(3 + ipByteLen + protoBuf.length);
        maBuf[0] = ipMa.code;
        maBuf.set(ipVal, 1);
        maBuf.set(protoBuf, 1 + ipByteLen);
        maBuf.set(protoVal, 1 + ipByteLen + protoBuf.length);
        return new multiaddr_1.Multiaddr(maBuf);
    }
    setLocationMultiaddr(multiaddr) {
        const protoNames = multiaddr.protoNames();
        if (protoNames.length !== 2 &&
            protoNames[1] !== "udp" &&
            protoNames[1] !== "tcp") {
            throw new Error("Invalid multiaddr");
        }
        const tuples = multiaddr.tuples();
        if (!tuples[0][1] || !tuples[1][1]) {
            throw new Error("Invalid multiaddr");
        }
        // IPv4
        if (tuples[0][0] === 4) {
            this.set("ip", tuples[0][1]);
            this.set(protoNames[1], tuples[1][1]);
        }
        else {
            this.set("ip6", tuples[0][1]);
            this.set(protoNames[1] + "6", tuples[1][1]);
        }
    }
    /**
     * Returns the full multiaddr from the ENR fields matching the provided
     * `protocol` parameter.
     * To return full multiaddrs from the `multiaddrs` ENR field,
     * use [[ENR.getFullMultiaddrs]]
     *
     * @param protocol
     */
    getFullMultiaddr(protocol) {
        if (this.peerId) {
            const locationMultiaddr = this.getLocationMultiaddr(protocol);
            if (locationMultiaddr) {
                return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toB58String()}`);
            }
        }
        return;
    }
    /**
     * Returns the full multiaddrs from the `multiaddrs` ENR field.
     */
    getFullMultiaddrs() {
        if (this.peerId && this.multiaddrs) {
            const peerId = this.peerId;
            return this.multiaddrs.map((ma) => {
                return ma.encapsulate(`/p2p/${peerId.toB58String()}`);
            });
        }
        return [];
    }
    /**
     * Get the `waku2` field from ENR.
     */
    get waku2() {
        const raw = this.get("waku2");
        if (raw)
            return (0, waku2_codec_1.decodeWaku2)(raw[0]);
        return;
    }
    /**
     * Set the `waku2` field on the ENR.
     */
    set waku2(waku2) {
        if (waku2 === undefined) {
            this.delete("waku2");
        }
        else {
            const byte = (0, waku2_codec_1.encodeWaku2)(waku2);
            this.set("waku2", new Uint8Array([byte]));
        }
    }
    verify(data, signature) {
        if (!this.get("id") || this.id !== "v4") {
            throw new Error(constants_1.ERR_INVALID_ID);
        }
        if (!this.publicKey) {
            throw new Error("Failed to verify ENR: No public key");
        }
        return (0, crypto_1.verifySignature)(signature, (0, crypto_1.keccak256)(data), this.publicKey);
    }
    async sign(data, privateKey) {
        switch (this.id) {
            case "v4":
                this.signature = await v4.sign(privateKey, data);
                break;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
        return this.signature;
    }
    async encodeToValues(privateKey) {
        // sort keys and flatten into [k, v, k, v, ...]
        const content = Array.from(this.keys())
            .sort((a, b) => a.localeCompare(b))
            .map((k) => [k, this.get(k)])
            .map(([k, v]) => [(0, utils_1.utf8ToBytes)(k), v])
            .flat();
        content.unshift(new Uint8Array([Number(this.seq)]));
        if (privateKey) {
            content.unshift(await this.sign((0, utils_1.hexToBytes)(RLP.encode(content)), privateKey));
        }
        else {
            if (!this.signature) {
                throw new Error(constants_1.ERR_NO_SIGNATURE);
            }
            content.unshift(this.signature);
        }
        return content;
    }
    async encode(privateKey) {
        const encoded = (0, utils_1.hexToBytes)(RLP.encode(await this.encodeToValues(privateKey)));
        if (encoded.length >= constants_1.MAX_RECORD_SIZE) {
            throw new Error("ENR must be less than 300 bytes");
        }
        return encoded;
    }
    async encodeTxt(privateKey) {
        return (ENR.RECORD_PREFIX + (0, to_string_1.toString)(await this.encode(privateKey), "base64url"));
    }
}
exports.ENR = ENR;
ENR.RECORD_PREFIX = "enr:";
//# sourceMappingURL=enr.js.map