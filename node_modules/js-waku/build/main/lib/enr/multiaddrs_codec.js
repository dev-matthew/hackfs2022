"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeMultiaddrs = exports.decodeMultiaddrs = void 0;
const multiaddr_1 = require("multiaddr");
const constants_1 = require("./constants");
function decodeMultiaddrs(bytes) {
    const multiaddrs = [];
    let index = 0;
    while (index < bytes.length) {
        const sizeDataView = new DataView(bytes.buffer, index, constants_1.MULTIADDR_LENGTH_SIZE);
        const size = sizeDataView.getUint16(0);
        index += constants_1.MULTIADDR_LENGTH_SIZE;
        const multiaddrBytes = bytes.slice(index, index + size);
        index += size;
        const multiaddr = new multiaddr_1.Multiaddr(multiaddrBytes);
        multiaddrs.push(multiaddr);
    }
    return multiaddrs;
}
exports.decodeMultiaddrs = decodeMultiaddrs;
function encodeMultiaddrs(multiaddrs) {
    const totalLength = multiaddrs.reduce((acc, ma) => acc + constants_1.MULTIADDR_LENGTH_SIZE + ma.bytes.length, 0);
    const bytes = new Uint8Array(totalLength);
    const dataView = new DataView(bytes.buffer);
    let index = 0;
    multiaddrs.forEach((multiaddr) => {
        if (multiaddr.getPeerId())
            throw new Error("`multiaddr` field MUST not contain peer id");
        // Prepend the size of the next entry
        dataView.setUint16(index, multiaddr.bytes.length);
        index += constants_1.MULTIADDR_LENGTH_SIZE;
        bytes.set(multiaddr.bytes, index);
        index += multiaddr.bytes.length;
    });
    return bytes;
}
exports.encodeMultiaddrs = encodeMultiaddrs;
//# sourceMappingURL=multiaddrs_codec.js.map