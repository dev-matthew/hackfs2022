"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Waku = exports.Protocols = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;
const libp2p_noise_1 = require("@chainsafe/libp2p-noise");
const debug_1 = __importDefault(require("debug"));
const libp2p_1 = __importDefault(require("libp2p"));
const libp2p_bootstrap_1 = __importDefault(require("libp2p-bootstrap"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_mplex_1 = __importDefault(require("libp2p-mplex"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_websockets_1 = __importDefault(require("libp2p-websockets"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const filters_1 = __importDefault(require("libp2p-websockets/src/filters"));
const ping_1 = __importDefault(require("libp2p/src/ping"));
const multiaddr_1 = require("multiaddr");
const peer_id_1 = __importDefault(require("peer-id"));
const discovery_1 = require("./discovery");
const waku_filter_1 = require("./waku_filter");
const waku_light_push_1 = require("./waku_light_push");
const waku_message_1 = require("./waku_message");
const waku_relay_1 = require("./waku_relay");
const constants_1 = require("./waku_relay/constants");
const waku_store_1 = require("./waku_store");
const websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];
exports.DefaultPingKeepAliveValueSecs = 0;
exports.DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
exports.DefaultPubSubTopic = "/waku/2/default-waku/proto";
const dbg = (0, debug_1.default)("waku:waku");
var Protocols;
(function (Protocols) {
    Protocols["Relay"] = "relay";
    Protocols["Store"] = "store";
    Protocols["LightPush"] = "lightpush";
    Protocols["Filter"] = "filter";
})(Protocols = exports.Protocols || (exports.Protocols = {}));
class Waku {
    constructor(options, libp2p, store, lightPush, filter) {
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.filter = filter;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on("peer:connect", (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on("peer:disconnect", (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        options?.decryptionKeys?.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Create and start new waku node.
     */
    static async create(options) {
        // Get an object in case options or libp2p are undefined
        const libp2pOpts = Object.assign({}, options?.libp2p);
        // Default for Websocket filter is `all`:
        // Returns all TCP and DNS based addresses, both with ws or wss.
        libp2pOpts.config = Object.assign({
            transport: {
                [websocketsTransportKey]: {
                    filter: filters_1.default.all,
                },
            },
        }, options?.libp2p?.config);
        // Pass pubsub topic to relay
        if (options?.pubSubTopic) {
            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
        }
        libp2pOpts.modules = Object.assign({}, options?.libp2p?.modules);
        // Default transport for libp2p is Websockets
        libp2pOpts.modules = Object.assign({
            transport: [libp2p_websockets_1.default],
        }, options?.libp2p?.modules);
        // streamMuxer, connection encryption and pubsub are overridden
        // as those are the only ones currently supported by Waku nodes.
        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
            streamMuxer: [libp2p_mplex_1.default],
            connEncryption: [new libp2p_noise_1.Noise(options?.staticNoiseKey)],
            pubsub: waku_relay_1.WakuRelay,
        });
        if (options?.bootstrap) {
            const bootstrap = new discovery_1.Bootstrap(options?.bootstrap);
            if (bootstrap.getBootstrapPeers !== undefined) {
                try {
                    const list = await bootstrap.getBootstrapPeers();
                    // Note: this overrides any other peer discover
                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                        peerDiscovery: [libp2p_bootstrap_1.default],
                    });
                    libp2pOpts.config.peerDiscovery = {
                        [libp2p_bootstrap_1.default.tag]: {
                            list,
                            enabled: true,
                        },
                    };
                }
                catch (e) {
                    dbg("Failed to retrieve bootstrap nodes", e);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: modules property is correctly set thanks to voodoo
        const libp2p = await libp2p_1.default.create(libp2pOpts);
        const wakuStore = new waku_store_1.WakuStore(libp2p, {
            pubSubTopic: options?.pubSubTopic,
        });
        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);
        const wakuFilter = new waku_filter_1.WakuFilter(libp2p);
        await libp2p.start();
        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush, wakuFilter);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     * @param protocols Waku protocols we expect from the peer; Default to Relay
     */
    async dial(peer, protocols) {
        const _protocols = protocols ?? [Protocols.Relay];
        const codecs = [];
        if (_protocols.includes(Protocols.Relay)) {
            waku_relay_1.RelayCodecs.forEach((codec) => codecs.push(codec));
        }
        if (_protocols.includes(Protocols.Store)) {
            for (const codec of Object.values(waku_store_1.StoreCodecs)) {
                codecs.push(codec);
            }
        }
        if (_protocols.includes(Protocols.LightPush)) {
            codecs.push(waku_light_push_1.LightPushCodec);
        }
        if (_protocols.includes(Protocols.Filter)) {
            codecs.push(waku_filter_1.FilterCodec);
        }
        return this.libp2p.dialProtocol(peer, codecs);
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === "string") {
            peer = peer_id_1.default.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === "string") {
                return (0, multiaddr_1.multiaddr)(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    async stop() {
        return this.libp2p.stop();
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.relay.addDecryptionKey(key, options);
        this.store.addDecryptionKey(key, options);
        this.filter.addDecryptionKey(key, options);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
        this.filter.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     *
     * @throws if libp2p is not listening on localhost.
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === "") {
            throw "Not listening on localhost";
        }
        return localMultiaddr + "/p2p/" + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait for a remote peer to be ready given the passed protocols.
     * Useful when using the [[CreateOptions.bootstrap]] with [[Waku.create]].
     *
     * @param protocols The protocols that need to be enabled by remote peers.
     * @param timeoutMs A timeout value in milliseconds..
     *
     * @returns A promise that **resolves** if all desired protocols are fulfilled by
     * remote nodes, **rejects** if the timeoutMs is reached.
     *
     * @default Remote peer must have Waku Relay enabled and no time out is applied.
     */
    async waitForRemotePeer(protocols, timeoutMs) {
        protocols = protocols ?? [Protocols.Relay];
        const promises = [];
        if (protocols.includes(Protocols.Relay)) {
            const peers = this.relay.getPeers();
            if (peers.size == 0) {
                // No peer yet available, wait for a subscription
                const promise = new Promise((resolve) => {
                    this.libp2p.pubsub.once("pubsub:subscription-change", () => {
                        // Remote peer subscribed to topic, now wait for a heartbeat
                        // so that the mesh is updated and the remote peer added to it
                        this.libp2p.pubsub.once("gossipsub:heartbeat", resolve);
                    });
                });
                promises.push(promise);
            }
        }
        if (protocols.includes(Protocols.Store)) {
            const storePromise = (async () => {
                for await (const peer of this.store.peers) {
                    dbg("Store peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(storePromise);
        }
        if (protocols.includes(Protocols.LightPush)) {
            const lightPushPromise = (async () => {
                for await (const peer of this.lightPush.peers) {
                    dbg("Light Push peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(lightPushPromise);
        }
        if (protocols.includes(Protocols.Filter)) {
            const filterPromise = (async () => {
                for await (const peer of this.filter.peers) {
                    dbg("Filter peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(filterPromise);
        }
        if (timeoutMs) {
            await rejectOnTimeout(Promise.all(promises), timeoutMs, "Timed out waiting for a remote peer.");
        }
        else {
            await Promise.all(promises);
        }
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            const pingService = new ping_1.default(this.libp2p);
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                pingService.ping(peerId).catch((e) => {
                    dbg(`Ping failed (${peerIdStr})`, e);
                });
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
exports.Waku = Waku;
const awaitTimeout = (ms, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms));
const rejectOnTimeout = (promise, timeoutMs, rejectReason) => Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
//# sourceMappingURL=waku.js.map