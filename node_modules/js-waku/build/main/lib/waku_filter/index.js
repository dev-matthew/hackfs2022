"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WakuFilter = exports.FilterCodec = void 0;
const debug_1 = __importDefault(require("debug"));
const it_length_prefixed_1 = __importDefault(require("it-length-prefixed"));
const it_pipe_1 = require("it-pipe");
const select_peer_1 = require("../select_peer");
const utils_1 = require("../utils");
const waku_1 = require("../waku");
const waku_message_1 = require("../waku_message");
const filter_rpc_1 = require("./filter_rpc");
exports.FilterCodec = "/vac/waku/filter/2.0.0-beta1";
const log = (0, debug_1.default)("waku:filter");
/**
 * Implements client side of the [Waku v2 Filter protocol](https://rfc.vac.dev/spec/12/).
 *
 * Note this currently only works in NodeJS when the Waku node is listening on a port, see:
 * - https://github.com/status-im/go-waku/issues/245
 * - https://github.com/status-im/nwaku/issues/948
 */
class WakuFilter {
    constructor(libp2p) {
        this.libp2p = libp2p;
        this.subscriptions = new Map();
        this.decryptionKeys = new Map();
        this.libp2p.handle(exports.FilterCodec, this.onRequest.bind(this));
    }
    /**
     * @param contentTopics Array of ContentTopics to subscribe to. If empty, no messages will be returned from the filter.
     * @param callback A function that will be called on each message returned by the filter.
     * @param opts The FilterSubscriptionOpts used to narrow which messages are returned, and which peer to connect to.
     * @returns Unsubscribe function that can be used to end the subscription.
     */
    async subscribe(callback, contentTopics, opts) {
        const topic = opts?.pubsubTopic || waku_1.DefaultPubSubTopic;
        const contentFilters = contentTopics.map((contentTopic) => ({
            contentTopic,
        }));
        const request = filter_rpc_1.FilterRPC.createRequest(topic, contentFilters, undefined, true);
        const peer = await this.getPeer(opts?.peerId);
        const stream = await this.newStream(peer);
        try {
            await (0, it_pipe_1.pipe)([request.encode()], it_length_prefixed_1.default.encode(), stream);
        }
        catch (e) {
            log("Error subscribing to peer ", peer.id.toB58String(), "for content topics", contentTopics, ": ", e);
            throw e;
        }
        this.addCallback(request.requestId, callback);
        return async () => {
            await this.unsubscribe(topic, contentFilters, request.requestId, peer);
            this.removeCallback(request.requestId);
        };
    }
    async onRequest({ stream }) {
        log("Receiving message push");
        try {
            await (0, it_pipe_1.pipe)(stream.source, it_length_prefixed_1.default.decode(), async (source) => {
                for await (const bytes of source) {
                    const res = filter_rpc_1.FilterRPC.decode(bytes.slice());
                    if (res.push?.messages?.length) {
                        await this.pushMessages(res.requestId, res.push.messages);
                    }
                }
            });
        }
        catch (e) {
            log("Error decoding message", e);
        }
    }
    async pushMessages(requestId, messages) {
        const callback = this.subscriptions.get(requestId);
        if (!callback) {
            log(`No callback registered for request ID ${requestId}`);
            return;
        }
        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
            return {
                key,
                method,
                contentTopics,
            };
        });
        for (const message of messages) {
            const decoded = await waku_message_1.WakuMessage.decodeProto(message, decryptionKeys);
            if (!decoded) {
                log("Not able to decode message");
                continue;
            }
            callback(decoded);
        }
    }
    addCallback(requestId, callback) {
        this.subscriptions.set(requestId, callback);
    }
    removeCallback(requestId) {
        this.subscriptions.delete(requestId);
    }
    async unsubscribe(topic, contentFilters, requestId, peer) {
        const unsubscribeRequest = filter_rpc_1.FilterRPC.createRequest(topic, contentFilters, requestId, false);
        const stream = await this.newStream(peer);
        try {
            await (0, it_pipe_1.pipe)([unsubscribeRequest.encode()], it_length_prefixed_1.default.encode(), stream.sink);
        }
        catch (e) {
            log("Error unsubscribing", e);
            throw e;
        }
    }
    async newStream(peer) {
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection) {
            throw new Error("Failed to get a connection to the peer");
        }
        const { stream } = await connection.newStream(exports.FilterCodec);
        return stream;
    }
    async getPeer(peerId) {
        let peer;
        if (peerId) {
            peer = await this.libp2p.peerStore.get(peerId);
            if (!peer) {
                throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toB58String()}`);
            }
        }
        else {
            peer = await this.randomPeer;
            if (!peer) {
                throw new Error("Failed to find known peer that registers waku filter protocol");
            }
        }
        return peer;
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[subscribe]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set((0, utils_1.hexToBytes)(key), options ?? {});
    }
    /**
     * Delete a decryption key so that it cannot be used in future [[subscribe]] calls
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete((0, utils_1.hexToBytes)(key));
    }
    get peers() {
        return (0, select_peer_1.getPeersForProtocol)(this.libp2p, [exports.FilterCodec]);
    }
    get randomPeer() {
        return (0, select_peer_1.selectRandomPeer)(this.peers);
    }
}
exports.WakuFilter = WakuFilter;
//# sourceMappingURL=index.js.map