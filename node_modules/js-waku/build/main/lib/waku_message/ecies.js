"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = void 0;
const secp = __importStar(require("@noble/secp256k1"));
const concat_1 = require("uint8arrays/concat");
const crypto_1 = require("../crypto");
const utils_1 = require("../utils");
/**
 * HKDF as implemented in go-ethereum.
 */
function kdf(secret, outputLength) {
    let ctr = 1;
    let written = 0;
    let willBeResult = Promise.resolve(new Uint8Array());
    while (written < outputLength) {
        const counters = new Uint8Array([ctr >> 24, ctr >> 16, ctr >> 8, ctr]);
        const countersSecret = (0, concat_1.concat)([counters, secret], counters.length + secret.length);
        const willBeHashResult = (0, crypto_1.sha256)(countersSecret);
        willBeResult = willBeResult.then((result) => willBeHashResult.then((hashResult) => {
            const _hashResult = new Uint8Array(hashResult);
            return (0, concat_1.concat)([result, _hashResult], result.length + _hashResult.length);
        }));
        written += 32;
        ctr += 1;
    }
    return willBeResult;
}
function aesCtrEncrypt(counter, key, data) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, "AES-CTR", false, ["encrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().encrypt({ name: "AES-CTR", counter: counter, length: 128 }, cryptoKey, data))
        .then((bytes) => new Uint8Array(bytes));
}
function aesCtrDecrypt(counter, key, data) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, "AES-CTR", false, ["decrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().decrypt({ name: "AES-CTR", counter: counter, length: 128 }, cryptoKey, data))
        .then((bytes) => new Uint8Array(bytes));
}
function hmacSha256Sign(key, msg) {
    const algorithm = { name: "HMAC", hash: { name: "SHA-256" } };
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, algorithm, false, ["sign"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().sign(algorithm, cryptoKey, msg))
        .then((bytes) => new Uint8Array(bytes));
}
function hmacSha256Verify(key, msg, sig) {
    const algorithm = { name: "HMAC", hash: { name: "SHA-256" } };
    const _key = (0, crypto_1.getSubtle)().importKey("raw", key, algorithm, false, ["verify"]);
    return _key.then((cryptoKey) => (0, crypto_1.getSubtle)().verify(algorithm, cryptoKey, sig, msg));
}
/**
 * Derive shared secret for given private and public keys.
 *
 * @param  privateKeyA Sender's private key (32 bytes)
 * @param  publicKeyB Recipient's public key (65 bytes)
 * @returns  A promise that resolves with the derived shared secret (Px, 32 bytes)
 * @throws Error If arguments are invalid
 */
function derive(privateKeyA, publicKeyB) {
    if (privateKeyA.length !== 32) {
        throw new Error(`Bad private key, it should be 32 bytes but it's actually ${privateKeyA.length} bytes long`);
    }
    else if (publicKeyB.length !== 65) {
        throw new Error(`Bad public key, it should be 65 bytes but it's actually ${publicKeyB.length} bytes long`);
    }
    else if (publicKeyB[0] !== 4) {
        throw new Error("Bad public key, a valid public key would begin with 4");
    }
    else {
        const px = secp.getSharedSecret(privateKeyA, publicKeyB, true);
        // Remove the compression prefix
        return new Uint8Array((0, utils_1.hexToBytes)(px).slice(1));
    }
}
/**
 * Encrypt message for given recipient's public key.
 *
 * @param  publicKeyTo Recipient's public key (65 bytes)
 * @param  msg The message being encrypted
 * @return A promise that resolves with the ECIES structure serialized
 */
async function encrypt(publicKeyTo, msg) {
    const ephemPrivateKey = (0, crypto_1.randomBytes)(32);
    const sharedPx = await derive(ephemPrivateKey, publicKeyTo);
    const hash = await kdf(sharedPx, 32);
    const iv = (0, crypto_1.randomBytes)(16);
    const encryptionKey = hash.slice(0, 16);
    const cipherText = await aesCtrEncrypt(iv, encryptionKey, msg);
    const ivCipherText = (0, concat_1.concat)([iv, cipherText], iv.length + cipherText.length);
    const macKey = await (0, crypto_1.sha256)(hash.slice(16));
    const hmac = await hmacSha256Sign(macKey, ivCipherText);
    const ephemPublicKey = secp.getPublicKey(ephemPrivateKey, false);
    return (0, concat_1.concat)([ephemPublicKey, ivCipherText, hmac], ephemPublicKey.length + ivCipherText.length + hmac.length);
}
exports.encrypt = encrypt;
const metaLength = 1 + 64 + 16 + 32;
/**
 * Decrypt message using given private key.
 *
 * @param privateKey A 32-byte private key of recipient of the message
 * @param encrypted ECIES serialized structure (result of ECIES encryption)
 * @returns The clear text
 * @throws Error If decryption fails
 */
async function decrypt(privateKey, encrypted) {
    if (encrypted.length <= metaLength) {
        throw new Error(`Invalid Ciphertext. Data is too small. It should ba at least ${metaLength} bytes`);
    }
    else if (encrypted[0] !== 4) {
        throw new Error(`Not a valid ciphertext. It should begin with 4 but actually begin with ${encrypted[0]}`);
    }
    else {
        // deserialize
        const ephemPublicKey = encrypted.slice(0, 65);
        const cipherTextLength = encrypted.length - metaLength;
        const iv = encrypted.slice(65, 65 + 16);
        const cipherAndIv = encrypted.slice(65, 65 + 16 + cipherTextLength);
        const ciphertext = cipherAndIv.slice(16);
        const msgMac = encrypted.slice(65 + 16 + cipherTextLength);
        // check HMAC
        const px = derive(privateKey, ephemPublicKey);
        const hash = await kdf(px, 32);
        const [encryptionKey, macKey] = await (0, crypto_1.sha256)(hash.slice(16)).then((macKey) => [hash.slice(0, 16), macKey]);
        if (!(await hmacSha256Verify(macKey, cipherAndIv, msgMac))) {
            throw new Error("Incorrect MAC");
        }
        return aesCtrDecrypt(iv, encryptionKey, ciphertext);
    }
}
exports.decrypt = decrypt;
//# sourceMappingURL=ecies.js.map