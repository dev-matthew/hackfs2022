"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;
const secp = __importStar(require("@noble/secp256k1"));
const concat_1 = require("uint8arrays/concat");
const crypto_1 = require("../crypto");
const utils_1 = require("../utils");
const ecies = __importStar(require("./ecies"));
const symmetric = __importStar(require("./symmetric"));
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
exports.PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
async function clearEncode(messagePayload, sigPrivKey) {
    let envelope = new Uint8Array([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = (0, concat_1.concat)([envelope, messagePayload]);
    // Calculate padding:
    let rawSize = FlagsLength +
        computeSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    const remainder = rawSize % PaddingTarget;
    const paddingSize = PaddingTarget - remainder;
    const pad = (0, crypto_1.randomBytes)(paddingSize);
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error("failed to generate random padding of size " + paddingSize);
    }
    envelope = (0, concat_1.concat)([envelope, pad]);
    let sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        const hash = (0, crypto_1.keccak256)(envelope);
        const bytesSignature = await (0, crypto_1.sign)(hash, sigPrivKey);
        envelope = (0, concat_1.concat)([envelope, bytesSignature]);
        sig = {
            signature: bytesSignature,
            publicKey: secp.getPublicKey(sigPrivKey, false),
        };
    }
    return { payload: envelope, sig };
}
exports.clearEncode = clearEncode;
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
function clearDecode(message) {
    const sizeOfPayloadSizeField = getSizeOfPayloadSizeField(message);
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = getPayloadSize(message, sizeOfPayloadSizeField);
    const payloadStart = 1 + sizeOfPayloadSizeField;
    const payload = message.slice(payloadStart, payloadStart + payloadSize);
    const isSigned = isMessageSigned(message);
    let sig;
    if (isSigned) {
        const signature = getSignature(message);
        const hash = getHash(message, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
exports.clearDecode = clearDecode;
function getSizeOfPayloadSizeField(message) {
    const messageDataView = new DataView(message.buffer);
    return messageDataView.getUint8(0) & FlagMask;
}
function getPayloadSize(message, sizeOfPayloadSizeField) {
    let payloadSizeBytes = message.slice(1, 1 + sizeOfPayloadSizeField);
    // int 32 == 4 bytes
    if (sizeOfPayloadSizeField < 4) {
        // If less than 4 bytes pad right (Little Endian).
        payloadSizeBytes = (0, concat_1.concat)([payloadSizeBytes, new Uint8Array(4 - sizeOfPayloadSizeField)], 4);
    }
    const payloadSizeDataView = new DataView(payloadSizeBytes.buffer);
    return payloadSizeDataView.getInt32(0, true);
}
function isMessageSigned(message) {
    const messageDataView = new DataView(message.buffer);
    return (messageDataView.getUint8(0) & IsSignedMask) == IsSignedMask;
}
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result  can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptAsymmetric(data, publicKey) {
    return ecies.encrypt((0, utils_1.hexToBytes)(publicKey), data);
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The returned data is expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptAsymmetric(payload, privKey) {
    return ecies.decrypt(privKey, payload);
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptSymmetric(data, key) {
    const iv = symmetric.generateIv();
    // Returns `cipher | tag`
    const cipher = await symmetric.encrypt(iv, (0, utils_1.hexToBytes)(key), data);
    return (0, concat_1.concat)([cipher, iv]);
}
exports.encryptSymmetric = encryptSymmetric;
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptSymmetric(payload, key) {
    const ivStart = payload.length - symmetric.IvSize;
    const cipher = payload.slice(0, ivStart);
    const iv = payload.slice(ivStart);
    return symmetric.decrypt(iv, (0, utils_1.hexToBytes)(key), cipher);
}
exports.decryptSymmetric = decryptSymmetric;
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = computeSizeOfPayloadSizeField(payload);
    let field = new Uint8Array(4);
    const fieldDataView = new DataView(field.buffer);
    fieldDataView.setUint32(0, payload.length, true);
    field = field.slice(0, fieldSize);
    msg = (0, concat_1.concat)([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function computeSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return expectedSize <= 3 || value.findIndex((i) => i !== 0) !== -1;
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return (0, crypto_1.keccak256)(message.slice(0, message.length - SignatureLength));
    }
    return (0, crypto_1.keccak256)(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recoveryDataView = new DataView(signature.slice(64).buffer);
    const recovery = recoveryDataView.getUint8(0);
    const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
    return secp.recoverPublicKey(messageHash, _signature, recovery, 
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: compressed: false
    false);
}
//# sourceMappingURL=version_1.js.map