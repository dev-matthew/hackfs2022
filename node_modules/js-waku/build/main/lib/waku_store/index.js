"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodecs = void 0;
const debug_1 = __importDefault(require("debug"));
const it_concat_1 = __importDefault(require("it-concat"));
const it_length_prefixed_1 = __importDefault(require("it-length-prefixed"));
const it_pipe_1 = require("it-pipe");
const select_peer_1 = require("../select_peer");
const utils_1 = require("../utils");
const waku_1 = require("../waku");
const waku_message_1 = require("../waku_message");
const history_rpc_1 = require("./history_rpc");
Object.defineProperty(exports, "PageDirection", { enumerable: true, get: function () { return history_rpc_1.PageDirection; } });
const dbg = (0, debug_1.default)("waku:store");
var StoreCodecs;
(function (StoreCodecs) {
    StoreCodecs["V2Beta3"] = "/vac/waku/store/2.0.0-beta3";
    StoreCodecs["V2Beta4"] = "/vac/waku/store/2.0.0-beta4";
})(StoreCodecs = exports.StoreCodecs || (exports.StoreCodecs = {}));
exports.DefaultPageSize = 10;
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 *
 * The Waku Store protocol can be used to retrieved historical messages.
 */
class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options?.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
        this.decryptionKeys = new Map();
    }
    /**
     * Do a query to a Waku Store to retrieve historical/missed messages.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     * @param options Optional parameters.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    async queryHistory(contentTopics, options) {
        let startTime, endTime;
        if (options?.timeFilter) {
            startTime = options.timeFilter.startTime;
            endTime = options.timeFilter.endTime;
        }
        const opts = Object.assign({
            pubSubTopic: this.pubSubTopic,
            pageDirection: history_rpc_1.PageDirection.BACKWARD,
            pageSize: exports.DefaultPageSize,
        }, options, { contentTopics, startTime, endTime });
        dbg("Querying history with the following options", {
            peerId: options?.peerId?.toB58String(),
            ...options,
        });
        let peer;
        if (opts.peerId) {
            peer = await this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
        }
        else {
            peer = await this.randomPeer;
            if (!peer)
                throw "Failed to find known peer that registers waku store protocol";
        }
        let storeCodec = "";
        for (const codec of Object.values(StoreCodecs)) {
            if (peer.protocols.includes(codec)) {
                storeCodec = codec;
                // Do not break as we want to keep the last value
            }
        }
        dbg(`Use store codec ${storeCodec}`);
        if (!storeCodec)
            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
        Object.assign(opts, { storeCodec });
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw "Failed to get a connection to the peer";
        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
            return {
                key,
                method,
                contentTopics,
            };
        });
        // Add the decryption keys passed to this function against the
        // content topics also passed to this function.
        if (opts.decryptionKeys) {
            opts.decryptionKeys.forEach((key) => {
                decryptionKeys.push({
                    key: (0, utils_1.hexToBytes)(key),
                    contentTopics: contentTopics.length ? contentTopics : undefined,
                    method: undefined,
                });
            });
        }
        const messages = [];
        let cursor = undefined;
        while (true) {
            const { stream } = await connection.newStream(storeCodec);
            const queryOpts = Object.assign(opts, { cursor });
            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);
            dbg("Querying store peer", connection.remoteAddr.toString());
            const res = await (0, it_pipe_1.pipe)([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            const reply = historyRpcQuery.decode(res.slice());
            const response = reply.response;
            if (!response) {
                throw "History response misses response field";
            }
            if (response.error) {
                throw "History response contains an Error" + response.error;
            }
            if (!response.messages || !response.messages.length) {
                // No messages left (or stored)
                console.log("No messages present in HistoryRPC response");
                return messages;
            }
            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
            const pageMessages = [];
            await Promise.all(response.messages.map(async (protoMsg) => {
                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);
                if (msg) {
                    messages.push(msg);
                    pageMessages.push(msg);
                }
            }));
            let abort = false;
            if (opts.callback) {
                abort = Boolean(opts.callback(pageMessages));
            }
            const responsePageSize = response.pagingInfo?.pageSize;
            const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;
            if (abort ||
                // Response page size smaller than query, meaning this is the last page
                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                return messages;
            }
            cursor = response.pagingInfo?.cursor;
            if (cursor === undefined) {
                // If the server does not return cursor then there is an issue,
                // Need to abort or we end up in an infinite loop
                console.log("No cursor returned by peer.");
                return messages;
            }
        }
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set((0, utils_1.hexToBytes)(key), options ?? {});
    }
    /**cursorV2Beta4
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete((0, utils_1.hexToBytes)(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        const codecs = [];
        for (const codec of Object.values(StoreCodecs)) {
            codecs.push(codec);
        }
        return (0, select_peer_1.getPeersForProtocol)(this.libp2p, codecs);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return (0, select_peer_1.selectRandomPeer)(this.peers);
    }
}
exports.WakuStore = WakuStore;
//# sourceMappingURL=index.js.map