(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jswaku"] = factory();
	else
		root["jswaku"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StoreCodecs = exports.WakuStore = exports.PageDirection = exports.waku_store = exports.RelayCodecs = exports.WakuRelay = exports.waku_relay = exports.PushResponse = exports.LightPushCodec = exports.WakuLightPush = exports.waku_light_push = exports.WakuMessage = exports.waku_message = exports.Protocols = exports.DefaultPubSubTopic = exports.Waku = exports.waku = exports.utils = exports.enr = exports.discovery = exports.getPredefinedBootstrapNodes = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = void 0;
var crypto_1 = __webpack_require__(/*! ./lib/crypto */ "./src/lib/crypto.ts");
Object.defineProperty(exports, "generatePrivateKey", ({ enumerable: true, get: function () { return crypto_1.generatePrivateKey; } }));
Object.defineProperty(exports, "generateSymmetricKey", ({ enumerable: true, get: function () { return crypto_1.generateSymmetricKey; } }));
Object.defineProperty(exports, "getPublicKey", ({ enumerable: true, get: function () { return crypto_1.getPublicKey; } }));
var discovery_1 = __webpack_require__(/*! ./lib/discovery */ "./src/lib/discovery/index.ts");
Object.defineProperty(exports, "getPredefinedBootstrapNodes", ({ enumerable: true, get: function () { return discovery_1.getPredefinedBootstrapNodes; } }));
exports.discovery = __importStar(__webpack_require__(/*! ./lib/discovery */ "./src/lib/discovery/index.ts"));
exports.enr = __importStar(__webpack_require__(/*! ./lib/enr */ "./src/lib/enr/index.ts"));
exports.utils = __importStar(__webpack_require__(/*! ./lib/utils */ "./src/lib/utils.ts"));
exports.waku = __importStar(__webpack_require__(/*! ./lib/waku */ "./src/lib/waku.ts"));
var waku_1 = __webpack_require__(/*! ./lib/waku */ "./src/lib/waku.ts");
Object.defineProperty(exports, "Waku", ({ enumerable: true, get: function () { return waku_1.Waku; } }));
Object.defineProperty(exports, "DefaultPubSubTopic", ({ enumerable: true, get: function () { return waku_1.DefaultPubSubTopic; } }));
Object.defineProperty(exports, "Protocols", ({ enumerable: true, get: function () { return waku_1.Protocols; } }));
exports.waku_message = __importStar(__webpack_require__(/*! ./lib/waku_message */ "./src/lib/waku_message/index.ts"));
var waku_message_1 = __webpack_require__(/*! ./lib/waku_message */ "./src/lib/waku_message/index.ts");
Object.defineProperty(exports, "WakuMessage", ({ enumerable: true, get: function () { return waku_message_1.WakuMessage; } }));
exports.waku_light_push = __importStar(__webpack_require__(/*! ./lib/waku_light_push */ "./src/lib/waku_light_push/index.ts"));
var waku_light_push_1 = __webpack_require__(/*! ./lib/waku_light_push */ "./src/lib/waku_light_push/index.ts");
Object.defineProperty(exports, "WakuLightPush", ({ enumerable: true, get: function () { return waku_light_push_1.WakuLightPush; } }));
Object.defineProperty(exports, "LightPushCodec", ({ enumerable: true, get: function () { return waku_light_push_1.LightPushCodec; } }));
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return waku_light_push_1.PushResponse; } }));
exports.waku_relay = __importStar(__webpack_require__(/*! ./lib/waku_relay */ "./src/lib/waku_relay/index.ts"));
var waku_relay_1 = __webpack_require__(/*! ./lib/waku_relay */ "./src/lib/waku_relay/index.ts");
Object.defineProperty(exports, "WakuRelay", ({ enumerable: true, get: function () { return waku_relay_1.WakuRelay; } }));
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return waku_relay_1.RelayCodecs; } }));
exports.waku_store = __importStar(__webpack_require__(/*! ./lib/waku_store */ "./src/lib/waku_store/index.ts"));
var waku_store_1 = __webpack_require__(/*! ./lib/waku_store */ "./src/lib/waku_store/index.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return waku_store_1.PageDirection; } }));
Object.defineProperty(exports, "WakuStore", ({ enumerable: true, get: function () { return waku_store_1.WakuStore; } }));
Object.defineProperty(exports, "StoreCodecs", ({ enumerable: true, get: function () { return waku_store_1.StoreCodecs; } }));


/***/ }),

/***/ "./src/lib/crypto.ts":
/*!***************************!*\
  !*** ./src/lib/crypto.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifySignature = exports.compressPublicKey = exports.keccak256 = exports.sign = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.sha256 = exports.randomBytes = exports.getSubtle = void 0;
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "?0bda"));
const secp = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/lib/index.js"));
const sha3 = __importStar(__webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js"));
const concat_1 = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/uint8arrays/esm/src/concat.js");
const symmetric = __importStar(__webpack_require__(/*! ./waku_message/symmetric */ "./src/lib/waku_message/symmetric.ts"));
const version_1_1 = __webpack_require__(/*! ./waku_message/version_1 */ "./src/lib/waku_message/version_1.ts");
const crypto = {
    node: crypto_1.default,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined,
};
function getSubtle() {
    if (crypto.web) {
        return crypto.web.subtle;
    }
    else if (crypto.node) {
        return crypto.node.webcrypto.subtle;
    }
    else {
        throw new Error("The environment doesn't have Crypto Subtle API (if in the browser, be sure to use to be in a secure context, ie, https)");
    }
}
exports.getSubtle = getSubtle;
exports.randomBytes = secp.utils.randomBytes;
exports.sha256 = secp.utils.sha256;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
function generatePrivateKey() {
    return (0, exports.randomBytes)(version_1_1.PrivateKeySize);
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
function generateSymmetricKey() {
    return (0, exports.randomBytes)(symmetric.KeySize);
}
exports.generateSymmetricKey = generateSymmetricKey;
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
exports.getPublicKey = secp.getPublicKey;
/**
 * ECDSA Sign a message with the given private key.
 *
 *  @param message The message to sign, usually a hash.
 *  @param privateKey The ECDSA private key to use to sign the message.
 *
 *  @returns The signature and the recovery id concatenated.
 */
async function sign(message, privateKey) {
    const [signature, recoveryId] = await secp.sign(message, privateKey, {
        recovered: true,
        der: false,
    });
    return (0, concat_1.concat)([signature, [recoveryId]], signature.length + 1);
}
exports.sign = sign;
function keccak256(input) {
    return new Uint8Array(sha3.keccak256.arrayBuffer(input));
}
exports.keccak256 = keccak256;
function compressPublicKey(publicKey) {
    if (publicKey.length === 64) {
        publicKey = (0, concat_1.concat)([[4], publicKey], 65);
    }
    const point = secp.Point.fromHex(publicKey);
    return point.toRawBytes(true);
}
exports.compressPublicKey = compressPublicKey;
/**
 * Verify an ECDSA signature.
 */
function verifySignature(signature, message, publicKey) {
    try {
        const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
        return secp.verify(_signature, message, publicKey);
    }
    catch {
        return false;
    }
}
exports.verifySignature = verifySignature;


/***/ }),

/***/ "./src/lib/discovery/bootstrap.ts":
/*!****************************************!*\
  !*** ./src/lib/discovery/bootstrap.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bootstrap = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const dns_1 = __webpack_require__(/*! ./dns */ "./src/lib/discovery/dns.ts");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/discovery/index.ts");
const dbg = (0, debug_1.default)("waku:discovery:bootstrap");
/**
 * Parse options and expose function to return bootstrap peer addresses.
 *
 * @throws if an invalid combination of options is passed, see [[BootstrapOptions]] for details.
 */
class Bootstrap {
    constructor(opts) {
        const maxPeers = opts.maxPeers ?? Bootstrap.DefaultMaxPeers;
        if (opts.default) {
            dbg("Use hosted list of peers.");
            this.getBootstrapPeers = () => {
                return Promise.resolve((0, index_1.getPredefinedBootstrapNodes)(undefined, maxPeers));
            };
        }
        else if (opts.peers !== undefined && opts.peers.length > 0) {
            const allPeers = opts.peers.map((node) => {
                if (typeof node === "string") {
                    return new multiaddr_1.Multiaddr(node);
                }
                else {
                    return node;
                }
            });
            const peers = (0, index_1.getPseudoRandomSubset)(allPeers, maxPeers);
            dbg("Use provided list of peers (reduced to maxPeers)", allPeers.map((ma) => ma.toString()));
            this.getBootstrapPeers = () => Promise.resolve(peers);
        }
        else if (typeof opts.getPeers === "function") {
            dbg("Bootstrap: Use provided getPeers function.");
            const getPeers = opts.getPeers;
            this.getBootstrapPeers = async () => {
                const allPeers = await getPeers();
                return (0, index_1.getPseudoRandomSubset)(allPeers, maxPeers).map((node) => new multiaddr_1.Multiaddr(node));
            };
        }
        else if (opts.enrUrl) {
            const wantedNodeCapabilityCount = opts.wantedNodeCapabilityCount;
            if (!wantedNodeCapabilityCount)
                throw "`wantedNodeCapabilityCount` must be defined when using `enrUrl`";
            const enrUrl = opts.enrUrl;
            dbg("Use provided EIP-1459 ENR Tree URL.");
            const dns = dns_1.DnsNodeDiscovery.dnsOverHttp();
            this.getBootstrapPeers = async () => {
                const enrs = await dns.getPeers([enrUrl], wantedNodeCapabilityCount);
                dbg(`Found ${enrs.length} peers`);
                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();
            };
        }
        else {
            dbg("No bootstrap method specified, no peer will be returned");
            this.getBootstrapPeers = undefined;
        }
    }
}
exports.Bootstrap = Bootstrap;
Bootstrap.DefaultMaxPeers = 1;


/***/ }),

/***/ "./src/lib/discovery/dns.ts":
/*!**********************************!*\
  !*** ./src/lib/discovery/dns.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnsNodeDiscovery = void 0;
const debug_1 = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
const enr_1 = __webpack_require__(/*! ../enr */ "./src/lib/enr/index.ts");
const dns_over_https_1 = __webpack_require__(/*! ./dns_over_https */ "./src/lib/discovery/dns_over_https.ts");
const enrtree_1 = __webpack_require__(/*! ./enrtree */ "./src/lib/discovery/enrtree.ts");
const fetch_nodes_1 = __importDefault(__webpack_require__(/*! ./fetch_nodes */ "./src/lib/discovery/fetch_nodes.ts"));
const dbg = (0, debug_1.debug)("waku:discovery:dns");
class DnsNodeDiscovery {
    constructor(dns) {
        this._errorTolerance = 10;
        this._DNSTreeCache = {};
        this.dns = dns;
    }
    static dnsOverHttp(endpoints) {
        const dnsClient = new dns_over_https_1.DnsOverHttps(endpoints);
        return new DnsNodeDiscovery(dnsClient);
    }
    /**
     * Returns a list of verified peers listed in an EIP-1459 DNS tree. Method may
     * return fewer peers than requested if [[wantedNodeCapabilityCount]] requires
     * larger quantity of peers than available or the number of errors/duplicate
     * peers encountered by randomized search exceeds the sum of the fields of
     * [[wantedNodeCapabilityCount]] plus the [[_errorTolerance]] factor.
     */
    async getPeers(enrTreeUrls, wantedNodeCapabilityCount) {
        const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
        const { publicKey, domain } = enrtree_1.ENRTree.parseTree(enrTreeUrls[networkIndex]);
        const context = {
            domain,
            publicKey,
            visits: {},
        };
        const peers = await (0, fetch_nodes_1.default)(wantedNodeCapabilityCount, this._errorTolerance, () => this._search(domain, context));
        dbg("retrieved peers: ", peers);
        return peers;
    }
    /**
     * Runs a recursive, randomized descent of the DNS tree to retrieve a single
     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
     */
    async _search(subdomain, context) {
        try {
            const entry = await this._getTXTRecord(subdomain, context);
            context.visits[subdomain] = true;
            let next;
            let branches;
            const entryType = getEntryType(entry);
            try {
                switch (entryType) {
                    case enrtree_1.ENRTree.ROOT_PREFIX:
                        next = enrtree_1.ENRTree.parseAndVerifyRoot(entry, context.publicKey);
                        return await this._search(next, context);
                    case enrtree_1.ENRTree.BRANCH_PREFIX:
                        branches = enrtree_1.ENRTree.parseBranch(entry);
                        next = selectRandomPath(branches, context);
                        return await this._search(next, context);
                    case enrtree_1.ENRTree.RECORD_PREFIX:
                        return enr_1.ENR.decodeTxt(entry);
                    default:
                        return null;
                }
            }
            catch (error) {
                dbg(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
                return null;
            }
        }
        catch (error) {
            dbg(`Failed to retrieve TXT record at subdomain ${subdomain}: ${error}`);
            return null;
        }
    }
    /**
     * Retrieves the TXT record stored at a location from either
     * this DNS tree cache or via DNS query.
     *
     * @throws if the TXT Record contains non-UTF-8 values.
     */
    async _getTXTRecord(subdomain, context) {
        if (this._DNSTreeCache[subdomain]) {
            return this._DNSTreeCache[subdomain];
        }
        // Location is either the top level tree entry host or a subdomain of it.
        const location = subdomain !== context.domain
            ? `${subdomain}.${context.domain}`
            : context.domain;
        const response = await this.dns.resolveTXT(location);
        if (!response.length)
            throw new Error("Received empty result array while fetching TXT record");
        if (!response[0].length)
            throw new Error("Received empty TXT record");
        // Branch entries can be an array of strings of comma delimited subdomains, with
        // some subdomain strings split across the array elements
        const result = response.join("");
        this._DNSTreeCache[subdomain] = result;
        return result;
    }
}
exports.DnsNodeDiscovery = DnsNodeDiscovery;
function getEntryType(entry) {
    if (entry.startsWith(enrtree_1.ENRTree.ROOT_PREFIX))
        return enrtree_1.ENRTree.ROOT_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.BRANCH_PREFIX))
        return enrtree_1.ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.RECORD_PREFIX))
        return enrtree_1.ENRTree.RECORD_PREFIX;
    return "";
}
/**
 * Returns a randomly selected subdomain string from the list provided by a branch
 * entry record.
 *
 * The client must track subdomains which are already resolved to avoid
 * going into an infinite loop b/c branch entries can contain
 * circular references. It’s in the client’s best interest to traverse the
 * tree in random order.
 */
function selectRandomPath(branches, context) {
    // Identify domains already visited in this traversal of the DNS tree.
    // Then filter against them to prevent cycles.
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
        if (context.visits[subdomain]) {
            circularRefs[idx] = true;
        }
    }
    // If all possible paths are circular...
    if (Object.keys(circularRefs).length === branches.length) {
        throw new Error("Unresolvable circular path detected");
    }
    // Randomly select a viable path
    let index;
    do {
        index = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index]);
    return branches[index];
}


/***/ }),

/***/ "./src/lib/discovery/dns_over_https.ts":
/*!*********************************************!*\
  !*** ./src/lib/discovery/dns_over_https.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnsOverHttps = void 0;
const dns_query_1 = __webpack_require__(/*! dns-query */ "./node_modules/dns-query/index.js");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const { cloudflare, google, opendns } = dns_query_1.endpoints;
class DnsOverHttps {
    /**
     * Create new Dns-Over-Http DNS client.
     *
     * @param endpoints The endpoints for Dns-Over-Https queries.
     * See [dns-query](https://www.npmjs.com/package/dns-query) for details.
     * Defaults to cloudflare, google and opendns.
     *
     * @throws {code: string} If DNS query fails.
     */
    constructor(endpoints = [cloudflare, google, opendns]) {
        this.endpoints = endpoints;
    }
    /**
     * Resolves a TXT record
     *
     * @param domain The domain name
     *
     * @throws if the result is provided in byte form which cannot be decoded
     * to UTF-8
     */
    async resolveTXT(domain) {
        const response = await (0, dns_query_1.query)({
            questions: [{ type: "TXT", name: domain }],
        });
        const answers = response.answers;
        const data = answers.map((a) => a.data);
        const result = [];
        data.forEach((d) => {
            if (typeof d === "string") {
                result.push(d);
            }
            else if (Array.isArray(d)) {
                d.forEach((sd) => {
                    if (typeof sd === "string") {
                        result.push(sd);
                    }
                    else {
                        result.push((0, utils_1.bytesToUtf8)(sd));
                    }
                });
            }
            else {
                result.push((0, utils_1.bytesToUtf8)(d));
            }
        });
        return result;
    }
}
exports.DnsOverHttps = DnsOverHttps;


/***/ }),

/***/ "./src/lib/discovery/enrtree.ts":
/*!**************************************!*\
  !*** ./src/lib/discovery/enrtree.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENRTree = void 0;
const base32 = __importStar(__webpack_require__(/*! hi-base32 */ "./node_modules/hi-base32/src/base32.js"));
const from_string_1 = __webpack_require__(/*! uint8arrays/from-string */ "./node_modules/uint8arrays/esm/src/from-string.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
const enr_1 = __webpack_require__(/*! ../enr */ "./src/lib/enr/index.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
class ENRTree {
    /**
     * Extracts the branch subdomain referenced by a DNS tree root string after verifying
     * the root record signature with its base32 compressed public key.
     */
    static parseAndVerifyRoot(root, publicKey) {
        if (!root.startsWith(this.ROOT_PREFIX))
            throw new Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
        const rootValues = ENRTree.parseRootValues(root);
        const decodedPublicKey = base32.decode.asBytes(publicKey);
        // The signature is a 65-byte secp256k1 over the keccak256 hash
        // of the record content, excluding the `sig=` part, encoded as URL-safe base64 string
        // (Trailing recovery bit must be trimmed to pass `ecdsaVerify` method)
        const signedComponent = root.split(" sig")[0];
        const signedComponentBuffer = (0, utils_1.utf8ToBytes)(signedComponent);
        const signatureBuffer = (0, from_string_1.fromString)(rootValues.signature, "base64url").slice(0, 64);
        const isVerified = (0, crypto_1.verifySignature)(signatureBuffer, (0, crypto_1.keccak256)(signedComponentBuffer), new Uint8Array(decodedPublicKey));
        if (!isVerified)
            throw new Error("Unable to verify ENRTree root signature");
        return rootValues.eRoot;
    }
    static parseRootValues(txt) {
        const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
        if (!Array.isArray(matches))
            throw new Error("Could not parse ENRTree root entry");
        matches.shift(); // The first entry is the full match
        const [eRoot, lRoot, seq, signature] = matches;
        if (!eRoot)
            throw new Error("Could not parse 'e' value from ENRTree root entry");
        if (!lRoot)
            throw new Error("Could not parse 'l' value from ENRTree root entry");
        if (!seq)
            throw new Error("Could not parse 'seq' value from ENRTree root entry");
        if (!signature)
            throw new Error("Could not parse 'sig' value from ENRTree root entry");
        return { eRoot, lRoot, seq: Number(seq), signature };
    }
    /**
     * Returns the public key and top level domain of an ENR tree entry.
     * The domain is the starting point for traversing a set of linked DNS TXT records
     * and the public key is used to verify the root entry record
     */
    static parseTree(tree) {
        if (!tree.startsWith(this.TREE_PREFIX))
            throw new Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
        const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
        if (!Array.isArray(matches))
            throw new Error("Could not parse ENRTree tree entry");
        matches.shift(); // The first entry is the full match
        const [publicKey, domain] = matches;
        if (!publicKey)
            throw new Error("Could not parse public key from ENRTree tree entry");
        if (!domain)
            throw new Error("Could not parse domain from ENRTree tree entry");
        return { publicKey, domain };
    }
    /**
     * Returns subdomains listed in an ENR branch entry. These in turn lead to
     * either further branch entries or ENR records.
     */
    static parseBranch(branch) {
        if (!branch.startsWith(this.BRANCH_PREFIX))
            throw new Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
        return branch.split(this.BRANCH_PREFIX)[1].split(",");
    }
}
exports.ENRTree = ENRTree;
ENRTree.RECORD_PREFIX = enr_1.ENR.RECORD_PREFIX;
ENRTree.TREE_PREFIX = "enrtree:";
ENRTree.BRANCH_PREFIX = "enrtree-branch:";
ENRTree.ROOT_PREFIX = "enrtree-root:";


/***/ }),

/***/ "./src/lib/discovery/fetch_nodes.ts":
/*!******************************************!*\
  !*** ./src/lib/discovery/fetch_nodes.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
const dbg = (0, debug_1.debug)("waku:discovery:fetch_nodes");
/**
 * Fetch nodes using passed [[getNode]] until all wanted capabilities are
 * fulfilled or the number of [[getNode]] call exceeds the sum of
 * [[wantedNodeCapabilityCount]] plus [[errorTolerance]].
 */
async function fetchNodesUntilCapabilitiesFulfilled(wantedNodeCapabilityCount, errorTolerance, getNode) {
    const wanted = {
        relay: wantedNodeCapabilityCount.relay ?? 0,
        store: wantedNodeCapabilityCount.store ?? 0,
        filter: wantedNodeCapabilityCount.filter ?? 0,
        lightPush: wantedNodeCapabilityCount.lightPush ?? 0,
    };
    const maxSearches = wanted.relay + wanted.store + wanted.filter + wanted.lightPush;
    const actual = {
        relay: 0,
        store: 0,
        filter: 0,
        lightPush: 0,
    };
    let totalSearches = 0;
    const peers = [];
    while (!isSatisfied(wanted, actual) &&
        totalSearches < maxSearches + errorTolerance) {
        const peer = await getNode();
        if (peer && isNewPeer(peer, peers)) {
            // ENRs without a waku2 key are ignored.
            if (peer.waku2) {
                if (helpsSatisfyCapabilities(peer.waku2, wanted, actual)) {
                    addCapabilities(peer.waku2, actual);
                    peers.push(peer);
                }
            }
            dbg(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
        }
        totalSearches++;
    }
    return peers;
}
exports["default"] = fetchNodesUntilCapabilitiesFulfilled;
function isSatisfied(wanted, actual) {
    return (actual.relay >= wanted.relay &&
        actual.store >= wanted.store &&
        actual.filter >= wanted.filter &&
        actual.lightPush >= wanted.lightPush);
}
function isNewPeer(peer, peers) {
    if (!peer.nodeId)
        return false;
    for (const existingPeer of peers) {
        if (peer.nodeId === existingPeer.nodeId) {
            return false;
        }
    }
    return true;
}
function addCapabilities(node, total) {
    if (node.relay)
        total.relay += 1;
    if (node.store)
        total.store += 1;
    if (node.filter)
        total.filter += 1;
    if (node.lightPush)
        total.lightPush += 1;
}
/**
 * Checks if the proposed ENR [[node]] helps satisfy the [[wanted]] capabilities,
 * considering the [[actual]] capabilities of nodes retrieved so far..
 *
 * @throws If the function is called when the wanted capabilities are already fulfilled.
 */
function helpsSatisfyCapabilities(node, wanted, actual) {
    if (isSatisfied(wanted, actual)) {
        throw "Internal Error: Waku2 wanted capabilities are already fulfilled";
    }
    const missing = missingCapabilities(wanted, actual);
    return ((missing.relay && node.relay) ||
        (missing.store && node.store) ||
        (missing.filter && node.filter) ||
        (missing.lightPush && node.lightPush));
}
/**
 * Return a [[Waku2]] Object for which capabilities are set to true if they are
 * [[wanted]] yet missing from [[actual]].
 */
function missingCapabilities(wanted, actual) {
    return {
        relay: actual.relay < wanted.relay,
        store: actual.store < wanted.store,
        filter: actual.filter < wanted.filter,
        lightPush: actual.lightPush < wanted.lightPush,
    };
}


/***/ }),

/***/ "./src/lib/discovery/index.ts":
/*!************************************!*\
  !*** ./src/lib/discovery/index.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPseudoRandomSubset = exports.ENRTree = exports.DnsOverHttps = exports.dns = exports.Bootstrap = exports.predefined = exports.getPredefinedBootstrapNodes = void 0;
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
var predefined_1 = __webpack_require__(/*! ./predefined */ "./src/lib/discovery/predefined.ts");
Object.defineProperty(exports, "getPredefinedBootstrapNodes", ({ enumerable: true, get: function () { return predefined_1.getPredefinedBootstrapNodes; } }));
exports.predefined = __importStar(__webpack_require__(/*! ./predefined */ "./src/lib/discovery/predefined.ts"));
var bootstrap_1 = __webpack_require__(/*! ./bootstrap */ "./src/lib/discovery/bootstrap.ts");
Object.defineProperty(exports, "Bootstrap", ({ enumerable: true, get: function () { return bootstrap_1.Bootstrap; } }));
exports.dns = __importStar(__webpack_require__(/*! ./dns */ "./src/lib/discovery/dns.ts"));
var dns_over_https_1 = __webpack_require__(/*! ./dns_over_https */ "./src/lib/discovery/dns_over_https.ts");
Object.defineProperty(exports, "DnsOverHttps", ({ enumerable: true, get: function () { return dns_over_https_1.DnsOverHttps; } }));
var enrtree_1 = __webpack_require__(/*! ./enrtree */ "./src/lib/discovery/enrtree.ts");
Object.defineProperty(exports, "ENRTree", ({ enumerable: true, get: function () { return enrtree_1.ENRTree; } }));
function getPseudoRandomSubset(values, wantedNumber) {
    if (values.length <= wantedNumber) {
        return values;
    }
    return (0, utils_1.shuffle)(values).slice(0, wantedNumber);
}
exports.getPseudoRandomSubset = getPseudoRandomSubset;


/***/ }),

/***/ "./src/lib/discovery/predefined.ts":
/*!*****************************************!*\
  !*** ./src/lib/discovery/predefined.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fleets = exports.getPredefinedBootstrapNodes = exports.Fleet = exports.DefaultWantedNumber = void 0;
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/discovery/index.ts");
exports.DefaultWantedNumber = 1;
var Fleet;
(function (Fleet) {
    Fleet["Prod"] = "prod";
    Fleet["Test"] = "test";
})(Fleet = exports.Fleet || (exports.Fleet = {}));
/**
 * Return list of pre-defined (hardcoded) bootstrap nodes.
 *
 * Default behavior is to return nodes of the nwaku Status Prod fleet.
 *
 * @param fleet The fleet to be returned. Defaults to production fleet.
 * @param wantedNumber The number of connections desired. Defaults to [[DefaultWantedNumber]].
 *
 * @returns An array of multiaddresses.
 */
function getPredefinedBootstrapNodes(fleet = Fleet.Prod, wantedNumber = exports.DefaultWantedNumber) {
    if (wantedNumber <= 0) {
        return [];
    }
    let nodes;
    switch (fleet) {
        case Fleet.Prod:
            nodes = exports.fleets.fleets["wakuv2.prod"]["waku-websocket"];
            break;
        case Fleet.Test:
            nodes = exports.fleets.fleets["wakuv2.test"]["waku-websocket"];
            break;
        default:
            nodes = exports.fleets.fleets["wakuv2.prod"]["waku-websocket"];
    }
    nodes = Object.values(nodes);
    nodes = nodes.map((node) => new multiaddr_1.Multiaddr(node));
    return (0, index_1.getPseudoRandomSubset)(nodes, wantedNumber);
}
exports.getPredefinedBootstrapNodes = getPredefinedBootstrapNodes;
exports.fleets = {
    fleets: {
        "wakuv2.prod": {
            "waku-websocket": {
                "node-01.ac-cn-hongkong-c.wakuv2.prod": "/dns4/node-01.ac-cn-hongkong-c.wakuv2.prod.statusim.net/tcp/443/wss/p2p/16Uiu2HAm4v86W3bmT1BiH6oSPzcsSr24iDQpSN5Qa992BCjjwgrD",
                "node-01.do-ams3.wakuv2.prod": "/dns4/node-01.do-ams3.wakuv2.prod.statusim.net/tcp/443/wss/p2p/16Uiu2HAmL5okWopX7NqZWBUKVqW8iUxCEmd5GMHLVPwCgzYzQv3e",
                "node-01.gc-us-central1-a.wakuv2.prod": "/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/443/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA",
            },
        },
        "wakuv2.test": {
            "waku-websocket": {
                "node-01.ac-cn-hongkong-c.wakuv2.test": "/dns4/node-01.ac-cn-hongkong-c.wakuv2.test.statusim.net/tcp/443/wss/p2p/16Uiu2HAkvWiyFsgRhuJEb9JfjYxEkoHLgnUQmr1N5mKWnYjxYRVm",
                "node-01.do-ams3.wakuv2.test": "/dns4/node-01.do-ams3.wakuv2.test.statusim.net/tcp/443/wss/p2p/16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ",
                "node-01.gc-us-central1-a.wakuv2.test": "/dns4/node-01.gc-us-central1-a.wakuv2.test.statusim.net/tcp/443/wss/p2p/16Uiu2HAmJb2e28qLXxT5kZxVUUoJt72EMzNGXB47Rxx5hw3q4YjS",
            },
        },
    },
};


/***/ }),

/***/ "./src/lib/enr/constants.ts":
/*!**********************************!*\
  !*** ./src/lib/enr/constants.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MULTIADDR_LENGTH_SIZE = exports.ERR_NO_SIGNATURE = exports.ERR_INVALID_ID = exports.MAX_RECORD_SIZE = void 0;
// Maximum encoded size of an ENR
exports.MAX_RECORD_SIZE = 300;
exports.ERR_INVALID_ID = "Invalid record id";
exports.ERR_NO_SIGNATURE = "No valid signature found";
// The maximum length of byte size of a multiaddr to encode in the `multiaddr` field
// The size is a big endian 16-bit unsigned integer
exports.MULTIADDR_LENGTH_SIZE = 2;


/***/ }),

/***/ "./src/lib/enr/enr.ts":
/*!****************************!*\
  !*** ./src/lib/enr/enr.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENR = void 0;
const RLP = __importStar(__webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const convert_1 = __importDefault(__webpack_require__(/*! multiaddr/src/convert */ "./node_modules/multiaddr/src/convert.js"));
const from_string_1 = __webpack_require__(/*! uint8arrays/from-string */ "./node_modules/uint8arrays/esm/src/from-string.js");
const to_string_1 = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/uint8arrays/esm/src/to-string.js");
const varint_1 = __webpack_require__(/*! varint */ "./node_modules/varint/index.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/enr/constants.ts");
const keypair_1 = __webpack_require__(/*! ./keypair */ "./src/lib/enr/keypair/index.ts");
const multiaddrs_codec_1 = __webpack_require__(/*! ./multiaddrs_codec */ "./src/lib/enr/multiaddrs_codec.ts");
const v4 = __importStar(__webpack_require__(/*! ./v4 */ "./src/lib/enr/v4.ts"));
const waku2_codec_1 = __webpack_require__(/*! ./waku2_codec */ "./src/lib/enr/waku2_codec.ts");
const dbg = (0, debug_1.default)("waku:enr");
class ENR extends Map {
    constructor(kvs = {}, seq = BigInt(1), signature = null) {
        super(Object.entries(kvs));
        this.seq = seq;
        this.signature = signature;
    }
    static async create(kvs = {}, seq = BigInt(1), signature = null) {
        const enr = new ENR(kvs, seq, signature);
        try {
            const publicKey = enr.publicKey;
            if (publicKey) {
                const keypair = (0, keypair_1.createKeypair)(enr.keypairType, undefined, publicKey);
                enr.peerId = await (0, keypair_1.createPeerIdFromKeypair)(keypair);
            }
        }
        catch (e) {
            dbg("Could not calculate peer id for ENR", e);
        }
        return enr;
    }
    static createV4(publicKey, kvs = {}) {
        // EIP-778 specifies that the key must be in compressed format, 33 bytes
        if (publicKey.length !== 33) {
            publicKey = (0, crypto_1.compressPublicKey)(publicKey);
        }
        return ENR.create({
            ...kvs,
            id: (0, utils_1.utf8ToBytes)("v4"),
            secp256k1: publicKey,
        });
    }
    static createFromPeerId(peerId, kvs = {}) {
        const keypair = (0, keypair_1.createKeypairFromPeerId)(peerId);
        switch (keypair.type) {
            case keypair_1.KeypairType.secp256k1:
                return ENR.createV4(keypair.publicKey, kvs);
            default:
                throw new Error();
        }
    }
    static async decodeFromValues(decoded) {
        if (!Array.isArray(decoded)) {
            throw new Error("Decoded ENR must be an array");
        }
        if (decoded.length % 2 !== 0) {
            throw new Error("Decoded ENR must have an even number of elements");
        }
        const [signature, seq, ...kvs] = decoded;
        if (!signature || Array.isArray(signature)) {
            throw new Error("Decoded ENR invalid signature: must be a byte array");
        }
        if (!seq || Array.isArray(seq)) {
            throw new Error("Decoded ENR invalid sequence number: must be a byte array");
        }
        const obj = {};
        for (let i = 0; i < kvs.length; i += 2) {
            try {
                obj[(0, utils_1.bytesToUtf8)(kvs[i])] = kvs[i + 1];
            }
            catch (e) {
                dbg("Failed to decode ENR key to UTF-8, skipping it", kvs[i], e);
            }
        }
        // If seq is an empty array, translate as value 0
        const hexSeq = "0x" + (seq.length ? (0, utils_1.bytesToHex)(seq) : "00");
        const enr = await ENR.create(obj, BigInt(hexSeq), signature);
        const rlpEncodedBytes = (0, utils_1.hexToBytes)(RLP.encode([seq, ...kvs]));
        if (!enr.verify(rlpEncodedBytes, signature)) {
            throw new Error("Unable to verify ENR signature");
        }
        return enr;
    }
    static decode(encoded) {
        const decoded = RLP.decode(encoded).map(utils_1.hexToBytes);
        return ENR.decodeFromValues(decoded);
    }
    static decodeTxt(encoded) {
        if (!encoded.startsWith(this.RECORD_PREFIX)) {
            throw new Error(`"string encoded ENR must start with '${this.RECORD_PREFIX}'`);
        }
        return ENR.decode((0, from_string_1.fromString)(encoded.slice(4), "base64url"));
    }
    set(k, v) {
        this.signature = null;
        this.seq++;
        return super.set(k, v);
    }
    get id() {
        const id = this.get("id");
        if (!id)
            throw new Error("id not found.");
        return (0, utils_1.bytesToUtf8)(id);
    }
    get keypairType() {
        switch (this.id) {
            case "v4":
                return keypair_1.KeypairType.secp256k1;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get publicKey() {
        switch (this.id) {
            case "v4":
                return this.get("secp256k1");
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get keypair() {
        if (this.publicKey) {
            const publicKey = this.publicKey;
            return (0, keypair_1.createKeypair)(this.keypairType, undefined, publicKey);
        }
        return;
    }
    get nodeId() {
        switch (this.id) {
            case "v4":
                return this.publicKey ? v4.nodeId(this.publicKey) : undefined;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get ip() {
        const raw = this.get("ip");
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip4.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip(ip) {
        if (ip) {
            this.set("ip", convert_1.default.toBytes(multiaddr_1.protocols.names.ip4.code, ip));
        }
        else {
            this.delete("ip");
        }
    }
    get tcp() {
        const raw = this.get("tcp");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp(port) {
        if (port === undefined) {
            this.delete("tcp");
        }
        else {
            this.set("tcp", convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp() {
        const raw = this.get("udp");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp(port) {
        if (port === undefined) {
            this.delete("udp");
        }
        else {
            this.set("udp", convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    get ip6() {
        const raw = this.get("ip6");
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip6.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip6(ip) {
        if (ip) {
            this.set("ip6", convert_1.default.toBytes(multiaddr_1.protocols.names.ip6.code, ip));
        }
        else {
            this.delete("ip6");
        }
    }
    get tcp6() {
        const raw = this.get("tcp6");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp6(port) {
        if (port === undefined) {
            this.delete("tcp6");
        }
        else {
            this.set("tcp6", convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp6() {
        const raw = this.get("udp6");
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp6(port) {
        if (port === undefined) {
            this.delete("udp6");
        }
        else {
            this.set("udp6", convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    /**
     * Get the `multiaddrs` field from ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[getLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
     */
    get multiaddrs() {
        const raw = this.get("multiaddrs");
        if (raw)
            return (0, multiaddrs_codec_1.decodeMultiaddrs)(raw);
        return;
    }
    /**
     * Set the `multiaddrs` field on the ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[setLocationMultiaddr]] should be preferred.
     * The multiaddresses stored in this field must be location multiaddresses,
     * ie, without a peer id.
     */
    set multiaddrs(multiaddrs) {
        if (multiaddrs === undefined) {
            this.delete("multiaddrs");
        }
        else {
            const multiaddrsBuf = (0, multiaddrs_codec_1.encodeMultiaddrs)(multiaddrs);
            this.set("multiaddrs", multiaddrsBuf);
        }
    }
    getLocationMultiaddr(protocol) {
        if (protocol === "udp") {
            return (this.getLocationMultiaddr("udp4") || this.getLocationMultiaddr("udp6"));
        }
        if (protocol === "tcp") {
            return (this.getLocationMultiaddr("tcp4") || this.getLocationMultiaddr("tcp6"));
        }
        const isIpv6 = protocol.endsWith("6");
        const ipVal = this.get(isIpv6 ? "ip6" : "ip");
        if (!ipVal) {
            return undefined;
        }
        const isUdp = protocol.startsWith("udp");
        const isTcp = protocol.startsWith("tcp");
        let protoName, protoVal;
        if (isUdp) {
            protoName = "udp";
            protoVal = isIpv6 ? this.get("udp6") : this.get("udp");
        }
        else if (isTcp) {
            protoName = "tcp";
            protoVal = isIpv6 ? this.get("tcp6") : this.get("tcp");
        }
        else {
            return undefined;
        }
        if (!protoVal) {
            return undefined;
        }
        // Create raw multiaddr buffer
        // multiaddr length is:
        //  1 byte for the ip protocol (ip4 or ip6)
        //  N bytes for the ip address
        //  1 or 2 bytes for the protocol as buffer (tcp or udp)
        //  2 bytes for the port
        const ipMa = multiaddr_1.protocols.names[isIpv6 ? "ip6" : "ip4"];
        const ipByteLen = ipMa.size / 8;
        const protoMa = multiaddr_1.protocols.names[protoName];
        const protoBuf = (0, varint_1.encode)(protoMa.code);
        const maBuf = new Uint8Array(3 + ipByteLen + protoBuf.length);
        maBuf[0] = ipMa.code;
        maBuf.set(ipVal, 1);
        maBuf.set(protoBuf, 1 + ipByteLen);
        maBuf.set(protoVal, 1 + ipByteLen + protoBuf.length);
        return new multiaddr_1.Multiaddr(maBuf);
    }
    setLocationMultiaddr(multiaddr) {
        const protoNames = multiaddr.protoNames();
        if (protoNames.length !== 2 &&
            protoNames[1] !== "udp" &&
            protoNames[1] !== "tcp") {
            throw new Error("Invalid multiaddr");
        }
        const tuples = multiaddr.tuples();
        if (!tuples[0][1] || !tuples[1][1]) {
            throw new Error("Invalid multiaddr");
        }
        // IPv4
        if (tuples[0][0] === 4) {
            this.set("ip", tuples[0][1]);
            this.set(protoNames[1], tuples[1][1]);
        }
        else {
            this.set("ip6", tuples[0][1]);
            this.set(protoNames[1] + "6", tuples[1][1]);
        }
    }
    /**
     * Returns the full multiaddr from the ENR fields matching the provided
     * `protocol` parameter.
     * To return full multiaddrs from the `multiaddrs` ENR field,
     * use [[ENR.getFullMultiaddrs]]
     *
     * @param protocol
     */
    getFullMultiaddr(protocol) {
        if (this.peerId) {
            const locationMultiaddr = this.getLocationMultiaddr(protocol);
            if (locationMultiaddr) {
                return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toB58String()}`);
            }
        }
        return;
    }
    /**
     * Returns the full multiaddrs from the `multiaddrs` ENR field.
     */
    getFullMultiaddrs() {
        if (this.peerId && this.multiaddrs) {
            const peerId = this.peerId;
            return this.multiaddrs.map((ma) => {
                return ma.encapsulate(`/p2p/${peerId.toB58String()}`);
            });
        }
        return [];
    }
    /**
     * Get the `waku2` field from ENR.
     */
    get waku2() {
        const raw = this.get("waku2");
        if (raw)
            return (0, waku2_codec_1.decodeWaku2)(raw[0]);
        return;
    }
    /**
     * Set the `waku2` field on the ENR.
     */
    set waku2(waku2) {
        if (waku2 === undefined) {
            this.delete("waku2");
        }
        else {
            const byte = (0, waku2_codec_1.encodeWaku2)(waku2);
            this.set("waku2", new Uint8Array([byte]));
        }
    }
    verify(data, signature) {
        if (!this.get("id") || this.id !== "v4") {
            throw new Error(constants_1.ERR_INVALID_ID);
        }
        if (!this.publicKey) {
            throw new Error("Failed to verify ENR: No public key");
        }
        return (0, crypto_1.verifySignature)(signature, (0, crypto_1.keccak256)(data), this.publicKey);
    }
    async sign(data, privateKey) {
        switch (this.id) {
            case "v4":
                this.signature = await v4.sign(privateKey, data);
                break;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
        return this.signature;
    }
    async encodeToValues(privateKey) {
        // sort keys and flatten into [k, v, k, v, ...]
        const content = Array.from(this.keys())
            .sort((a, b) => a.localeCompare(b))
            .map((k) => [k, this.get(k)])
            .map(([k, v]) => [(0, utils_1.utf8ToBytes)(k), v])
            .flat();
        content.unshift(new Uint8Array([Number(this.seq)]));
        if (privateKey) {
            content.unshift(await this.sign((0, utils_1.hexToBytes)(RLP.encode(content)), privateKey));
        }
        else {
            if (!this.signature) {
                throw new Error(constants_1.ERR_NO_SIGNATURE);
            }
            content.unshift(this.signature);
        }
        return content;
    }
    async encode(privateKey) {
        const encoded = (0, utils_1.hexToBytes)(RLP.encode(await this.encodeToValues(privateKey)));
        if (encoded.length >= constants_1.MAX_RECORD_SIZE) {
            throw new Error("ENR must be less than 300 bytes");
        }
        return encoded;
    }
    async encodeTxt(privateKey) {
        return (ENR.RECORD_PREFIX + (0, to_string_1.toString)(await this.encode(privateKey), "base64url"));
    }
}
exports.ENR = ENR;
ENR.RECORD_PREFIX = "enr:";


/***/ }),

/***/ "./src/lib/enr/index.ts":
/*!******************************!*\
  !*** ./src/lib/enr/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.v4 = void 0;
const v4Crypto = __importStar(__webpack_require__(/*! ./v4 */ "./src/lib/enr/v4.ts"));
exports.v4 = v4Crypto;
__exportStar(__webpack_require__(/*! ./constants */ "./src/lib/enr/constants.ts"), exports);
__exportStar(__webpack_require__(/*! ./enr */ "./src/lib/enr/enr.ts"), exports);
__exportStar(__webpack_require__(/*! ./types */ "./src/lib/enr/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./keypair */ "./src/lib/enr/keypair/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./waku2_codec */ "./src/lib/enr/waku2_codec.ts"), exports);


/***/ }),

/***/ "./src/lib/enr/keypair/index.ts":
/*!**************************************!*\
  !*** ./src/lib/enr/keypair/index.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createKeypairFromPeerId = exports.createPeerIdFromKeypair = exports.createKeypair = exports.generateKeypair = exports.ERR_TYPE_NOT_IMPLEMENTED = void 0;
const libp2p_crypto_1 = __webpack_require__(/*! libp2p-crypto */ "./node_modules/libp2p-crypto/src/index.js");
const identity_1 = __webpack_require__(/*! multiformats/hashes/identity */ "./node_modules/multiformats/esm/src/hashes/identity.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const secp256k1_1 = __webpack_require__(/*! ./secp256k1 */ "./src/lib/enr/keypair/secp256k1.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts");
const { keysPBM, supportedKeys } = libp2p_crypto_1.keys;
exports.ERR_TYPE_NOT_IMPLEMENTED = "Keypair type not implemented";
__exportStar(__webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./secp256k1 */ "./src/lib/enr/keypair/secp256k1.ts"), exports);
async function generateKeypair(type) {
    switch (type) {
        case types_1.KeypairType.secp256k1:
            return await secp256k1_1.Secp256k1Keypair.generate();
        default:
            throw new Error(exports.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.generateKeypair = generateKeypair;
function createKeypair(type, privateKey, publicKey) {
    switch (type) {
        case types_1.KeypairType.secp256k1:
            return new secp256k1_1.Secp256k1Keypair(privateKey, publicKey);
        default:
            throw new Error(exports.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.createKeypair = createKeypair;
async function createPeerIdFromKeypair(keypair) {
    switch (keypair.type) {
        case types_1.KeypairType.secp256k1: {
            // manually create a peer id to avoid expensive ops
            const privKey = keypair.hasPrivateKey()
                ? new supportedKeys.secp256k1.Secp256k1PrivateKey(keypair.privateKey, keypair.publicKey)
                : undefined;
            const pubKey = new supportedKeys.secp256k1.Secp256k1PublicKey(keypair.publicKey);
            const id = await identity_1.identity.digest(pubKey.bytes);
            return new peer_id_1.default(id.bytes, privKey, pubKey);
        }
        default:
            throw new Error(exports.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.createPeerIdFromKeypair = createPeerIdFromKeypair;
function createKeypairFromPeerId(peerId) {
    // pub/private key bytes from peer-id are encoded in protobuf format
    const pub = keysPBM.PublicKey.decode(peerId.pubKey.bytes);
    return createKeypair(pub.Type, peerId.privKey ? peerId.privKey.marshal() : undefined, pub.Data);
}
exports.createKeypairFromPeerId = createKeypairFromPeerId;


/***/ }),

/***/ "./src/lib/enr/keypair/secp256k1.ts":
/*!******************************************!*\
  !*** ./src/lib/enr/keypair/secp256k1.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Secp256k1Keypair = void 0;
const secp = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/lib/index.js"));
const crypto_1 = __webpack_require__(/*! ../../crypto */ "./src/lib/crypto.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts");
class Secp256k1Keypair {
    constructor(privateKey, publicKey) {
        let pub = publicKey;
        if (pub) {
            pub = (0, crypto_1.compressPublicKey)(pub);
        }
        if ((this._privateKey = privateKey) && !this.privateKeyVerify()) {
            throw new Error("Invalid private key");
        }
        if ((this._publicKey = pub) && !this.publicKeyVerify()) {
            throw new Error("Invalid public key");
        }
        this.type = types_1.KeypairType.secp256k1;
    }
    static async generate() {
        const privateKey = (0, crypto_1.randomBytes)(32);
        const publicKey = secp.getPublicKey(privateKey);
        return new Secp256k1Keypair(privateKey, publicKey);
    }
    privateKeyVerify(key = this._privateKey) {
        if (key) {
            return secp.utils.isValidPrivateKey(key);
        }
        return true;
    }
    publicKeyVerify(key = this._publicKey) {
        if (key) {
            try {
                secp.Point.fromHex(key);
                return true;
            }
            catch {
                return false;
            }
        }
        return true;
    }
    get privateKey() {
        if (!this._privateKey) {
            throw new Error();
        }
        return this._privateKey;
    }
    get publicKey() {
        if (!this._publicKey) {
            throw new Error();
        }
        return this._publicKey;
    }
    hasPrivateKey() {
        return !!this._privateKey;
    }
}
exports.Secp256k1Keypair = Secp256k1Keypair;


/***/ }),

/***/ "./src/lib/enr/keypair/types.ts":
/*!**************************************!*\
  !*** ./src/lib/enr/keypair/types.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeypairType = void 0;
var KeypairType;
(function (KeypairType) {
    KeypairType[KeypairType["rsa"] = 0] = "rsa";
    KeypairType[KeypairType["ed25519"] = 1] = "ed25519";
    KeypairType[KeypairType["secp256k1"] = 2] = "secp256k1";
})(KeypairType = exports.KeypairType || (exports.KeypairType = {}));


/***/ }),

/***/ "./src/lib/enr/multiaddrs_codec.ts":
/*!*****************************************!*\
  !*** ./src/lib/enr/multiaddrs_codec.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeMultiaddrs = exports.decodeMultiaddrs = void 0;
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/enr/constants.ts");
function decodeMultiaddrs(bytes) {
    const multiaddrs = [];
    let index = 0;
    while (index < bytes.length) {
        const sizeDataView = new DataView(bytes.buffer, index, constants_1.MULTIADDR_LENGTH_SIZE);
        const size = sizeDataView.getUint16(0);
        index += constants_1.MULTIADDR_LENGTH_SIZE;
        const multiaddrBytes = bytes.slice(index, index + size);
        index += size;
        const multiaddr = new multiaddr_1.Multiaddr(multiaddrBytes);
        multiaddrs.push(multiaddr);
    }
    return multiaddrs;
}
exports.decodeMultiaddrs = decodeMultiaddrs;
function encodeMultiaddrs(multiaddrs) {
    const totalLength = multiaddrs.reduce((acc, ma) => acc + constants_1.MULTIADDR_LENGTH_SIZE + ma.bytes.length, 0);
    const bytes = new Uint8Array(totalLength);
    const dataView = new DataView(bytes.buffer);
    let index = 0;
    multiaddrs.forEach((multiaddr) => {
        if (multiaddr.getPeerId())
            throw new Error("`multiaddr` field MUST not contain peer id");
        // Prepend the size of the next entry
        dataView.setUint16(index, multiaddr.bytes.length);
        index += constants_1.MULTIADDR_LENGTH_SIZE;
        bytes.set(multiaddr.bytes, index);
        index += multiaddr.bytes.length;
    });
    return bytes;
}
exports.encodeMultiaddrs = encodeMultiaddrs;


/***/ }),

/***/ "./src/lib/enr/types.ts":
/*!******************************!*\
  !*** ./src/lib/enr/types.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Custom and aliased types for ENRs
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/lib/enr/v4.ts":
/*!***************************!*\
  !*** ./src/lib/enr/v4.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeId = exports.sign = void 0;
const secp = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/lib/index.js"));
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
async function sign(privKey, msg) {
    return secp.sign((0, crypto_1.keccak256)(msg), privKey, {
        der: false,
    });
}
exports.sign = sign;
function nodeId(pubKey) {
    const publicKey = secp.Point.fromHex(pubKey);
    const uncompressedPubkey = publicKey.toRawBytes(false);
    return (0, utils_1.bytesToHex)((0, crypto_1.keccak256)(uncompressedPubkey.slice(1)));
}
exports.nodeId = nodeId;


/***/ }),

/***/ "./src/lib/enr/waku2_codec.ts":
/*!************************************!*\
  !*** ./src/lib/enr/waku2_codec.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeWaku2 = exports.encodeWaku2 = void 0;
function encodeWaku2(protocols) {
    let byte = 0;
    if (protocols.lightPush)
        byte += 1;
    byte = byte << 1;
    if (protocols.filter)
        byte += 1;
    byte = byte << 1;
    if (protocols.store)
        byte += 1;
    byte = byte << 1;
    if (protocols.relay)
        byte += 1;
    return byte;
}
exports.encodeWaku2 = encodeWaku2;
function decodeWaku2(byte) {
    const waku2 = {
        relay: false,
        store: false,
        filter: false,
        lightPush: false,
    };
    if (byte % 2)
        waku2.relay = true;
    byte = byte >> 1;
    if (byte % 2)
        waku2.store = true;
    byte = byte >> 1;
    if (byte % 2)
        waku2.filter = true;
    byte = byte >> 1;
    if (byte % 2)
        waku2.lightPush = true;
    return waku2;
}
exports.decodeWaku2 = decodeWaku2;


/***/ }),

/***/ "./src/lib/select_peer.ts":
/*!********************************!*\
  !*** ./src/lib/select_peer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPeersForProtocol = exports.selectRandomPeer = void 0;
/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
async function selectRandomPeer(peersIter) {
    const peers = [];
    for await (const peer of peersIter) {
        peers.push(peer);
    }
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
exports.selectRandomPeer = selectRandomPeer;
/**
 * Returns the list of peers that supports the given protocol.
 */
async function* getPeersForProtocol(libp2p, protocols) {
    for await (const peer of libp2p.peerStore.getPeers()) {
        let peerFound = false;
        for (let i = 0; i < protocols.length; i++) {
            if (peer.protocols.includes(protocols[i])) {
                peerFound = true;
                break;
            }
        }
        if (!peerFound) {
            continue;
        }
        yield peer;
    }
}
exports.getPeersForProtocol = getPeersForProtocol;


/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.utf8ToBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.hexToBytes = void 0;
const from_string_1 = __webpack_require__(/*! uint8arrays/from-string */ "./node_modules/uint8arrays/esm/src/from-string.js");
const to_string_1 = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/uint8arrays/esm/src/to-string.js");
/**
 * Convert input to a byte array.
 *
 * Handles both `0x` prefixed and non-prefixed strings.
 */
function hexToBytes(hex) {
    if (typeof hex === "string") {
        const _hex = hex.replace(/^0x/i, "");
        return (0, from_string_1.fromString)(_hex, "base16");
    }
    return hex;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert byte array to hex string (no `0x` prefix).
 */
const bytesToHex = (bytes) => (0, to_string_1.toString)(bytes, "base16");
exports.bytesToHex = bytesToHex;
/**
 * Decode byte array to utf-8 string.
 */
const bytesToUtf8 = (b) => (0, to_string_1.toString)(b, "utf8");
exports.bytesToUtf8 = bytesToUtf8;
/**
 * Encode utf-8 string to byte array.
 */
const utf8ToBytes = (s) => (0, from_string_1.fromString)(s, "utf8");
exports.utf8ToBytes = utf8ToBytes;


/***/ }),

/***/ "./src/lib/waku.ts":
/*!*************************!*\
  !*** ./src/lib/waku.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Waku = exports.Protocols = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;
const libp2p_noise_1 = __webpack_require__(/*! @chainsafe/libp2p-noise */ "./node_modules/@chainsafe/libp2p-noise/dist/src/index.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_1 = __importDefault(__webpack_require__(/*! libp2p */ "./node_modules/libp2p/src/index.js"));
const libp2p_bootstrap_1 = __importDefault(__webpack_require__(/*! libp2p-bootstrap */ "./node_modules/libp2p-bootstrap/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_mplex_1 = __importDefault(__webpack_require__(/*! libp2p-mplex */ "./node_modules/libp2p-mplex/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_websockets_1 = __importDefault(__webpack_require__(/*! libp2p-websockets */ "./node_modules/libp2p-websockets/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const filters_1 = __importDefault(__webpack_require__(/*! libp2p-websockets/src/filters */ "./node_modules/libp2p-websockets/src/filters.js"));
const ping_1 = __importDefault(__webpack_require__(/*! libp2p/src/ping */ "./node_modules/libp2p/src/ping/index.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const discovery_1 = __webpack_require__(/*! ./discovery */ "./src/lib/discovery/index.ts");
const waku_filter_1 = __webpack_require__(/*! ./waku_filter */ "./src/lib/waku_filter/index.ts");
const waku_light_push_1 = __webpack_require__(/*! ./waku_light_push */ "./src/lib/waku_light_push/index.ts");
const waku_message_1 = __webpack_require__(/*! ./waku_message */ "./src/lib/waku_message/index.ts");
const waku_relay_1 = __webpack_require__(/*! ./waku_relay */ "./src/lib/waku_relay/index.ts");
const constants_1 = __webpack_require__(/*! ./waku_relay/constants */ "./src/lib/waku_relay/constants.ts");
const waku_store_1 = __webpack_require__(/*! ./waku_store */ "./src/lib/waku_store/index.ts");
const websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];
exports.DefaultPingKeepAliveValueSecs = 0;
exports.DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
exports.DefaultPubSubTopic = "/waku/2/default-waku/proto";
const dbg = (0, debug_1.default)("waku:waku");
var Protocols;
(function (Protocols) {
    Protocols["Relay"] = "relay";
    Protocols["Store"] = "store";
    Protocols["LightPush"] = "lightpush";
    Protocols["Filter"] = "filter";
})(Protocols = exports.Protocols || (exports.Protocols = {}));
class Waku {
    constructor(options, libp2p, store, lightPush, filter) {
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.filter = filter;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on("peer:connect", (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on("peer:disconnect", (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        options?.decryptionKeys?.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Create and start new waku node.
     */
    static async create(options) {
        // Get an object in case options or libp2p are undefined
        const libp2pOpts = Object.assign({}, options?.libp2p);
        // Default for Websocket filter is `all`:
        // Returns all TCP and DNS based addresses, both with ws or wss.
        libp2pOpts.config = Object.assign({
            transport: {
                [websocketsTransportKey]: {
                    filter: filters_1.default.all,
                },
            },
        }, options?.libp2p?.config);
        // Pass pubsub topic to relay
        if (options?.pubSubTopic) {
            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
        }
        libp2pOpts.modules = Object.assign({}, options?.libp2p?.modules);
        // Default transport for libp2p is Websockets
        libp2pOpts.modules = Object.assign({
            transport: [libp2p_websockets_1.default],
        }, options?.libp2p?.modules);
        // streamMuxer, connection encryption and pubsub are overridden
        // as those are the only ones currently supported by Waku nodes.
        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
            streamMuxer: [libp2p_mplex_1.default],
            connEncryption: [new libp2p_noise_1.Noise(options?.staticNoiseKey)],
            pubsub: waku_relay_1.WakuRelay,
        });
        if (options?.bootstrap) {
            const bootstrap = new discovery_1.Bootstrap(options?.bootstrap);
            if (bootstrap.getBootstrapPeers !== undefined) {
                try {
                    const list = await bootstrap.getBootstrapPeers();
                    // Note: this overrides any other peer discover
                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                        peerDiscovery: [libp2p_bootstrap_1.default],
                    });
                    libp2pOpts.config.peerDiscovery = {
                        [libp2p_bootstrap_1.default.tag]: {
                            list,
                            enabled: true,
                        },
                    };
                }
                catch (e) {
                    dbg("Failed to retrieve bootstrap nodes", e);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: modules property is correctly set thanks to voodoo
        const libp2p = await libp2p_1.default.create(libp2pOpts);
        const wakuStore = new waku_store_1.WakuStore(libp2p, {
            pubSubTopic: options?.pubSubTopic,
        });
        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);
        const wakuFilter = new waku_filter_1.WakuFilter(libp2p);
        await libp2p.start();
        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush, wakuFilter);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     * @param protocols Waku protocols we expect from the peer; Default to Relay
     */
    async dial(peer, protocols) {
        const _protocols = protocols ?? [Protocols.Relay];
        const codecs = [];
        if (_protocols.includes(Protocols.Relay)) {
            waku_relay_1.RelayCodecs.forEach((codec) => codecs.push(codec));
        }
        if (_protocols.includes(Protocols.Store)) {
            for (const codec of Object.values(waku_store_1.StoreCodecs)) {
                codecs.push(codec);
            }
        }
        if (_protocols.includes(Protocols.LightPush)) {
            codecs.push(waku_light_push_1.LightPushCodec);
        }
        if (_protocols.includes(Protocols.Filter)) {
            codecs.push(waku_filter_1.FilterCodec);
        }
        return this.libp2p.dialProtocol(peer, codecs);
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === "string") {
            peer = peer_id_1.default.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === "string") {
                return (0, multiaddr_1.multiaddr)(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    async stop() {
        return this.libp2p.stop();
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.relay.addDecryptionKey(key, options);
        this.store.addDecryptionKey(key, options);
        this.filter.addDecryptionKey(key, options);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
        this.filter.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     *
     * @throws if libp2p is not listening on localhost.
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === "") {
            throw "Not listening on localhost";
        }
        return localMultiaddr + "/p2p/" + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait for a remote peer to be ready given the passed protocols.
     * Useful when using the [[CreateOptions.bootstrap]] with [[Waku.create]].
     *
     * @param protocols The protocols that need to be enabled by remote peers.
     * @param timeoutMs A timeout value in milliseconds..
     *
     * @returns A promise that **resolves** if all desired protocols are fulfilled by
     * remote nodes, **rejects** if the timeoutMs is reached.
     *
     * @default Remote peer must have Waku Relay enabled and no time out is applied.
     */
    async waitForRemotePeer(protocols, timeoutMs) {
        protocols = protocols ?? [Protocols.Relay];
        const promises = [];
        if (protocols.includes(Protocols.Relay)) {
            const peers = this.relay.getPeers();
            if (peers.size == 0) {
                // No peer yet available, wait for a subscription
                const promise = new Promise((resolve) => {
                    this.libp2p.pubsub.once("pubsub:subscription-change", () => {
                        // Remote peer subscribed to topic, now wait for a heartbeat
                        // so that the mesh is updated and the remote peer added to it
                        this.libp2p.pubsub.once("gossipsub:heartbeat", resolve);
                    });
                });
                promises.push(promise);
            }
        }
        if (protocols.includes(Protocols.Store)) {
            const storePromise = (async () => {
                for await (const peer of this.store.peers) {
                    dbg("Store peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(storePromise);
        }
        if (protocols.includes(Protocols.LightPush)) {
            const lightPushPromise = (async () => {
                for await (const peer of this.lightPush.peers) {
                    dbg("Light Push peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(lightPushPromise);
        }
        if (protocols.includes(Protocols.Filter)) {
            const filterPromise = (async () => {
                for await (const peer of this.filter.peers) {
                    dbg("Filter peer found", peer.id.toB58String());
                    break;
                }
            })();
            promises.push(filterPromise);
        }
        if (timeoutMs) {
            await rejectOnTimeout(Promise.all(promises), timeoutMs, "Timed out waiting for a remote peer.");
        }
        else {
            await Promise.all(promises);
        }
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            const pingService = new ping_1.default(this.libp2p);
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                pingService.ping(peerId).catch((e) => {
                    dbg(`Ping failed (${peerIdStr})`, e);
                });
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
exports.Waku = Waku;
const awaitTimeout = (ms, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms));
const rejectOnTimeout = (promise, timeoutMs, rejectReason) => Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);


/***/ }),

/***/ "./src/lib/waku_filter/filter_rpc.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_filter/filter_rpc.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterRPC = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/filter */ "./src/proto/waku/v2/filter.ts"));
/**
 * FilterRPC represents a message conforming to the Waku Filter protocol
 */
class FilterRPC {
    constructor(proto) {
        this.proto = proto;
    }
    static createRequest(topic, contentFilters, requestId, subscribe = true) {
        return new FilterRPC({
            requestId: requestId || (0, uuid_1.v4)(),
            request: {
                subscribe,
                topic,
                contentFilters,
            },
            push: undefined,
        });
    }
    /**
     *
     * @param bytes Uint8Array of bytes from a FilterRPC message
     * @returns FilterRPC
     */
    static decode(bytes) {
        const res = proto.FilterRPC.decode(minimal_1.Reader.create(bytes));
        return new FilterRPC(res);
    }
    /**
     * Encode the current FilterRPC request to bytes
     * @returns Uint8Array
     */
    encode() {
        return proto.FilterRPC.encode(this.proto).finish();
    }
    get push() {
        return this.proto.push;
    }
    get requestId() {
        return this.proto.requestId;
    }
}
exports.FilterRPC = FilterRPC;


/***/ }),

/***/ "./src/lib/waku_filter/index.ts":
/*!**************************************!*\
  !*** ./src/lib/waku_filter/index.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuFilter = exports.FilterCodec = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js");
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const filter_rpc_1 = __webpack_require__(/*! ./filter_rpc */ "./src/lib/waku_filter/filter_rpc.ts");
exports.FilterCodec = "/vac/waku/filter/2.0.0-beta1";
const log = (0, debug_1.default)("waku:filter");
/**
 * Implements client side of the [Waku v2 Filter protocol](https://rfc.vac.dev/spec/12/).
 *
 * Note this currently only works in NodeJS when the Waku node is listening on a port, see:
 * - https://github.com/status-im/go-waku/issues/245
 * - https://github.com/status-im/nwaku/issues/948
 */
class WakuFilter {
    constructor(libp2p) {
        this.libp2p = libp2p;
        this.subscriptions = new Map();
        this.decryptionKeys = new Map();
        this.libp2p.handle(exports.FilterCodec, this.onRequest.bind(this));
    }
    /**
     * @param contentTopics Array of ContentTopics to subscribe to. If empty, no messages will be returned from the filter.
     * @param callback A function that will be called on each message returned by the filter.
     * @param opts The FilterSubscriptionOpts used to narrow which messages are returned, and which peer to connect to.
     * @returns Unsubscribe function that can be used to end the subscription.
     */
    async subscribe(callback, contentTopics, opts) {
        const topic = opts?.pubsubTopic || waku_1.DefaultPubSubTopic;
        const contentFilters = contentTopics.map((contentTopic) => ({
            contentTopic,
        }));
        const request = filter_rpc_1.FilterRPC.createRequest(topic, contentFilters, undefined, true);
        const peer = await this.getPeer(opts?.peerId);
        const stream = await this.newStream(peer);
        try {
            await (0, it_pipe_1.pipe)([request.encode()], it_length_prefixed_1.default.encode(), stream);
        }
        catch (e) {
            log("Error subscribing to peer ", peer.id.toB58String(), "for content topics", contentTopics, ": ", e);
            throw e;
        }
        this.addCallback(request.requestId, callback);
        return async () => {
            await this.unsubscribe(topic, contentFilters, request.requestId, peer);
            this.removeCallback(request.requestId);
        };
    }
    async onRequest({ stream }) {
        log("Receiving message push");
        try {
            await (0, it_pipe_1.pipe)(stream.source, it_length_prefixed_1.default.decode(), async (source) => {
                for await (const bytes of source) {
                    const res = filter_rpc_1.FilterRPC.decode(bytes.slice());
                    if (res.push?.messages?.length) {
                        await this.pushMessages(res.requestId, res.push.messages);
                    }
                }
            });
        }
        catch (e) {
            log("Error decoding message", e);
        }
    }
    async pushMessages(requestId, messages) {
        const callback = this.subscriptions.get(requestId);
        if (!callback) {
            log(`No callback registered for request ID ${requestId}`);
            return;
        }
        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
            return {
                key,
                method,
                contentTopics,
            };
        });
        for (const message of messages) {
            const decoded = await waku_message_1.WakuMessage.decodeProto(message, decryptionKeys);
            if (!decoded) {
                log("Not able to decode message");
                continue;
            }
            callback(decoded);
        }
    }
    addCallback(requestId, callback) {
        this.subscriptions.set(requestId, callback);
    }
    removeCallback(requestId) {
        this.subscriptions.delete(requestId);
    }
    async unsubscribe(topic, contentFilters, requestId, peer) {
        const unsubscribeRequest = filter_rpc_1.FilterRPC.createRequest(topic, contentFilters, requestId, false);
        const stream = await this.newStream(peer);
        try {
            await (0, it_pipe_1.pipe)([unsubscribeRequest.encode()], it_length_prefixed_1.default.encode(), stream.sink);
        }
        catch (e) {
            log("Error unsubscribing", e);
            throw e;
        }
    }
    async newStream(peer) {
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection) {
            throw new Error("Failed to get a connection to the peer");
        }
        const { stream } = await connection.newStream(exports.FilterCodec);
        return stream;
    }
    async getPeer(peerId) {
        let peer;
        if (peerId) {
            peer = await this.libp2p.peerStore.get(peerId);
            if (!peer) {
                throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toB58String()}`);
            }
        }
        else {
            peer = await this.randomPeer;
            if (!peer) {
                throw new Error("Failed to find known peer that registers waku filter protocol");
            }
        }
        return peer;
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[subscribe]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set((0, utils_1.hexToBytes)(key), options ?? {});
    }
    /**
     * Delete a decryption key so that it cannot be used in future [[subscribe]] calls
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete((0, utils_1.hexToBytes)(key));
    }
    get peers() {
        return (0, select_peer_1.getPeersForProtocol)(this.libp2p, [exports.FilterCodec]);
    }
    get randomPeer() {
        return (0, select_peer_1.selectRandomPeer)(this.peers);
    }
}
exports.WakuFilter = WakuFilter;


/***/ }),

/***/ "./src/lib/waku_light_push/index.ts":
/*!******************************************!*\
  !*** ./src/lib/waku_light_push/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js");
const light_push_1 = __webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts");
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return light_push_1.PushResponse; } }));
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const push_rpc_1 = __webpack_require__(/*! ./push_rpc */ "./src/lib/waku_light_push/push_rpc.ts");
exports.LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
class WakuLightPush {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options?.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
    }
    async push(message, opts) {
        let peer;
        if (opts?.peerId) {
            peer = await this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw "Peer is unknown";
        }
        else {
            peer = await this.randomPeer;
        }
        if (!peer)
            throw "No peer available";
        if (!peer.protocols.includes(exports.LightPushCodec))
            throw "Peer does not register waku light push protocol";
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw "Failed to get a connection to the peer";
        const { stream } = await connection.newStream(exports.LightPushCodec);
        try {
            const pubSubTopic = opts?.pubSubTopic
                ? opts.pubSubTopic
                : this.pubSubTopic;
            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);
            const res = await (0, it_pipe_1.pipe)([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            try {
                const response = push_rpc_1.PushRPC.decode(res.slice()).response;
                if (!response) {
                    console.log("No response in PushRPC");
                    return null;
                }
                return response;
            }
            catch (err) {
                console.log("Failed to decode push reply", err);
            }
        }
        catch (err) {
            console.log("Failed to send waku light push request", err);
        }
        return null;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * light push protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return (0, select_peer_1.getPeersForProtocol)(this.libp2p, [exports.LightPushCodec]);
    }
    /**
     * Returns a random peer that supports light push protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return (0, select_peer_1.selectRandomPeer)(this.peers);
    }
}
exports.WakuLightPush = WakuLightPush;


/***/ }),

/***/ "./src/lib/waku_light_push/push_rpc.ts":
/*!*********************************************!*\
  !*** ./src/lib/waku_light_push/push_rpc.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts"));
class PushRPC {
    constructor(proto) {
        this.proto = proto;
    }
    static createRequest(message, pubSubTopic) {
        return new PushRPC({
            requestId: (0, uuid_1.v4)(),
            request: {
                message: message.proto,
                pubSubTopic: pubSubTopic,
            },
            response: undefined,
        });
    }
    static decode(bytes) {
        const res = proto.PushRPC.decode(minimal_1.Reader.create(bytes));
        return new PushRPC(res);
    }
    encode() {
        return proto.PushRPC.encode(this.proto).finish();
    }
    get query() {
        return this.proto.request;
    }
    get response() {
        return this.proto.response;
    }
}
exports.PushRPC = PushRPC;


/***/ }),

/***/ "./src/lib/waku_message/ecies.ts":
/*!***************************************!*\
  !*** ./src/lib/waku_message/ecies.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decrypt = exports.encrypt = void 0;
const secp = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/lib/index.js"));
const concat_1 = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/uint8arrays/esm/src/concat.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
/**
 * HKDF as implemented in go-ethereum.
 */
function kdf(secret, outputLength) {
    let ctr = 1;
    let written = 0;
    let willBeResult = Promise.resolve(new Uint8Array());
    while (written < outputLength) {
        const counters = new Uint8Array([ctr >> 24, ctr >> 16, ctr >> 8, ctr]);
        const countersSecret = (0, concat_1.concat)([counters, secret], counters.length + secret.length);
        const willBeHashResult = (0, crypto_1.sha256)(countersSecret);
        willBeResult = willBeResult.then((result) => willBeHashResult.then((hashResult) => {
            const _hashResult = new Uint8Array(hashResult);
            return (0, concat_1.concat)([result, _hashResult], result.length + _hashResult.length);
        }));
        written += 32;
        ctr += 1;
    }
    return willBeResult;
}
function aesCtrEncrypt(counter, key, data) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, "AES-CTR", false, ["encrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().encrypt({ name: "AES-CTR", counter: counter, length: 128 }, cryptoKey, data))
        .then((bytes) => new Uint8Array(bytes));
}
function aesCtrDecrypt(counter, key, data) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, "AES-CTR", false, ["decrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().decrypt({ name: "AES-CTR", counter: counter, length: 128 }, cryptoKey, data))
        .then((bytes) => new Uint8Array(bytes));
}
function hmacSha256Sign(key, msg) {
    const algorithm = { name: "HMAC", hash: { name: "SHA-256" } };
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, algorithm, false, ["sign"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().sign(algorithm, cryptoKey, msg))
        .then((bytes) => new Uint8Array(bytes));
}
function hmacSha256Verify(key, msg, sig) {
    const algorithm = { name: "HMAC", hash: { name: "SHA-256" } };
    const _key = (0, crypto_1.getSubtle)().importKey("raw", key, algorithm, false, ["verify"]);
    return _key.then((cryptoKey) => (0, crypto_1.getSubtle)().verify(algorithm, cryptoKey, sig, msg));
}
/**
 * Derive shared secret for given private and public keys.
 *
 * @param  privateKeyA Sender's private key (32 bytes)
 * @param  publicKeyB Recipient's public key (65 bytes)
 * @returns  A promise that resolves with the derived shared secret (Px, 32 bytes)
 * @throws Error If arguments are invalid
 */
function derive(privateKeyA, publicKeyB) {
    if (privateKeyA.length !== 32) {
        throw new Error(`Bad private key, it should be 32 bytes but it's actually ${privateKeyA.length} bytes long`);
    }
    else if (publicKeyB.length !== 65) {
        throw new Error(`Bad public key, it should be 65 bytes but it's actually ${publicKeyB.length} bytes long`);
    }
    else if (publicKeyB[0] !== 4) {
        throw new Error("Bad public key, a valid public key would begin with 4");
    }
    else {
        const px = secp.getSharedSecret(privateKeyA, publicKeyB, true);
        // Remove the compression prefix
        return new Uint8Array((0, utils_1.hexToBytes)(px).slice(1));
    }
}
/**
 * Encrypt message for given recipient's public key.
 *
 * @param  publicKeyTo Recipient's public key (65 bytes)
 * @param  msg The message being encrypted
 * @return A promise that resolves with the ECIES structure serialized
 */
async function encrypt(publicKeyTo, msg) {
    const ephemPrivateKey = (0, crypto_1.randomBytes)(32);
    const sharedPx = await derive(ephemPrivateKey, publicKeyTo);
    const hash = await kdf(sharedPx, 32);
    const iv = (0, crypto_1.randomBytes)(16);
    const encryptionKey = hash.slice(0, 16);
    const cipherText = await aesCtrEncrypt(iv, encryptionKey, msg);
    const ivCipherText = (0, concat_1.concat)([iv, cipherText], iv.length + cipherText.length);
    const macKey = await (0, crypto_1.sha256)(hash.slice(16));
    const hmac = await hmacSha256Sign(macKey, ivCipherText);
    const ephemPublicKey = secp.getPublicKey(ephemPrivateKey, false);
    return (0, concat_1.concat)([ephemPublicKey, ivCipherText, hmac], ephemPublicKey.length + ivCipherText.length + hmac.length);
}
exports.encrypt = encrypt;
const metaLength = 1 + 64 + 16 + 32;
/**
 * Decrypt message using given private key.
 *
 * @param privateKey A 32-byte private key of recipient of the message
 * @param encrypted ECIES serialized structure (result of ECIES encryption)
 * @returns The clear text
 * @throws Error If decryption fails
 */
async function decrypt(privateKey, encrypted) {
    if (encrypted.length <= metaLength) {
        throw new Error(`Invalid Ciphertext. Data is too small. It should ba at least ${metaLength} bytes`);
    }
    else if (encrypted[0] !== 4) {
        throw new Error(`Not a valid ciphertext. It should begin with 4 but actually begin with ${encrypted[0]}`);
    }
    else {
        // deserialize
        const ephemPublicKey = encrypted.slice(0, 65);
        const cipherTextLength = encrypted.length - metaLength;
        const iv = encrypted.slice(65, 65 + 16);
        const cipherAndIv = encrypted.slice(65, 65 + 16 + cipherTextLength);
        const ciphertext = cipherAndIv.slice(16);
        const msgMac = encrypted.slice(65 + 16 + cipherTextLength);
        // check HMAC
        const px = derive(privateKey, ephemPublicKey);
        const hash = await kdf(px, 32);
        const [encryptionKey, macKey] = await (0, crypto_1.sha256)(hash.slice(16)).then((macKey) => [hash.slice(0, 16), macKey]);
        if (!(await hmacSha256Verify(macKey, cipherAndIv, msgMac))) {
            throw new Error("Incorrect MAC");
        }
        return aesCtrDecrypt(iv, encryptionKey, ciphertext);
    }
}
exports.decrypt = decrypt;


/***/ }),

/***/ "./src/lib/waku_message/index.ts":
/*!***************************************!*\
  !*** ./src/lib/waku_message/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = exports.DecryptionMethod = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/message */ "./src/proto/waku/v2/message.ts"));
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const version_1 = __importStar(__webpack_require__(/*! ./version_1 */ "./src/lib/waku_message/version_1.ts"));
const DefaultVersion = 0;
const dbg = (0, debug_1.default)("waku:message");
var DecryptionMethod;
(function (DecryptionMethod) {
    DecryptionMethod["Asymmetric"] = "asymmetric";
    DecryptionMethod["Symmetric"] = "symmetric";
})(DecryptionMethod = exports.DecryptionMethod || (exports.DecryptionMethod = {}));
class WakuMessage {
    constructor(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with an utf-8 string as payload.
     */
    static async fromUtf8String(utf8, contentTopic, opts) {
        const payload = (0, utils_1.utf8ToBytes)(utf8);
        return WakuMessage.fromBytes(payload, contentTopic, opts);
    }
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static async fromBytes(payload, contentTopic, opts) {
        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});
        let _payload = payload;
        let version = DefaultVersion;
        let sig;
        if (encPublicKey && symKey) {
            throw "Pass either `encPublicKey` or `symKey`, not both.";
        }
        if (encPublicKey) {
            const enc = await version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);
            sig = enc.sig;
            version = 1;
        }
        else if (symKey) {
            const enc = await version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptSymmetric(enc.payload, symKey);
            sig = enc.sig;
            version = 1;
        }
        return new WakuMessage({
            payload: _payload,
            timestampDeprecated: timestamp.valueOf() / 1000,
            // milliseconds 10^-3 to nanoseconds 10^-9
            timestamp: long_1.default.fromNumber(timestamp.valueOf()).mul(1000000),
            version,
            contentTopic,
        }, sig?.publicKey, sig?.signature);
    }
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static async decode(bytes, decryptionKeys) {
        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));
        return WakuMessage.decodeProto(protoBuf, decryptionKeys);
    }
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static async decodeProto(protoBuf, decryptionKeys) {
        if (protoBuf.payload === undefined) {
            dbg("Payload is undefined");
            return;
        }
        const payload = protoBuf.payload;
        let signaturePublicKey;
        let signature;
        if (protoBuf.version === 1 && protoBuf.payload) {
            if (decryptionKeys === undefined) {
                dbg("Payload is encrypted but no private keys have been provided.");
                return;
            }
            // Returns a bunch of `undefined` and hopefully one decrypted result
            const allResults = await Promise.all(decryptionKeys.map(async ({ key, method, contentTopics }) => {
                if (!contentTopics ||
                    (protoBuf.contentTopic &&
                        contentTopics.includes(protoBuf.contentTopic))) {
                    switch (method) {
                        case DecryptionMethod.Asymmetric:
                            try {
                                return await version_1.decryptAsymmetric(payload, key);
                            }
                            catch (e) {
                                dbg("Failed to decrypt message using asymmetric encryption despite decryption method being specified", e);
                                return;
                            }
                        case DecryptionMethod.Symmetric:
                            try {
                                return await version_1.decryptSymmetric(payload, key);
                            }
                            catch (e) {
                                dbg("Failed to decrypt message using asymmetric encryption despite decryption method being specified", e);
                                return;
                            }
                        default:
                            try {
                                return await version_1.decryptSymmetric(payload, key);
                            }
                            catch (e) {
                                dbg("Failed to decrypt message using symmetric encryption", e);
                                try {
                                    return await version_1.decryptAsymmetric(payload, key);
                                }
                                catch (e) {
                                    dbg("Failed to decrypt message using asymmetric encryption", e);
                                    return;
                                }
                            }
                    }
                }
                else {
                    // No key available for this content topic
                    return;
                }
            }));
            const isDefined = (dec) => {
                return !!dec;
            };
            const decodedResults = allResults.filter(isDefined);
            if (decodedResults.length === 0) {
                dbg("Failed to decrypt payload.");
                return;
            }
            const dec = decodedResults[0];
            const res = await version_1.clearDecode(dec);
            if (!res) {
                dbg("Failed to decode payload.");
                return;
            }
            Object.assign(protoBuf, { payload: res.payload });
            signaturePublicKey = res.sig?.publicKey;
            signature = res.sig?.signature;
        }
        return new WakuMessage(protoBuf, signaturePublicKey, signature);
    }
    encode() {
        return proto.WakuMessage.encode(this.proto).finish();
    }
    get payloadAsUtf8() {
        if (!this.payload) {
            return "";
        }
        try {
            return (0, utils_1.bytesToUtf8)(this.payload);
        }
        catch (e) {
            dbg("Could not decode byte as UTF-8", e);
            return "";
        }
    }
    get payload() {
        if (this.proto.payload) {
            return new Uint8Array(this.proto.payload);
        }
        return;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get version() {
        return this.proto.version;
    }
    get timestamp() {
        // In the case we receive a value that is bigger than JS's max number,
        // we catch the error and return undefined.
        try {
            if (this.proto.timestamp) {
                // nanoseconds 10^-9 to milliseconds 10^-3
                const timestamp = this.proto.timestamp.div(1000000).toNumber();
                return new Date(timestamp);
            }
            if (this.proto.timestampDeprecated) {
                return new Date(this.proto.timestampDeprecated * 1000);
            }
        }
        catch (e) {
            return;
        }
        return;
    }
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey() {
        return this._signaturePublicKey;
    }
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature() {
        return this._signature;
    }
}
exports.WakuMessage = WakuMessage;


/***/ }),

/***/ "./src/lib/waku_message/symmetric.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_message/symmetric.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateIv = exports.decrypt = exports.encrypt = exports.TagSize = exports.IvSize = exports.KeySize = void 0;
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
exports.KeySize = 32;
exports.IvSize = 12;
exports.TagSize = 16;
const Algorithm = { name: "AES-GCM", length: 128 };
async function encrypt(iv, key, clearText) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, Algorithm, false, ["encrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().encrypt({ iv, ...Algorithm }, cryptoKey, clearText))
        .then((cipher) => new Uint8Array(cipher));
}
exports.encrypt = encrypt;
async function decrypt(iv, key, cipherText) {
    return (0, crypto_1.getSubtle)()
        .importKey("raw", key, Algorithm, false, ["decrypt"])
        .then((cryptoKey) => (0, crypto_1.getSubtle)().decrypt({ iv, ...Algorithm }, cryptoKey, cipherText))
        .then((clear) => new Uint8Array(clear));
}
exports.decrypt = decrypt;
function generateIv() {
    return (0, crypto_1.randomBytes)(exports.IvSize);
}
exports.generateIv = generateIv;


/***/ }),

/***/ "./src/lib/waku_message/version_1.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_message/version_1.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;
const secp = __importStar(__webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/lib/index.js"));
const concat_1 = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/uint8arrays/esm/src/concat.js");
const crypto_1 = __webpack_require__(/*! ../crypto */ "./src/lib/crypto.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const ecies = __importStar(__webpack_require__(/*! ./ecies */ "./src/lib/waku_message/ecies.ts"));
const symmetric = __importStar(__webpack_require__(/*! ./symmetric */ "./src/lib/waku_message/symmetric.ts"));
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
exports.PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
async function clearEncode(messagePayload, sigPrivKey) {
    let envelope = new Uint8Array([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = (0, concat_1.concat)([envelope, messagePayload]);
    // Calculate padding:
    let rawSize = FlagsLength +
        computeSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    const remainder = rawSize % PaddingTarget;
    const paddingSize = PaddingTarget - remainder;
    const pad = (0, crypto_1.randomBytes)(paddingSize);
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error("failed to generate random padding of size " + paddingSize);
    }
    envelope = (0, concat_1.concat)([envelope, pad]);
    let sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        const hash = (0, crypto_1.keccak256)(envelope);
        const bytesSignature = await (0, crypto_1.sign)(hash, sigPrivKey);
        envelope = (0, concat_1.concat)([envelope, bytesSignature]);
        sig = {
            signature: bytesSignature,
            publicKey: secp.getPublicKey(sigPrivKey, false),
        };
    }
    return { payload: envelope, sig };
}
exports.clearEncode = clearEncode;
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
function clearDecode(message) {
    const sizeOfPayloadSizeField = getSizeOfPayloadSizeField(message);
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = getPayloadSize(message, sizeOfPayloadSizeField);
    const payloadStart = 1 + sizeOfPayloadSizeField;
    const payload = message.slice(payloadStart, payloadStart + payloadSize);
    const isSigned = isMessageSigned(message);
    let sig;
    if (isSigned) {
        const signature = getSignature(message);
        const hash = getHash(message, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
exports.clearDecode = clearDecode;
function getSizeOfPayloadSizeField(message) {
    const messageDataView = new DataView(message.buffer);
    return messageDataView.getUint8(0) & FlagMask;
}
function getPayloadSize(message, sizeOfPayloadSizeField) {
    let payloadSizeBytes = message.slice(1, 1 + sizeOfPayloadSizeField);
    // int 32 == 4 bytes
    if (sizeOfPayloadSizeField < 4) {
        // If less than 4 bytes pad right (Little Endian).
        payloadSizeBytes = (0, concat_1.concat)([payloadSizeBytes, new Uint8Array(4 - sizeOfPayloadSizeField)], 4);
    }
    const payloadSizeDataView = new DataView(payloadSizeBytes.buffer);
    return payloadSizeDataView.getInt32(0, true);
}
function isMessageSigned(message) {
    const messageDataView = new DataView(message.buffer);
    return (messageDataView.getUint8(0) & IsSignedMask) == IsSignedMask;
}
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result  can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptAsymmetric(data, publicKey) {
    return ecies.encrypt((0, utils_1.hexToBytes)(publicKey), data);
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The returned data is expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptAsymmetric(payload, privKey) {
    return ecies.decrypt(privKey, payload);
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptSymmetric(data, key) {
    const iv = symmetric.generateIv();
    // Returns `cipher | tag`
    const cipher = await symmetric.encrypt(iv, (0, utils_1.hexToBytes)(key), data);
    return (0, concat_1.concat)([cipher, iv]);
}
exports.encryptSymmetric = encryptSymmetric;
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptSymmetric(payload, key) {
    const ivStart = payload.length - symmetric.IvSize;
    const cipher = payload.slice(0, ivStart);
    const iv = payload.slice(ivStart);
    return symmetric.decrypt(iv, (0, utils_1.hexToBytes)(key), cipher);
}
exports.decryptSymmetric = decryptSymmetric;
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = computeSizeOfPayloadSizeField(payload);
    let field = new Uint8Array(4);
    const fieldDataView = new DataView(field.buffer);
    fieldDataView.setUint32(0, payload.length, true);
    field = field.slice(0, fieldSize);
    msg = (0, concat_1.concat)([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function computeSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return expectedSize <= 3 || value.findIndex((i) => i !== 0) !== -1;
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return (0, crypto_1.keccak256)(message.slice(0, message.length - SignatureLength));
    }
    return (0, crypto_1.keccak256)(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recoveryDataView = new DataView(signature.slice(64).buffer);
    const recovery = recoveryDataView.getUint8(0);
    const _signature = secp.Signature.fromCompact(signature.slice(0, 64));
    return secp.recoverPublicKey(messageHash, _signature, recovery, 
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: compressed: false
    false);
}


/***/ }),

/***/ "./src/lib/waku_relay/constants.ts":
/*!*****************************************!*\
  !*** ./src/lib/waku_relay/constants.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayMaxIHaveLength = exports.RelayOpportunisticGraftPeers = exports.RelayOpportunisticGraftTicks = exports.RelayFanoutTTL = exports.RelayPruneBackoff = exports.RelayPrunePeers = exports.RelayHeartbeatInterval = exports.RelayHeartbeatInitialDelay = exports.RelayGossipFactor = exports.RelayPingContentTopic = exports.RelayCodecs = exports.minute = exports.second = void 0;
exports.second = 1000;
exports.minute = 60 * exports.second;
/**
 * RelayCodec is the libp2p identifier for the waku relay protocol
 */
exports.RelayCodecs = [
    "/vac/waku/relay/2.0.0-beta2",
    "/vac/waku/relay/2.0.0",
];
exports.RelayPingContentTopic = "/relay-ping/1/ping/null";
/**
 * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.
 * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or
 * RelayDlazy, whichever is greater.
 */
exports.RelayGossipFactor = 0.25;
/**
 * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins
 * after the router is initialized.
 */
exports.RelayHeartbeatInitialDelay = 100;
/**
 * RelayHeartbeatInterval controls the time between heartbeats.
 */
exports.RelayHeartbeatInterval = exports.second;
/**
 * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.
 * When we prune a peer that's eligible for PX (has a good score, etc), we will try to
 * send them signed peer records for up to RelayPrunePeers other peers that we
 * know of.
 */
exports.RelayPrunePeers = 16;
/**
 * RelayPruneBackoff controls the backoff time for pruned peers. This is how long
 * a peer must wait before attempting to graft into our mesh again after being pruned.
 * When pruning a peer, we send them our value of RelayPruneBackoff so they know
 * the minimum time to wait. Peers running older versions may not send a backoff time,
 * so if we receive a prune message without one, we will wait at least RelayPruneBackoff
 * before attempting to re-graft.
 */
exports.RelayPruneBackoff = exports.minute;
/**
 * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been
 * RelayFanoutTTL since we've published to a topic that we're not subscribed to,
 * we'll delete the fanout map for that topic.
 */
exports.RelayFanoutTTL = exports.minute;
/**
 * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh
 * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some
 * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls
 * below a threshold
 */
exports.RelayOpportunisticGraftTicks = 60;
/**
 * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.
 */
exports.RelayOpportunisticGraftPeers = 2;
/**
 * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.
 * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a
 * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the
 * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;
 * with the defaults this is 1666 messages/s.
 */
exports.RelayMaxIHaveLength = 5000;


/***/ }),

/***/ "./src/lib/waku_relay/get_relay_peers.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/get_relay_peers.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRelayPeers = void 0;
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_relay/index.ts");
/**
 * Given a topic, returns up to count peers subscribed to that topic
 * that pass an optional filter function
 *
 * @param {Gossipsub} router
 * @param {String} topic
 * @param {Number} count
 * @param {Function} [filter] a function to filter acceptable peers
 * @returns {Set<string>}
 *
 */
function getRelayPeers(router, topic, count, filter = () => true) {
    const peersInTopic = router.topics.get(topic);
    if (!peersInTopic) {
        return new Set();
    }
    // Adds all peers using our protocol
    // that also pass the filter function
    let peers = [];
    peersInTopic.forEach((id) => {
        const peerStreams = router.peers.get(id);
        if (!peerStreams) {
            return;
        }
        if (index_1.RelayCodecs.includes(peerStreams.protocol) && filter(id)) {
            peers.push(id);
        }
    });
    // Pseudo-randomly shuffles peers
    peers = (0, utils_1.shuffle)(peers);
    if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
    }
    return new Set(peers);
}
exports.getRelayPeers = getRelayPeers;


/***/ }),

/***/ "./src/lib/waku_relay/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_relay/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuRelay = exports.RelayCodecs = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_gossipsub_1 = __importDefault(__webpack_require__(/*! libp2p-gossipsub */ "./node_modules/libp2p-gossipsub/src/index.js"));
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const signature_policy_1 = __webpack_require__(/*! libp2p-interfaces/src/pubsub/signature-policy */ "./node_modules/libp2p-interfaces/src/pubsub/signature-policy.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const utils_2 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts");
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return constants_1.RelayCodecs; } }));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
const relay_heartbeat_1 = __webpack_require__(/*! ./relay_heartbeat */ "./src/lib/waku_relay/relay_heartbeat.ts");
const dbg = (0, debug_1.default)("waku:relay");
/**
 * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.
 * Must be passed as a `pubsub` module to a {Libp2p} instance.
 *
 * @implements {require('libp2p-interfaces/src/pubsub')}
 * @noInheritDoc
 */
class WakuRelay extends libp2p_gossipsub_1.default {
    constructor(libp2p, options) {
        super(libp2p, Object.assign(options, {
            // Ensure that no signature is included nor expected in the messages.
            globalSignaturePolicy: signature_policy_1.SignaturePolicy.StrictNoSign,
        }));
        this.heartbeat = new relay_heartbeat_1.RelayHeartbeat(this);
        this.observers = {};
        this.decryptionKeys = new Map();
        const multicodecs = constants.RelayCodecs;
        Object.assign(this, { multicodecs });
        this.pubSubTopic = options?.pubSubTopic || waku_1.DefaultPubSubTopic;
        options?.decryptionKeys?.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Mounts the gossipsub protocol onto the libp2p node
     * and subscribes to the default topic.
     *
     * @override
     * @returns {void}
     */
    async start() {
        await super.start();
        this.subscribe(this.pubSubTopic);
    }
    /**
     * Send Waku message.
     *
     * @param {WakuMessage} message
     * @returns {Promise<void>}
     */
    async send(message) {
        const msg = message.encode();
        await super.publish(this.pubSubTopic, msg);
    }
    /**
     * Register a decryption key to attempt decryption of received messages.
     * This can either be a private key for asymmetric encryption or a symmetric
     * key. `WakuRelay` will attempt to decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set((0, utils_2.hexToBytes)(key), options ?? {});
    }
    /**
     * Delete a decryption key that was used to attempt decryption of received
     * messages.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete((0, utils_2.hexToBytes)(key));
    }
    /**
     * Register an observer of new messages received via waku relay
     *
     * @param callback called when a new message is received via waku relay
     * @param contentTopics Content Topics for which the callback with be called,
     * all of them if undefined, [] or ["",..] is passed.
     * @returns {void}
     */
    addObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (!this.observers[""]) {
                this.observers[""] = new Set();
            }
            this.observers[""].add(callback);
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (!this.observers[contentTopic]) {
                    this.observers[contentTopic] = new Set();
                }
                this.observers[contentTopic].add(callback);
            });
        }
    }
    /**
     * Remove an observer of new messages received via waku relay.
     * Useful to ensure the same observer is not registered several time
     * (e.g when loading React components)
     */
    deleteObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (this.observers[""]) {
                this.observers[""].delete(callback);
            }
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (this.observers[contentTopic]) {
                    this.observers[contentTopic].delete(callback);
                }
            });
        }
    }
    /**
     * Return the relay peers we are connected to, and we would publish a message to
     */
    getPeers() {
        return (0, get_relay_peers_1.getRelayPeers)(this, this.pubSubTopic, this._options.D, (id) => {
            // Filter peers we would not publish to
            return (this.score.score(id) >= this._options.scoreThresholds.publishThreshold);
        });
    }
    /**
     * Subscribe to a pubsub topic and start emitting Waku messages to observers.
     *
     * @override
     */
    subscribe(pubSubTopic) {
        this.on(pubSubTopic, (event) => {
            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
                return {
                    key,
                    method,
                    contentTopics,
                };
            });
            dbg(`Message received on ${pubSubTopic}`);
            waku_message_1.WakuMessage.decode(event.data, decryptionKeys)
                .then((wakuMsg) => {
                if (!wakuMsg) {
                    dbg("Failed to decode Waku Message");
                    return;
                }
                if (this.observers[""]) {
                    this.observers[""].forEach((callbackFn) => {
                        callbackFn(wakuMsg);
                    });
                }
                if (wakuMsg.contentTopic) {
                    if (this.observers[wakuMsg.contentTopic]) {
                        this.observers[wakuMsg.contentTopic].forEach((callbackFn) => {
                            callbackFn(wakuMsg);
                        });
                    }
                }
            })
                .catch((e) => {
                dbg("Failed to decode Waku Message", e);
            });
        });
        super.subscribe(pubSubTopic);
    }
    /**
     * Join pubsub topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @internal
     * @param {string} topic
     * @returns {void}
     * @override
     */
    join(topic) {
        if (!this.started) {
            throw new Error("WakuRelayPubSub has not started");
        }
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
            // these peers have a score above the publish threshold, which may be negative
            // so drop the ones with a negative score
            fanoutPeers.forEach((id) => {
                if (this.score.score(id) < 0) {
                    fanoutPeers.delete(id);
                }
            });
            if (fanoutPeers.size < this._options.D) {
                // we need more peers; eager, as this would get fixed in the next heartbeat
                (0, get_relay_peers_1.getRelayPeers)(this, topic, this._options.D - fanoutPeers.size, (id) => {
                    // filter our current peers, direct peers, and peers with negative scores
                    return (!fanoutPeers.has(id) &&
                        !this.direct.has(id) &&
                        this.score.score(id) >= 0);
                }).forEach((id) => fanoutPeers.add(id));
            }
            this.mesh.set(topic, fanoutPeers);
            this.fanout.delete(topic);
            this.lastpub.delete(topic);
        }
        else {
            const peers = (0, get_relay_peers_1.getRelayPeers)(this, topic, this._options.D, (id) => {
                // filter direct peers and peers with negative score
                return !this.direct.has(id) && this.score.score(id) >= 0;
            });
            this.mesh.set(topic, peers);
        }
        this.mesh.get(topic)?.forEach((id) => {
            this.log("JOIN: Add mesh link to %s in %s", id, topic);
            this._sendGraft(id, topic);
        });
    }
    /**
     * Publish messages.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {InMessage} msg
     * @returns {void}
     */
    async _publish(msg) {
        const msgIdStr = await this.getCanonicalMsgIdStr(msg);
        if (msg.receivedFrom !== this.peerId.toB58String()) {
            this.score.deliverMessage(msg, msgIdStr);
            this.gossipTracer.deliverMessage(msgIdStr);
        }
        // put in seen cache
        this.seenCache.put(msgIdStr);
        this.messageCache.put(msg, msgIdStr);
        const toSend = new Set();
        msg.topicIDs.forEach((topic) => {
            const peersInTopic = this.topics.get(topic);
            if (!peersInTopic) {
                return;
            }
            // direct peers
            this.direct.forEach((id) => {
                toSend.add(id);
            });
            let meshPeers = this.mesh.get(topic);
            if (!meshPeers || !meshPeers.size) {
                // We are not in the mesh for topic, use fanout peers
                meshPeers = this.fanout.get(topic);
                if (!meshPeers) {
                    // If we are not in the fanout, then pick peers in topic above the publishThreshold
                    const peers = (0, get_relay_peers_1.getRelayPeers)(this, topic, this._options.D, (id) => {
                        return (this.score.score(id) >=
                            this._options.scoreThresholds.publishThreshold);
                    });
                    if (peers.size > 0) {
                        meshPeers = peers;
                        this.fanout.set(topic, peers);
                    }
                    else {
                        meshPeers = new Set();
                    }
                }
                // Store the latest publishing time
                this.lastpub.set(topic, this._now());
            }
            meshPeers?.forEach((peer) => {
                toSend.add(peer);
            });
        });
        // Publish messages to peers
        const rpc = (0, utils_1.createGossipRpc)([libp2p_gossipsub_1.default.utils.normalizeOutRpcMessage(msg)]);
        dbg(`Relay message to ${toSend.size} peers`);
        toSend.forEach((id) => {
            if (id === msg.from) {
                return;
            }
            dbg("Relay message to", id);
            this._sendRpc(id, rpc);
        });
    }
    /**
     * Emits gossip to peers in a particular topic.
     *
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} topic
     * @param {Set<string>} exclude peers to exclude
     * @returns {void}
     */
    _emitGossip(topic, exclude) {
        const messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
            return;
        }
        // shuffle to emit in random order
        (0, utils_1.shuffle)(messageIDs);
        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list
        if (messageIDs.length > constants.RelayMaxIHaveLength) {
            // we do the truncation (with shuffling) per peer below
            this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
        }
        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy
        // First we collect the peers above gossipThreshold that are not in the exclude set
        // and then randomly select from that set
        // We also exclude direct peers, as there is no reason to emit gossip to them
        const peersToGossip = [];
        const topicPeers = this.topics.get(topic);
        if (!topicPeers) {
            // no topic peers, no gossip
            return;
        }
        topicPeers.forEach((id) => {
            const peerStreams = this.peers.get(id);
            if (!peerStreams) {
                return;
            }
            if (!exclude.has(id) &&
                !this.direct.has(id) &&
                constants.RelayCodecs.includes(peerStreams.protocol) &&
                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
                peersToGossip.push(id);
            }
        });
        let target = this._options.Dlazy;
        const factor = constants.RelayGossipFactor * peersToGossip.length;
        if (factor > target) {
            target = factor;
        }
        if (target > peersToGossip.length) {
            target = peersToGossip.length;
        }
        else {
            (0, utils_1.shuffle)(peersToGossip);
        }
        // Emit the IHAVE gossip to the selected peers up to the target
        peersToGossip.slice(0, target).forEach((id) => {
            let peerMessageIDs = messageIDs;
            if (messageIDs.length > constants.RelayMaxIHaveLength) {
                // shuffle and slice message IDs per peer so that we emit a different set for each peer
                // we have enough redundancy in the system that this will significantly increase the message
                // coverage when we do truncate
                peerMessageIDs = (0, utils_1.shuffle)(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);
            }
            this._pushGossip(id, {
                topicID: topic,
                messageIDs: peerMessageIDs,
            });
        });
    }
    /**
     * Make a PRUNE control message for a peer in a topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} id
     * @param {string} topic
     * @param {boolean} doPX
     * @returns {Promise<RPC.IControlPrune>}
     */
    async _makePrune(id, topic, doPX) {
        // backoff is measured in seconds
        // RelayPruneBackoff is measured in milliseconds
        const backoff = constants.RelayPruneBackoff / 1000;
        if (!doPX) {
            return {
                topicID: topic,
                peers: [],
                backoff: backoff,
            };
        }
        // select peers for Peer eXchange
        const peers = (0, get_relay_peers_1.getRelayPeers)(this, topic, constants.RelayPrunePeers, (xid) => {
            return xid !== id && this.score.score(xid) >= 0;
        });
        const px = await Promise.all(Array.from(peers).map(async (p) => {
            // see if we have a signed record to send back; if we don't, just send
            // the peer ID and let the pruned peer find them in the DHT -- we can't trust
            // unsigned address records through PX anyways
            // Finding signed records in the DHT is not supported at the time of writing in js-libp2p
            const peerId = peer_id_1.default.createFromB58String(p);
            return {
                peerID: peerId.toBytes(),
                signedPeerRecord: await this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),
            };
        }));
        return {
            topicID: topic,
            peers: px,
            backoff: backoff,
        };
    }
}
exports.WakuRelay = WakuRelay;


/***/ }),

/***/ "./src/lib/waku_relay/relay_heartbeat.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/relay_heartbeat.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayHeartbeat = void 0;
const heartbeat_1 = __webpack_require__(/*! libp2p-gossipsub/src/heartbeat */ "./node_modules/libp2p-gossipsub/src/heartbeat.js");
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
class RelayHeartbeat extends heartbeat_1.Heartbeat {
    /**
     * @param {Object} gossipsub
     * @constructor
     */
    constructor(gossipsub) {
        super(gossipsub);
    }
    start() {
        if (this._heartbeatTimer) {
            return;
        }
        const heartbeat = this._heartbeat.bind(this);
        const timeout = setTimeout(() => {
            heartbeat();
            this._heartbeatTimer?.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);
        }, constants.RelayHeartbeatInitialDelay);
        this._heartbeatTimer = {
            _intervalId: undefined,
            runPeriodically: (fn, period) => {
                // this._heartbeatTimer cannot be null, it is being assigned.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this._heartbeatTimer._intervalId = setInterval(fn, period);
            },
            cancel: () => {
                clearTimeout(timeout);
                clearInterval(this._heartbeatTimer?._intervalId);
            },
        };
    }
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     * @override
     * @returns {void}
     */
    stop() {
        if (!this._heartbeatTimer) {
            return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
    }
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     *
     * @returns {void}
     */
    _heartbeat() {
        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;
        this.gossipsub.heartbeatTicks++;
        // cache scores through the heartbeat
        const scores = new Map();
        const getScore = (id) => {
            let s = scores.get(id);
            if (s === undefined) {
                s = this.gossipsub.score.score(id);
                scores.set(id, s);
            }
            return s;
        };
        // peer id => topic[]
        const toGraft = new Map();
        // peer id => topic[]
        const toPrune = new Map();
        // peer id => don't px
        const noPX = new Map();
        // clean up expired backoffs
        this.gossipsub._clearBackoff();
        // clean up peerhave/iasked counters
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        // apply IWANT request penalties
        this.gossipsub._applyIwantPenalties();
        // ensure direct peers are connected
        this.gossipsub._directConnect();
        // maintain the mesh for topics we have joined
        this.gossipsub.mesh.forEach((peers, topic) => {
            // prune/graft helper functions (defined per topic)
            const prunePeer = (id) => {
                this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
                // update peer score
                this.gossipsub.score.prune(id, topic);
                // add prune backoff record
                this.gossipsub._addBackoff(id, topic);
                // remove peer from mesh
                peers.delete(id);
                // add to toPrune
                const topics = toPrune.get(id);
                if (!topics) {
                    toPrune.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            const graftPeer = (id) => {
                this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
                // update peer score
                this.gossipsub.score.graft(id, topic);
                // add peer to mesh
                peers.add(id);
                // add to toGraft
                const topics = toGraft.get(id);
                if (!topics) {
                    toGraft.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            // drop all peers with negative score, without PX
            peers.forEach((id) => {
                const score = getScore(id);
                if (score < 0) {
                    this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
                    prunePeer(id);
                    noPX.set(id, true);
                }
            });
            // do we have enough peers?
            if (peers.size < Dlo) {
                const backoff = this.gossipsub.backoff.get(topic);
                const ineed = D - peers.size;
                const peersSet = (0, get_relay_peers_1.getRelayPeers)(this.gossipsub, topic, ineed, (id) => {
                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score
                    return (!peers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        (!backoff || !backoff.has(id)) &&
                        getScore(id) >= 0);
                });
                peersSet.forEach(graftPeer);
            }
            // do we have to many peers?
            if (peers.size > Dhi) {
                let peersArray = Array.from(peers);
                // sort by score
                peersArray.sort((a, b) => getScore(b) - getScore(a));
                // We keep the first D_score peers by score and the remaining up to D randomly
                // under the constraint that we keep D_out peers in the mesh (if we have that many)
                peersArray = peersArray
                    .slice(0, Dscore)
                    .concat((0, utils_1.shuffle)(peersArray.slice(Dscore)));
                // count the outbound peers we are keeping
                let outbound = 0;
                peersArray.slice(0, D).forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, bubble up some outbound peers from the random selection
                if (outbound < Dout) {
                    const rotate = (i) => {
                        // rotate the peersArray to the right and put the ith peer in the front
                        const p = peersArray[i];
                        for (let j = i; j > 0; j--) {
                            peersArray[j] = peersArray[j - 1];
                        }
                        peersArray[0] = p;
                    };
                    // first bubble up all outbound peers already in the selection to the front
                    if (outbound > 0) {
                        let ihave = outbound;
                        for (let i = 1; i < D && ihave > 0; i++) {
                            if (this.gossipsub.outbound.get(peersArray[i])) {
                                rotate(i);
                                ihave--;
                            }
                        }
                    }
                    // now bubble up enough outbound peers outside the selection to the front
                    let ineed = D - outbound;
                    for (let i = D; i < peersArray.length && ineed > 0; i++) {
                        if (this.gossipsub.outbound.get(peersArray[i])) {
                            rotate(i);
                            ineed--;
                        }
                    }
                }
                // prune the excess peers
                peersArray.slice(D).forEach(prunePeer);
            }
            // do we have enough outbound peers?
            if (peers.size >= Dlo) {
                // count the outbound peers we have
                let outbound = 0;
                peers.forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, select some peers with outbound connections and graft them
                if (outbound < Dout) {
                    const ineed = Dout - outbound;
                    const backoff = this.gossipsub.backoff.get(topic);
                    (0, get_relay_peers_1.getRelayPeers)(this.gossipsub, topic, ineed, (id) => {
                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score
                        return (!peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) >= 0);
                    }).forEach(graftPeer);
                }
            }
            // should we try to improve the mesh with opportunistic grafting?
            if (this.gossipsub.heartbeatTicks %
                constants.RelayOpportunisticGraftTicks ===
                0 &&
                peers.size > 1) {
                // Opportunistic grafting works as follows: we check the median score of peers in the
                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at
                // random with score over the median.
                // The intention is to (slowly) improve an under performing mesh by introducing good
                // scoring peers that may have been gossiping at us. This allows us to get out of sticky
                // situations where we are stuck with poor peers and also recover from churn of good peers.
                // now compute the median peer score in the mesh
                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
                const medianIndex = Math.floor(peers.size / 2);
                const medianScore = getScore(peersList[medianIndex]);
                // if the median score is below the threshold, select a better peer (if any) and GRAFT
                if (medianScore <
                    this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                    const backoff = this.gossipsub.backoff.get(topic);
                    const peersToGraft = (0, get_relay_peers_1.getRelayPeers)(this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, (id) => {
                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold
                        return (peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) > medianScore);
                    });
                    peersToGraft.forEach((id) => {
                        this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
                        graftPeer(id);
                    });
                }
            }
            // 2nd arg are mesh peers excluded from gossip. We have already pushed
            // messages to them, so its redundant to gossip IHAVEs.
            this.gossipsub._emitGossip(topic, peers);
        });
        // expire fanout for topics we haven't published to in a while
        const now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach((lastpub, topic) => {
            if (lastpub + constants.RelayFanoutTTL < now) {
                this.gossipsub.fanout.delete(topic);
                this.gossipsub.lastpub.delete(topic);
            }
        });
        // maintain our fanout for topics we are publishing but we have not joined
        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
            // checks whether our peers are still in the topic and have a score above the publish threshold
            const topicPeers = this.gossipsub.topics.get(topic);
            fanoutPeers.forEach((id) => {
                if (!topicPeers?.has(id) ||
                    getScore(id) <
                        this.gossipsub._options.scoreThresholds.publishThreshold) {
                    fanoutPeers.delete(id);
                }
            });
            // do we need more peers?
            if (fanoutPeers.size < D) {
                const ineed = D - fanoutPeers.size;
                const peersSet = (0, get_relay_peers_1.getRelayPeers)(this.gossipsub, topic, ineed, (id) => {
                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold
                    return (!fanoutPeers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        getScore(id) >=
                            this.gossipsub._options.scoreThresholds.publishThreshold);
                });
                peersSet.forEach((id) => {
                    fanoutPeers.add(id);
                });
            }
            // 2nd arg are fanout peers excluded from gossip.
            // We have already pushed messages to them, so its redundant to gossip IHAVEs
            this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)
        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);
        // flush pending gossip that wasn't piggybacked above
        this.gossipsub._flush();
        // advance the message history window
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit("gossipsub:heartbeat");
    }
}
exports.RelayHeartbeat = RelayHeartbeat;


/***/ }),

/***/ "./src/lib/waku_store/history_rpc.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_store/history_rpc.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.PageDirection = void 0;
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const protoV2Beta3 = __importStar(__webpack_require__(/*! ../../proto/waku/v2/store/v2beta3/store */ "./src/proto/waku/v2/store/v2beta3/store.ts"));
const protoV2Beta4 = __importStar(__webpack_require__(/*! ../../proto/waku/v2/store/v2beta4/store */ "./src/proto/waku/v2/store/v2beta4/store.ts"));
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_store/index.ts");
var PageDirection;
(function (PageDirection) {
    PageDirection["BACKWARD"] = "backward";
    PageDirection["FORWARD"] = "forward";
})(PageDirection = exports.PageDirection || (exports.PageDirection = {}));
class HistoryRPC {
    constructor(proto, storeCodec) {
        this.proto = proto;
        this.storeCodec = storeCodec;
        switch (storeCodec) {
            case index_1.StoreCodecs.V2Beta3:
                this.protoCodec = protoV2Beta3;
                break;
            case index_1.StoreCodecs.V2Beta4:
                this.protoCodec = protoV2Beta4;
                break;
            default:
                throw `Internal Error: Unexpected store codec value received in constructor: ${storeCodec}`;
        }
    }
    get query() {
        return this.proto.query;
    }
    get response() {
        return this.proto.response;
    }
    /**
     * Create History Query.
     */
    static createQuery(params) {
        const storeCodec = params.storeCodec ?? index_1.StoreCodecs.V2Beta4;
        const contentFilters = params.contentTopics.map((contentTopic) => {
            return { contentTopic };
        });
        const direction = directionToProto(params.pageDirection);
        switch (storeCodec) {
            case index_1.StoreCodecs.V2Beta3:
                // Using function to scope variables
                return (() => {
                    const pagingInfo = {
                        pageSize: long_1.default.fromNumber(params.pageSize),
                        cursor: params.cursor,
                        direction,
                    };
                    let startTime, endTime;
                    if (params.startTime)
                        startTime = params.startTime.valueOf() / 1000;
                    if (params.endTime)
                        endTime = params.endTime.valueOf() / 1000;
                    return new HistoryRPC({
                        requestId: (0, uuid_1.v4)(),
                        query: {
                            pubSubTopic: params.pubSubTopic,
                            contentFilters,
                            pagingInfo,
                            startTime,
                            endTime,
                        },
                        response: undefined,
                    }, storeCodec);
                })();
            case index_1.StoreCodecs.V2Beta4:
                return (() => {
                    const pagingInfo = {
                        pageSize: long_1.default.fromNumber(params.pageSize),
                        cursor: params.cursor,
                        direction,
                    };
                    let startTime, endTime;
                    if (params.startTime) {
                        // milliseconds 10^-3 to nanoseconds 10^-9
                        startTime = long_1.default.fromNumber(params.startTime.valueOf()).mul(1000000);
                    }
                    if (params.endTime) {
                        // milliseconds 10^-3 to nanoseconds 10^-9
                        endTime = long_1.default.fromNumber(params.endTime.valueOf()).mul(1000000);
                    }
                    return new HistoryRPC({
                        requestId: (0, uuid_1.v4)(),
                        query: {
                            pubSubTopic: params.pubSubTopic,
                            contentFilters,
                            pagingInfo,
                            startTime,
                            endTime,
                        },
                        response: undefined,
                    }, storeCodec);
                })();
            default:
                throw `Internal Error: Unexpected store codec value received in createQuery: ${storeCodec}`;
        }
    }
    decode(bytes) {
        const res = this.protoCodec.HistoryRPC.decode(minimal_1.Reader.create(bytes));
        return new HistoryRPC(res, this.storeCodec);
    }
    encode() {
        return this.protoCodec.HistoryRPC.encode(this.proto).finish();
    }
}
exports.HistoryRPC = HistoryRPC;
function directionToProto(pageDirection) {
    switch (pageDirection) {
        case PageDirection.BACKWARD:
            return protoV2Beta4.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case PageDirection.FORWARD:
            return protoV2Beta4.PagingInfo_Direction.DIRECTION_FORWARD;
        default:
            return protoV2Beta4.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
    }
}


/***/ }),

/***/ "./src/lib/waku_store/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_store/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodecs = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js");
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const history_rpc_1 = __webpack_require__(/*! ./history_rpc */ "./src/lib/waku_store/history_rpc.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return history_rpc_1.PageDirection; } }));
const dbg = (0, debug_1.default)("waku:store");
var StoreCodecs;
(function (StoreCodecs) {
    StoreCodecs["V2Beta3"] = "/vac/waku/store/2.0.0-beta3";
    StoreCodecs["V2Beta4"] = "/vac/waku/store/2.0.0-beta4";
})(StoreCodecs = exports.StoreCodecs || (exports.StoreCodecs = {}));
exports.DefaultPageSize = 10;
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 *
 * The Waku Store protocol can be used to retrieved historical messages.
 */
class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options?.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
        this.decryptionKeys = new Map();
    }
    /**
     * Do a query to a Waku Store to retrieve historical/missed messages.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     * @param options Optional parameters.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    async queryHistory(contentTopics, options) {
        let startTime, endTime;
        if (options?.timeFilter) {
            startTime = options.timeFilter.startTime;
            endTime = options.timeFilter.endTime;
        }
        const opts = Object.assign({
            pubSubTopic: this.pubSubTopic,
            pageDirection: history_rpc_1.PageDirection.BACKWARD,
            pageSize: exports.DefaultPageSize,
        }, options, { contentTopics, startTime, endTime });
        dbg("Querying history with the following options", {
            peerId: options?.peerId?.toB58String(),
            ...options,
        });
        let peer;
        if (opts.peerId) {
            peer = await this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
        }
        else {
            peer = await this.randomPeer;
            if (!peer)
                throw "Failed to find known peer that registers waku store protocol";
        }
        let storeCodec = "";
        for (const codec of Object.values(StoreCodecs)) {
            if (peer.protocols.includes(codec)) {
                storeCodec = codec;
                // Do not break as we want to keep the last value
            }
        }
        dbg(`Use store codec ${storeCodec}`);
        if (!storeCodec)
            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
        Object.assign(opts, { storeCodec });
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw "Failed to get a connection to the peer";
        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
            return {
                key,
                method,
                contentTopics,
            };
        });
        // Add the decryption keys passed to this function against the
        // content topics also passed to this function.
        if (opts.decryptionKeys) {
            opts.decryptionKeys.forEach((key) => {
                decryptionKeys.push({
                    key: (0, utils_1.hexToBytes)(key),
                    contentTopics: contentTopics.length ? contentTopics : undefined,
                    method: undefined,
                });
            });
        }
        const messages = [];
        let cursor = undefined;
        while (true) {
            const { stream } = await connection.newStream(storeCodec);
            const queryOpts = Object.assign(opts, { cursor });
            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);
            dbg("Querying store peer", connection.remoteAddr.toString());
            const res = await (0, it_pipe_1.pipe)([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            const reply = historyRpcQuery.decode(res.slice());
            const response = reply.response;
            if (!response) {
                throw "History response misses response field";
            }
            if (response.error) {
                throw "History response contains an Error" + response.error;
            }
            if (!response.messages || !response.messages.length) {
                // No messages left (or stored)
                console.log("No messages present in HistoryRPC response");
                return messages;
            }
            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
            const pageMessages = [];
            await Promise.all(response.messages.map(async (protoMsg) => {
                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);
                if (msg) {
                    messages.push(msg);
                    pageMessages.push(msg);
                }
            }));
            let abort = false;
            if (opts.callback) {
                abort = Boolean(opts.callback(pageMessages));
            }
            const responsePageSize = response.pagingInfo?.pageSize;
            const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;
            if (abort ||
                // Response page size smaller than query, meaning this is the last page
                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                return messages;
            }
            cursor = response.pagingInfo?.cursor;
            if (cursor === undefined) {
                // If the server does not return cursor then there is an issue,
                // Need to abort or we end up in an infinite loop
                console.log("No cursor returned by peer.");
                return messages;
            }
        }
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set((0, utils_1.hexToBytes)(key), options ?? {});
    }
    /**cursorV2Beta4
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete((0, utils_1.hexToBytes)(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        const codecs = [];
        for (const codec of Object.values(StoreCodecs)) {
            codecs.push(codec);
        }
        return (0, select_peer_1.getPeersForProtocol)(this.libp2p, codecs);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return (0, select_peer_1.selectRandomPeer)(this.peers);
    }
}
exports.WakuStore = WakuStore;


/***/ }),

/***/ "./src/proto/waku/v2/filter.ts":
/*!*************************************!*\
  !*** ./src/proto/waku/v2/filter.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterRPC = exports.MessagePush = exports.FilterRequest_ContentFilter = exports.FilterRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = "waku.v2";
function createBaseFilterRequest() {
    return { subscribe: false, topic: "", contentFilters: [] };
}
exports.FilterRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.subscribe === true) {
            writer.uint32(8).bool(message.subscribe);
        }
        if (message.topic !== "") {
            writer.uint32(18).string(message.topic);
        }
        for (const v of message.contentFilters) {
            exports.FilterRequest_ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFilterRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subscribe = reader.bool();
                    break;
                case 2:
                    message.topic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.FilterRequest_ContentFilter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,
            topic: isSet(object.topic) ? String(object.topic) : "",
            contentFilters: Array.isArray(object?.contentFilters)
                ? object.contentFilters.map((e) => exports.FilterRequest_ContentFilter.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.subscribe !== undefined && (obj.subscribe = message.subscribe);
        message.topic !== undefined && (obj.topic = message.topic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.FilterRequest_ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFilterRequest();
        message.subscribe = object.subscribe ?? false;
        message.topic = object.topic ?? "";
        message.contentFilters =
            object.contentFilters?.map((e) => exports.FilterRequest_ContentFilter.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFilterRequest_ContentFilter() {
    return { contentTopic: "" };
}
exports.FilterRequest_ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== "") {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFilterRequest_ContentFilter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFilterRequest_ContentFilter();
        message.contentTopic = object.contentTopic ?? "";
        return message;
    },
};
function createBaseMessagePush() {
    return { messages: [] };
}
exports.MessagePush = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessagePush();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: Array.isArray(object?.messages)
                ? object.messages.map((e) => message_1.WakuMessage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMessagePush();
        message.messages =
            object.messages?.map((e) => message_1.WakuMessage.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFilterRPC() {
    return { requestId: "", request: undefined, push: undefined };
}
exports.FilterRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.request !== undefined) {
            exports.FilterRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
        }
        if (message.push !== undefined) {
            exports.MessagePush.encode(message.push, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFilterRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.request = exports.FilterRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.push = exports.MessagePush.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            request: isSet(object.request)
                ? exports.FilterRequest.fromJSON(object.request)
                : undefined,
            push: isSet(object.push) ? exports.MessagePush.fromJSON(object.push) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.request !== undefined &&
            (obj.request = message.request
                ? exports.FilterRequest.toJSON(message.request)
                : undefined);
        message.push !== undefined &&
            (obj.push = message.push ? exports.MessagePush.toJSON(message.push) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseFilterRPC();
        message.requestId = object.requestId ?? "";
        message.request =
            object.request !== undefined && object.request !== null
                ? exports.FilterRequest.fromPartial(object.request)
                : undefined;
        message.push =
            object.push !== undefined && object.push !== null
                ? exports.MessagePush.fromPartial(object.push)
                : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/light_push.ts":
/*!*****************************************!*\
  !*** ./src/proto/waku/v2/light_push.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = exports.PushResponse = exports.PushRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = "waku.v2";
function createBasePushRequest() {
    return { pubSubTopic: "", message: undefined };
}
exports.PushRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== "") {
            writer.uint32(10).string(message.pubSubTopic);
        }
        if (message.message !== undefined) {
            message_1.WakuMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pubSubTopic = reader.string();
                    break;
                case 2:
                    message.message = message_1.WakuMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubSubTopic: isSet(object.pubSubTopic) ? String(object.pubSubTopic) : "",
            message: isSet(object.message)
                ? message_1.WakuMessage.fromJSON(object.message)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        message.message !== undefined &&
            (obj.message = message.message
                ? message_1.WakuMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushRequest();
        message.pubSubTopic = object.pubSubTopic ?? "";
        message.message =
            object.message !== undefined && object.message !== null
                ? message_1.WakuMessage.fromPartial(object.message)
                : undefined;
        return message;
    },
};
function createBasePushResponse() {
    return { isSuccess: false, info: "" };
}
exports.PushResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isSuccess === true) {
            writer.uint32(8).bool(message.isSuccess);
        }
        if (message.info !== "") {
            writer.uint32(18).string(message.info);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isSuccess = reader.bool();
                    break;
                case 2:
                    message.info = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isSuccess: isSet(object.isSuccess) ? Boolean(object.isSuccess) : false,
            info: isSet(object.info) ? String(object.info) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.isSuccess !== undefined && (obj.isSuccess = message.isSuccess);
        message.info !== undefined && (obj.info = message.info);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushResponse();
        message.isSuccess = object.isSuccess ?? false;
        message.info = object.info ?? "";
        return message;
    },
};
function createBasePushRPC() {
    return { requestId: "", request: undefined, response: undefined };
}
exports.PushRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.request !== undefined) {
            exports.PushRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.PushResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.request = exports.PushRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.PushResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            request: isSet(object.request)
                ? exports.PushRequest.fromJSON(object.request)
                : undefined,
            response: isSet(object.response)
                ? exports.PushResponse.fromJSON(object.response)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.request !== undefined &&
            (obj.request = message.request
                ? exports.PushRequest.toJSON(message.request)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.PushResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushRPC();
        message.requestId = object.requestId ?? "";
        message.request =
            object.request !== undefined && object.request !== null
                ? exports.PushRequest.fromPartial(object.request)
                : undefined;
        message.response =
            object.response !== undefined && object.response !== null
                ? exports.PushResponse.fromPartial(object.response)
                : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/message.ts":
/*!**************************************!*\
  !*** ./src/proto/waku/v2/message.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
exports.protobufPackage = "waku.v2";
function createBaseWakuMessage() {
    return {
        payload: undefined,
        contentTopic: undefined,
        version: undefined,
        timestampDeprecated: undefined,
        timestamp: undefined,
    };
}
exports.WakuMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.payload !== undefined) {
            writer.uint32(10).bytes(message.payload);
        }
        if (message.contentTopic !== undefined) {
            writer.uint32(18).string(message.contentTopic);
        }
        if (message.version !== undefined) {
            writer.uint32(24).uint32(message.version);
        }
        if (message.timestampDeprecated !== undefined) {
            writer.uint32(33).double(message.timestampDeprecated);
        }
        if (message.timestamp !== undefined) {
            writer.uint32(80).sint64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWakuMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.contentTopic = reader.string();
                    break;
                case 3:
                    message.version = reader.uint32();
                    break;
                case 4:
                    message.timestampDeprecated = reader.double();
                    break;
                case 10:
                    message.timestamp = reader.sint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            payload: isSet(object.payload)
                ? bytesFromBase64(object.payload)
                : undefined,
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : undefined,
            version: isSet(object.version) ? Number(object.version) : undefined,
            timestampDeprecated: isSet(object.timestampDeprecated)
                ? Number(object.timestampDeprecated)
                : undefined,
            timestamp: isSet(object.timestamp)
                ? long_1.default.fromString(object.timestamp)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.payload !== undefined &&
            (obj.payload =
                message.payload !== undefined
                    ? base64FromBytes(message.payload)
                    : undefined);
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        message.timestampDeprecated !== undefined &&
            (obj.timestampDeprecated = message.timestampDeprecated);
        message.timestamp !== undefined &&
            (obj.timestamp = (message.timestamp || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWakuMessage();
        message.payload = object.payload ?? undefined;
        message.contentTopic = object.contentTopic ?? undefined;
        message.version = object.version ?? undefined;
        message.timestampDeprecated = object.timestampDeprecated ?? undefined;
        message.timestamp =
            object.timestamp !== undefined && object.timestamp !== null
                ? long_1.default.fromValue(object.timestamp)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof __webpack_require__.g !== "undefined")
        return __webpack_require__.g;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/store/v2beta3/store.ts":
/*!**************************************************!*\
  !*** ./src/proto/waku/v2/store/v2beta3/store.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = "waku.v2.store.v2beta3";
var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));
function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case "DIRECTION_BACKWARD_UNSPECIFIED":
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case "DIRECTION_FORWARD":
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
exports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;
function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return "DIRECTION_BACKWARD_UNSPECIFIED";
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return "DIRECTION_FORWARD";
        default:
            return "UNKNOWN";
    }
}
exports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;
var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));
function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case "ERROR_NONE_UNSPECIFIED":
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case "ERROR_INVALID_CURSOR":
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
exports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;
function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return "ERROR_NONE_UNSPECIFIED";
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return "ERROR_INVALID_CURSOR";
        default:
            return "UNKNOWN";
    }
}
exports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;
function createBaseIndex() {
    return { digest: new Uint8Array(), receivedTime: 0, senderTime: 0 };
}
exports.Index = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (message.receivedTime !== 0) {
            writer.uint32(17).double(message.receivedTime);
        }
        if (message.senderTime !== 0) {
            writer.uint32(25).double(message.senderTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIndex();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.double();
                    break;
                case 3:
                    message.senderTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            digest: isSet(object.digest)
                ? bytesFromBase64(object.digest)
                : new Uint8Array(),
            receivedTime: isSet(object.receivedTime)
                ? Number(object.receivedTime)
                : 0,
            senderTime: isSet(object.senderTime) ? Number(object.senderTime) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = message.receivedTime);
        message.senderTime !== undefined && (obj.senderTime = message.senderTime);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIndex();
        message.digest = object.digest ?? new Uint8Array();
        message.receivedTime = object.receivedTime ?? 0;
        message.senderTime = object.senderTime ?? 0;
        return message;
    },
};
function createBasePagingInfo() {
    return { pageSize: long_1.default.UZERO, cursor: undefined, direction: 0 };
}
exports.PagingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.pageSize.isZero()) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePagingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = reader.uint64();
                    break;
                case 2:
                    message.cursor = exports.Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pageSize: isSet(object.pageSize)
                ? long_1.default.fromString(object.pageSize)
                : long_1.default.UZERO,
            cursor: isSet(object.cursor) ? exports.Index.fromJSON(object.cursor) : undefined,
            direction: isSet(object.direction)
                ? pagingInfo_DirectionFromJSON(object.direction)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pageSize !== undefined &&
            (obj.pageSize = (message.pageSize || long_1.default.UZERO).toString());
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePagingInfo();
        message.pageSize =
            object.pageSize !== undefined && object.pageSize !== null
                ? long_1.default.fromValue(object.pageSize)
                : long_1.default.UZERO;
        message.cursor =
            object.cursor !== undefined && object.cursor !== null
                ? exports.Index.fromPartial(object.cursor)
                : undefined;
        message.direction = object.direction ?? 0;
        return message;
    },
};
function createBaseContentFilter() {
    return { contentTopic: "" };
}
exports.ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== "") {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentFilter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContentFilter();
        message.contentTopic = object.contentTopic ?? "";
        return message;
    },
};
function createBaseHistoryQuery() {
    return {
        pubSubTopic: undefined,
        contentFilters: [],
        pagingInfo: undefined,
        startTime: undefined,
        endTime: undefined,
    };
}
exports.HistoryQuery = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (const v of message.contentFilters) {
            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(41).double(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(49).double(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.double();
                    break;
                case 6:
                    message.endTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubSubTopic: isSet(object.pubSubTopic)
                ? String(object.pubSubTopic)
                : undefined,
            contentFilters: Array.isArray(object?.contentFilters)
                ? object.contentFilters.map((e) => exports.ContentFilter.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            startTime: isSet(object.startTime) ? Number(object.startTime) : undefined,
            endTime: isSet(object.endTime) ? Number(object.endTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined && (obj.startTime = message.startTime);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryQuery();
        message.pubSubTopic = object.pubSubTopic ?? undefined;
        message.contentFilters =
            object.contentFilters?.map((e) => exports.ContentFilter.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.startTime = object.startTime ?? undefined;
        message.endTime = object.endTime ?? undefined;
        return message;
    },
};
function createBaseHistoryResponse() {
    return { messages: [], pagingInfo: undefined, error: 0 };
}
exports.HistoryResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: Array.isArray(object?.messages)
                ? object.messages.map((e) => message_1.WakuMessage.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            error: isSet(object.error)
                ? historyResponse_ErrorFromJSON(object.error)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryResponse();
        message.messages =
            object.messages?.map((e) => message_1.WakuMessage.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.error = object.error ?? 0;
        return message;
    },
};
function createBaseHistoryRPC() {
    return { requestId: "", query: undefined, response: undefined };
}
exports.HistoryRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            query: isSet(object.query)
                ? exports.HistoryQuery.fromJSON(object.query)
                : undefined,
            response: isSet(object.response)
                ? exports.HistoryResponse.fromJSON(object.response)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? exports.HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryRPC();
        message.requestId = object.requestId ?? "";
        message.query =
            object.query !== undefined && object.query !== null
                ? exports.HistoryQuery.fromPartial(object.query)
                : undefined;
        message.response =
            object.response !== undefined && object.response !== null
                ? exports.HistoryResponse.fromPartial(object.response)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof __webpack_require__.g !== "undefined")
        return __webpack_require__.g;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/store/v2beta4/store.ts":
/*!**************************************************!*\
  !*** ./src/proto/waku/v2/store/v2beta4/store.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = "waku.v2.store.v2beta4";
var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));
function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case "DIRECTION_BACKWARD_UNSPECIFIED":
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case "DIRECTION_FORWARD":
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
exports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;
function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return "DIRECTION_BACKWARD_UNSPECIFIED";
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return "DIRECTION_FORWARD";
        default:
            return "UNKNOWN";
    }
}
exports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;
var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));
function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case "ERROR_NONE_UNSPECIFIED":
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case "ERROR_INVALID_CURSOR":
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
exports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;
function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return "ERROR_NONE_UNSPECIFIED";
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return "ERROR_INVALID_CURSOR";
        default:
            return "UNKNOWN";
    }
}
exports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;
function createBaseIndex() {
    return {
        digest: new Uint8Array(),
        receivedTime: long_1.default.ZERO,
        senderTime: long_1.default.ZERO,
        pubsubTopic: "",
    };
}
exports.Index = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (!message.receivedTime.isZero()) {
            writer.uint32(16).sint64(message.receivedTime);
        }
        if (!message.senderTime.isZero()) {
            writer.uint32(24).sint64(message.senderTime);
        }
        if (message.pubsubTopic !== "") {
            writer.uint32(34).string(message.pubsubTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIndex();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.sint64();
                    break;
                case 3:
                    message.senderTime = reader.sint64();
                    break;
                case 4:
                    message.pubsubTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            digest: isSet(object.digest)
                ? bytesFromBase64(object.digest)
                : new Uint8Array(),
            receivedTime: isSet(object.receivedTime)
                ? long_1.default.fromString(object.receivedTime)
                : long_1.default.ZERO,
            senderTime: isSet(object.senderTime)
                ? long_1.default.fromString(object.senderTime)
                : long_1.default.ZERO,
            pubsubTopic: isSet(object.pubsubTopic) ? String(object.pubsubTopic) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = (message.receivedTime || long_1.default.ZERO).toString());
        message.senderTime !== undefined &&
            (obj.senderTime = (message.senderTime || long_1.default.ZERO).toString());
        message.pubsubTopic !== undefined &&
            (obj.pubsubTopic = message.pubsubTopic);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIndex();
        message.digest = object.digest ?? new Uint8Array();
        message.receivedTime =
            object.receivedTime !== undefined && object.receivedTime !== null
                ? long_1.default.fromValue(object.receivedTime)
                : long_1.default.ZERO;
        message.senderTime =
            object.senderTime !== undefined && object.senderTime !== null
                ? long_1.default.fromValue(object.senderTime)
                : long_1.default.ZERO;
        message.pubsubTopic = object.pubsubTopic ?? "";
        return message;
    },
};
function createBasePagingInfo() {
    return { pageSize: long_1.default.UZERO, cursor: undefined, direction: 0 };
}
exports.PagingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.pageSize.isZero()) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePagingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = reader.uint64();
                    break;
                case 2:
                    message.cursor = exports.Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pageSize: isSet(object.pageSize)
                ? long_1.default.fromString(object.pageSize)
                : long_1.default.UZERO,
            cursor: isSet(object.cursor) ? exports.Index.fromJSON(object.cursor) : undefined,
            direction: isSet(object.direction)
                ? pagingInfo_DirectionFromJSON(object.direction)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pageSize !== undefined &&
            (obj.pageSize = (message.pageSize || long_1.default.UZERO).toString());
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePagingInfo();
        message.pageSize =
            object.pageSize !== undefined && object.pageSize !== null
                ? long_1.default.fromValue(object.pageSize)
                : long_1.default.UZERO;
        message.cursor =
            object.cursor !== undefined && object.cursor !== null
                ? exports.Index.fromPartial(object.cursor)
                : undefined;
        message.direction = object.direction ?? 0;
        return message;
    },
};
function createBaseContentFilter() {
    return { contentTopic: "" };
}
exports.ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== "") {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentFilter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContentFilter();
        message.contentTopic = object.contentTopic ?? "";
        return message;
    },
};
function createBaseHistoryQuery() {
    return {
        pubSubTopic: undefined,
        contentFilters: [],
        pagingInfo: undefined,
        startTime: undefined,
        endTime: undefined,
    };
}
exports.HistoryQuery = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (const v of message.contentFilters) {
            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(40).sint64(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(48).sint64(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.sint64();
                    break;
                case 6:
                    message.endTime = reader.sint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubSubTopic: isSet(object.pubSubTopic)
                ? String(object.pubSubTopic)
                : undefined,
            contentFilters: Array.isArray(object?.contentFilters)
                ? object.contentFilters.map((e) => exports.ContentFilter.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            startTime: isSet(object.startTime)
                ? long_1.default.fromString(object.startTime)
                : undefined,
            endTime: isSet(object.endTime)
                ? long_1.default.fromString(object.endTime)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined &&
            (obj.startTime = (message.startTime || undefined).toString());
        message.endTime !== undefined &&
            (obj.endTime = (message.endTime || undefined).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryQuery();
        message.pubSubTopic = object.pubSubTopic ?? undefined;
        message.contentFilters =
            object.contentFilters?.map((e) => exports.ContentFilter.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.startTime =
            object.startTime !== undefined && object.startTime !== null
                ? long_1.default.fromValue(object.startTime)
                : undefined;
        message.endTime =
            object.endTime !== undefined && object.endTime !== null
                ? long_1.default.fromValue(object.endTime)
                : undefined;
        return message;
    },
};
function createBaseHistoryResponse() {
    return { messages: [], pagingInfo: undefined, error: 0 };
}
exports.HistoryResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: Array.isArray(object?.messages)
                ? object.messages.map((e) => message_1.WakuMessage.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            error: isSet(object.error)
                ? historyResponse_ErrorFromJSON(object.error)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryResponse();
        message.messages =
            object.messages?.map((e) => message_1.WakuMessage.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.error = object.error ?? 0;
        return message;
    },
};
function createBaseHistoryRPC() {
    return { requestId: "", query: undefined, response: undefined };
}
exports.HistoryRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            query: isSet(object.query)
                ? exports.HistoryQuery.fromJSON(object.query)
                : undefined,
            response: isSet(object.response)
                ? exports.HistoryResponse.fromJSON(object.response)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? exports.HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryRPC();
        message.requestId = object.requestId ?? "";
        message.query =
            object.query !== undefined && object.query !== null
                ? exports.HistoryQuery.fromPartial(object.query)
                : undefined;
        message.response =
            object.response !== undefined && object.response !== null
                ? exports.HistoryResponse.fromPartial(object.response)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof __webpack_require__.g !== "undefined")
        return __webpack_require__.g;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "?18f2":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0b7d":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?25ed":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e4dd":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?887c":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c738":
/*!*************************!*\
  !*** nat-api (ignored) ***!
  \*************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9820":
/*!*************************!*\
  !*** cluster (ignored) ***!
  \*************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7d1a":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b254":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0bda":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"js-waku": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = this["webpackChunkjswaku"] = this["webpackChunkjswaku"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./src/index.ts")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1dDTkE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU0scUJBQXFCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBOzs7OztVRWhEQTtVQUNBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9jcnlwdG8udHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9kaXNjb3ZlcnkvYm9vdHN0cmFwLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5L2Rucy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Rpc2NvdmVyeS9kbnNfb3Zlcl9odHRwcy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Rpc2NvdmVyeS9lbnJ0cmVlLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5L2ZldGNoX25vZGVzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5L2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5L3ByZWRlZmluZWQudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9lbnIvY29uc3RhbnRzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2Vuci50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9rZXlwYWlyL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2tleXBhaXIvc2VjcDI1NmsxLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2tleXBhaXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9lbnIvbXVsdGlhZGRyc19jb2RlYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci90eXBlcy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci92NC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci93YWt1Ml9jb2RlYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3NlbGVjdF9wZWVyLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9maWx0ZXIvZmlsdGVyX3JwYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfZmlsdGVyL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9saWdodF9wdXNoL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9saWdodF9wdXNoL3B1c2hfcnBjLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9tZXNzYWdlL2VjaWVzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9tZXNzYWdlL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9tZXNzYWdlL3N5bW1ldHJpYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbWVzc2FnZS92ZXJzaW9uXzEudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3JlbGF5L2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfcmVsYXkvZ2V0X3JlbGF5X3BlZXJzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9yZWxheS9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfcmVsYXkvcmVsYXlfaGVhcnRiZWF0LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9zdG9yZS9oaXN0b3J5X3JwYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3Vfc3RvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL3Byb3RvL3dha3UvdjIvZmlsdGVyLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9wcm90by93YWt1L3YyL2xpZ2h0X3B1c2gudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL3Byb3RvL3dha3UvdjIvbWVzc2FnZS50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvcHJvdG8vd2FrdS92Mi9zdG9yZS92MmJldGEzL3N0b3JlLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9wcm90by93YWt1L3YyL3N0b3JlL3YyYmV0YTQvc3RvcmUudHMiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJ5b3JjcmFrZW4vc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9Abm9ibGUvZWQyNTUxOS9saWJ8Y3J5cHRvIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2ZyeW9yY3Jha2VuL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWJ8Y3J5cHRvIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2ZyeW9yY3Jha2VuL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3NvdXJjZXxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJ5b3JjcmFrZW4vc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9jbGVhbi1zdGFja3xvcyIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcnlvcmNyYWtlbi9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL2l0LXdzfHdzIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2ZyeW9yY3Jha2VuL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvbGlicDJwL3NyY3xuYXQtYXBpIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2ZyeW9yY3Jha2VuL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvbW9ydGljZS9saWJ8Y2x1c3RlciIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcnlvcmNyYWtlbi9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGlifGJ1ZmZlciIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcnlvcmNyYWtlbi9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGlifGNyeXB0byIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcnlvcmNyYWtlbi9zcmMvc3RhdHVzLWltL2pzLXdha3Uvc3JjL2xpYnxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3J1bnRpbWUvYW1kIG9wdGlvbnMiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9jaHVuayBsb2FkZWQiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImpzd2FrdVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJqc3dha3VcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCJleHBvcnQge1xuICBnZW5lcmF0ZVByaXZhdGVLZXksXG4gIGdlbmVyYXRlU3ltbWV0cmljS2V5LFxuICBnZXRQdWJsaWNLZXksXG59IGZyb20gXCIuL2xpYi9jcnlwdG9cIjtcblxuZXhwb3J0IHsgZ2V0UHJlZGVmaW5lZEJvb3RzdHJhcE5vZGVzIH0gZnJvbSBcIi4vbGliL2Rpc2NvdmVyeVwiO1xuZXhwb3J0ICogYXMgZGlzY292ZXJ5IGZyb20gXCIuL2xpYi9kaXNjb3ZlcnlcIjtcblxuZXhwb3J0ICogYXMgZW5yIGZyb20gXCIuL2xpYi9lbnJcIjtcblxuZXhwb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vbGliL3V0aWxzXCI7XG5cbmV4cG9ydCAqIGFzIHdha3UgZnJvbSBcIi4vbGliL3dha3VcIjtcbmV4cG9ydCB7IFdha3UsIERlZmF1bHRQdWJTdWJUb3BpYywgUHJvdG9jb2xzIH0gZnJvbSBcIi4vbGliL3dha3VcIjtcblxuZXhwb3J0ICogYXMgd2FrdV9tZXNzYWdlIGZyb20gXCIuL2xpYi93YWt1X21lc3NhZ2VcIjtcbmV4cG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSBcIi4vbGliL3dha3VfbWVzc2FnZVwiO1xuXG5leHBvcnQgKiBhcyB3YWt1X2xpZ2h0X3B1c2ggZnJvbSBcIi4vbGliL3dha3VfbGlnaHRfcHVzaFwiO1xuZXhwb3J0IHtcbiAgV2FrdUxpZ2h0UHVzaCxcbiAgTGlnaHRQdXNoQ29kZWMsXG4gIFB1c2hSZXNwb25zZSxcbn0gZnJvbSBcIi4vbGliL3dha3VfbGlnaHRfcHVzaFwiO1xuXG5leHBvcnQgKiBhcyB3YWt1X3JlbGF5IGZyb20gXCIuL2xpYi93YWt1X3JlbGF5XCI7XG5leHBvcnQgeyBXYWt1UmVsYXksIFJlbGF5Q29kZWNzIH0gZnJvbSBcIi4vbGliL3dha3VfcmVsYXlcIjtcblxuZXhwb3J0ICogYXMgd2FrdV9zdG9yZSBmcm9tIFwiLi9saWIvd2FrdV9zdG9yZVwiO1xuZXhwb3J0IHsgUGFnZURpcmVjdGlvbiwgV2FrdVN0b3JlLCBTdG9yZUNvZGVjcyB9IGZyb20gXCIuL2xpYi93YWt1X3N0b3JlXCI7XG4iLCJpbXBvcnQgbm9kZUNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmltcG9ydCAqIGFzIHNlY3AgZnJvbSBcIkBub2JsZS9zZWNwMjU2azFcIjtcbmltcG9ydCAqIGFzIHNoYTMgZnJvbSBcImpzLXNoYTNcIjtcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCJ1aW50OGFycmF5cy9jb25jYXRcIjtcblxuaW1wb3J0ICogYXMgc3ltbWV0cmljIGZyb20gXCIuL3dha3VfbWVzc2FnZS9zeW1tZXRyaWNcIjtcbmltcG9ydCB7IFByaXZhdGVLZXlTaXplIH0gZnJvbSBcIi4vd2FrdV9tZXNzYWdlL3ZlcnNpb25fMVwiO1xuXG5kZWNsYXJlIGNvbnN0IHNlbGY6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG5jb25zdCBjcnlwdG86IHsgbm9kZT86IGFueTsgd2ViPzogYW55IH0gPSB7XG4gIG5vZGU6IG5vZGVDcnlwdG8sXG4gIHdlYjogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VidGxlKCk6IFN1YnRsZUNyeXB0byB7XG4gIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgcmV0dXJuIGNyeXB0by53ZWIuc3VidGxlO1xuICB9IGVsc2UgaWYgKGNyeXB0by5ub2RlKSB7XG4gICAgcmV0dXJuIGNyeXB0by5ub2RlLndlYmNyeXB0by5zdWJ0bGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIENyeXB0byBTdWJ0bGUgQVBJIChpZiBpbiB0aGUgYnJvd3NlciwgYmUgc3VyZSB0byB1c2UgdG8gYmUgaW4gYSBzZWN1cmUgY29udGV4dCwgaWUsIGh0dHBzKVwiXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmFuZG9tQnl0ZXMgPSBzZWNwLnV0aWxzLnJhbmRvbUJ5dGVzO1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHNlY3AudXRpbHMuc2hhMjU2O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHByaXZhdGUga2V5IHRvIGJlIHVzZWQgZm9yIGFzeW1tZXRyaWMgZW5jcnlwdGlvbi5cbiAqXG4gKiBVc2Uge0BsaW5rIGdldFB1YmxpY0tleX0gdG8gZ2V0IHRoZSBjb3JyZXNwb25kaW5nIFB1YmxpYyBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVByaXZhdGVLZXkoKTogVWludDhBcnJheSB7XG4gIHJldHVybiByYW5kb21CeXRlcyhQcml2YXRlS2V5U2l6ZSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBuZXcgc3ltbWV0cmljIGtleSB0byBiZSB1c2VkIGZvciBzeW1tZXRyaWMgZW5jcnlwdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3ltbWV0cmljS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoc3ltbWV0cmljLktleVNpemUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHByaXZhdGUga2V5LCB0byBiZSB1c2VkIGZvciBhc3ltbWV0cmljXG4gKiBlbmNyeXB0aW9uLlxuICovXG5leHBvcnQgY29uc3QgZ2V0UHVibGljS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXk7XG5cbi8qKlxuICogRUNEU0EgU2lnbiBhIG1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKlxuICogIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNpZ24sIHVzdWFsbHkgYSBoYXNoLlxuICogIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBFQ0RTQSBwcml2YXRlIGtleSB0byB1c2UgdG8gc2lnbiB0aGUgbWVzc2FnZS5cbiAqXG4gKiAgQHJldHVybnMgVGhlIHNpZ25hdHVyZSBhbmQgdGhlIHJlY292ZXJ5IGlkIGNvbmNhdGVuYXRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ24oXG4gIG1lc3NhZ2U6IFVpbnQ4QXJyYXksXG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXlcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGF3YWl0IHNlY3Auc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCB7XG4gICAgcmVjb3ZlcmVkOiB0cnVlLFxuICAgIGRlcjogZmFsc2UsXG4gIH0pO1xuICByZXR1cm4gY29uY2F0KFtzaWduYXR1cmUsIFtyZWNvdmVyeUlkXV0sIHNpZ25hdHVyZS5sZW5ndGggKyAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihpbnB1dDogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2hhMy5rZWNjYWsyNTYuYXJyYXlCdWZmZXIoaW5wdXQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzUHVibGljS2V5KHB1YmxpY0tleTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICBwdWJsaWNLZXkgPSBjb25jYXQoW1s0XSwgcHVibGljS2V5XSwgNjUpO1xuICB9XG4gIGNvbnN0IHBvaW50ID0gc2VjcC5Qb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gIHJldHVybiBwb2ludC50b1Jhd0J5dGVzKHRydWUpO1xufVxuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUoXG4gIHNpZ25hdHVyZTogVWludDhBcnJheSxcbiAgbWVzc2FnZTogVWludDhBcnJheSB8IHN0cmluZyxcbiAgcHVibGljS2V5OiBVaW50OEFycmF5XG4pOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBfc2lnbmF0dXJlID0gc2VjcC5TaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlLnNsaWNlKDAsIDY0KSk7XG4gICAgcmV0dXJuIHNlY3AudmVyaWZ5KF9zaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSBcIm11bHRpYWRkclwiO1xuXG5pbXBvcnQgeyBEbnNOb2RlRGlzY292ZXJ5LCBOb2RlQ2FwYWJpbGl0eUNvdW50IH0gZnJvbSBcIi4vZG5zXCI7XG5cbmltcG9ydCB7IGdldFByZWRlZmluZWRCb290c3RyYXBOb2RlcywgZ2V0UHNldWRvUmFuZG9tU3Vic2V0IH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuY29uc3QgZGJnID0gZGVidWcoXCJ3YWt1OmRpc2NvdmVyeTpib290c3RyYXBcIik7XG5cbi8qKlxuICogU2V0dXAgZGlzY292ZXJ5IG1ldGhvZCB1c2VkIHRvIGJvb3RzdHJhcC5cbiAqXG4gKiBPbmx5IG9uZSBtZXRob2QgaXMgdXNlZC4gW1tkZWZhdWx0XV0sIFtbcGVlcnNdXSwgW1tnZXRQZWVyc11dIGFuZCBbW2VuclVybF1dIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCb290c3RyYXBPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG9mIHBlZXJzIHRvIGNvbm5lY3QgdG8gYXMgcGFydCBvZiB0aGUgYm9vdHN0cmFwIHByb2Nlc3MuXG4gICAqIFRoaXMgb25seSBhcHBsaWVzIGlmIFtbcGVlcnNdXSBvciBbW2dldFBlZXJzXV0gaXMgdXNlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgW1tCb290c3RyYXAuRGVmYXVsdE1heFBlZXJzXV1cbiAgICovXG4gIG1heFBlZXJzPzogbnVtYmVyO1xuICAvKipcbiAgICogVXNlIHRoZSBkZWZhdWx0IGRpc2NvdmVyeSBtZXRob2QuIE92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBidXQgYG1heFBlZXJzYFxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBkaXNjb3ZlcnkgbWV0aG9kIGlzIGxpa2VseSB0byBjaGFuZ2Ugb3ZlcnRpbWUgYXMgbmV3IGRpc2NvdmVyeVxuICAgKiBtZXRob2RzIGFyZSBpbXBsZW1lbnRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZmF1bHQ/OiBib29sZWFuO1xuICAvKipcbiAgICogTXVsdGlhZGRycyBvZiBwZWVycyB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgcGVlcnM/OiBzdHJpbmdbXSB8IE11bHRpYWRkcltdO1xuICAvKipcbiAgICogR2V0dGVyIHRoYXQgcmV0cmlldmUgbXVsdGlhZGRycyBvZiBwZWVycyB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgZ2V0UGVlcnM/OiAoKSA9PiBQcm9taXNlPHN0cmluZ1tdIHwgTXVsdGlhZGRyW10+O1xuICAvKipcbiAgICogQW4gRUlQLTE0NTkgRU5SIFRyZWUgVVJMLiBGb3IgZXhhbXBsZTpcbiAgICogXCJlbnJ0cmVlOi8vQU9GVElDVTJYV0RVTE5MWkdSTVFTNFJJWlBBWkVIWU1WNEZZSEFQVzU2M0hOUkFPRVJQN0NAdGVzdC5ub2Rlcy52YWMuZGV2XCJcbiAgICpcbiAgICogW1t3YW50ZWROb2RlQ2FwYWJpbGl0eUNvdW50XV0gTVVTVCBiZSBwYXNzZWQgd2hlbiB1c2luZyB0aGlzIG9wdGlvbi5cbiAgICovXG4gIGVuclVybD86IHN0cmluZztcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IG5vZGUgY2FwYWJpbGl0aWVzIChwcm90b2NvbCkgbXVzdCBiZSByZXR1cm5lZC5cbiAgICogVGhpcyBvbmx5IGFwcGxpZXMgd2hlbiBbW2VuclVybF1dIGlzIHBhc3NlZCAoRUlQLTE0NTkgRE5TIERpc2NvdmVyeSkuXG4gICAqL1xuICB3YW50ZWROb2RlQ2FwYWJpbGl0eUNvdW50PzogUGFydGlhbDxOb2RlQ2FwYWJpbGl0eUNvdW50Pjtcbn1cblxuLyoqXG4gKiBQYXJzZSBvcHRpb25zIGFuZCBleHBvc2UgZnVuY3Rpb24gdG8gcmV0dXJuIGJvb3RzdHJhcCBwZWVyIGFkZHJlc3Nlcy5cbiAqXG4gKiBAdGhyb3dzIGlmIGFuIGludmFsaWQgY29tYmluYXRpb24gb2Ygb3B0aW9ucyBpcyBwYXNzZWQsIHNlZSBbW0Jvb3RzdHJhcE9wdGlvbnNdXSBmb3IgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcCB7XG4gIHB1YmxpYyBzdGF0aWMgRGVmYXVsdE1heFBlZXJzID0gMTtcblxuICBwdWJsaWMgcmVhZG9ubHkgZ2V0Qm9vdHN0cmFwUGVlcnM6ICgoKSA9PiBQcm9taXNlPE11bHRpYWRkcltdPikgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0czogQm9vdHN0cmFwT3B0aW9ucykge1xuICAgIGNvbnN0IG1heFBlZXJzID0gb3B0cy5tYXhQZWVycyA/PyBCb290c3RyYXAuRGVmYXVsdE1heFBlZXJzO1xuXG4gICAgaWYgKG9wdHMuZGVmYXVsdCkge1xuICAgICAgZGJnKFwiVXNlIGhvc3RlZCBsaXN0IG9mIHBlZXJzLlwiKTtcblxuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9ICgpOiBQcm9taXNlPE11bHRpYWRkcltdPiA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgZ2V0UHJlZGVmaW5lZEJvb3RzdHJhcE5vZGVzKHVuZGVmaW5lZCwgbWF4UGVlcnMpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5wZWVycyAhPT0gdW5kZWZpbmVkICYmIG9wdHMucGVlcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWxsUGVlcnM6IE11bHRpYWRkcltdID0gb3B0cy5wZWVycy5tYXAoXG4gICAgICAgIChub2RlOiBzdHJpbmcgfCBNdWx0aWFkZHIpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBwZWVycyA9IGdldFBzZXVkb1JhbmRvbVN1YnNldChhbGxQZWVycywgbWF4UGVlcnMpO1xuICAgICAgZGJnKFxuICAgICAgICBcIlVzZSBwcm92aWRlZCBsaXN0IG9mIHBlZXJzIChyZWR1Y2VkIHRvIG1heFBlZXJzKVwiLFxuICAgICAgICBhbGxQZWVycy5tYXAoKG1hKSA9PiBtYS50b1N0cmluZygpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZ2V0Qm9vdHN0cmFwUGVlcnMgPSAoKTogUHJvbWlzZTxNdWx0aWFkZHJbXT4gPT5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHBlZXJzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmdldFBlZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRiZyhcIkJvb3RzdHJhcDogVXNlIHByb3ZpZGVkIGdldFBlZXJzIGZ1bmN0aW9uLlwiKTtcbiAgICAgIGNvbnN0IGdldFBlZXJzID0gb3B0cy5nZXRQZWVycztcblxuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9IGFzeW5jICgpOiBQcm9taXNlPE11bHRpYWRkcltdPiA9PiB7XG4gICAgICAgIGNvbnN0IGFsbFBlZXJzID0gYXdhaXQgZ2V0UGVlcnMoKTtcbiAgICAgICAgcmV0dXJuIGdldFBzZXVkb1JhbmRvbVN1YnNldDxzdHJpbmcgfCBNdWx0aWFkZHI+KFxuICAgICAgICAgIGFsbFBlZXJzLFxuICAgICAgICAgIG1heFBlZXJzXG4gICAgICAgICkubWFwKChub2RlKSA9PiBuZXcgTXVsdGlhZGRyKG5vZGUpKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmVuclVybCkge1xuICAgICAgY29uc3Qgd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudCA9IG9wdHMud2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudDtcbiAgICAgIGlmICghd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudClcbiAgICAgICAgdGhyb3cgXCJgd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudGAgbXVzdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgYGVuclVybGBcIjtcbiAgICAgIGNvbnN0IGVuclVybCA9IG9wdHMuZW5yVXJsO1xuICAgICAgZGJnKFwiVXNlIHByb3ZpZGVkIEVJUC0xNDU5IEVOUiBUcmVlIFVSTC5cIik7XG5cbiAgICAgIGNvbnN0IGRucyA9IERuc05vZGVEaXNjb3ZlcnkuZG5zT3Zlckh0dHAoKTtcblxuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9IGFzeW5jICgpOiBQcm9taXNlPE11bHRpYWRkcltdPiA9PiB7XG4gICAgICAgIGNvbnN0IGVucnMgPSBhd2FpdCBkbnMuZ2V0UGVlcnMoW2VuclVybF0sIHdhbnRlZE5vZGVDYXBhYmlsaXR5Q291bnQpO1xuICAgICAgICBkYmcoYEZvdW5kICR7ZW5ycy5sZW5ndGh9IHBlZXJzYCk7XG4gICAgICAgIHJldHVybiBlbnJzLm1hcCgoZW5yKSA9PiBlbnIuZ2V0RnVsbE11bHRpYWRkcnMoKSkuZmxhdCgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGJnKFwiTm8gYm9vdHN0cmFwIG1ldGhvZCBzcGVjaWZpZWQsIG5vIHBlZXIgd2lsbCBiZSByZXR1cm5lZFwiKTtcbiAgICAgIHRoaXMuZ2V0Qm9vdHN0cmFwUGVlcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBkZWJ1ZyB9IGZyb20gXCJkZWJ1Z1wiO1xuXG5pbXBvcnQgeyBFTlIgfSBmcm9tIFwiLi4vZW5yXCI7XG5cbmltcG9ydCB7IERuc092ZXJIdHRwcywgRW5kcG9pbnRzIH0gZnJvbSBcIi4vZG5zX292ZXJfaHR0cHNcIjtcbmltcG9ydCB7IEVOUlRyZWUgfSBmcm9tIFwiLi9lbnJ0cmVlXCI7XG5pbXBvcnQgZmV0Y2hOb2Rlc1VudGlsQ2FwYWJpbGl0aWVzRnVsZmlsbGVkIGZyb20gXCIuL2ZldGNoX25vZGVzXCI7XG5cbmNvbnN0IGRiZyA9IGRlYnVnKFwid2FrdTpkaXNjb3Zlcnk6ZG5zXCIpO1xuXG5leHBvcnQgdHlwZSBTZWFyY2hDb250ZXh0ID0ge1xuICBkb21haW46IHN0cmluZztcbiAgcHVibGljS2V5OiBzdHJpbmc7XG4gIHZpc2l0czogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH07XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIERuc0NsaWVudCB7XG4gIHJlc29sdmVUWFQ6IChkb21haW46IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmdbXT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZUNhcGFiaWxpdHlDb3VudCB7XG4gIHJlbGF5OiBudW1iZXI7XG4gIHN0b3JlOiBudW1iZXI7XG4gIGZpbHRlcjogbnVtYmVyO1xuICBsaWdodFB1c2g6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIERuc05vZGVEaXNjb3Zlcnkge1xuICBwcml2YXRlIHJlYWRvbmx5IGRuczogRG5zQ2xpZW50O1xuICBwcml2YXRlIHJlYWRvbmx5IF9ETlNUcmVlQ2FjaGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHByaXZhdGUgcmVhZG9ubHkgX2Vycm9yVG9sZXJhbmNlOiBudW1iZXIgPSAxMDtcblxuICBwdWJsaWMgc3RhdGljIGRuc092ZXJIdHRwKGVuZHBvaW50cz86IEVuZHBvaW50cyk6IERuc05vZGVEaXNjb3Zlcnkge1xuICAgIGNvbnN0IGRuc0NsaWVudCA9IG5ldyBEbnNPdmVySHR0cHMoZW5kcG9pbnRzKTtcbiAgICByZXR1cm4gbmV3IERuc05vZGVEaXNjb3ZlcnkoZG5zQ2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZXJpZmllZCBwZWVycyBsaXN0ZWQgaW4gYW4gRUlQLTE0NTkgRE5TIHRyZWUuIE1ldGhvZCBtYXlcbiAgICogcmV0dXJuIGZld2VyIHBlZXJzIHRoYW4gcmVxdWVzdGVkIGlmIFtbd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudF1dIHJlcXVpcmVzXG4gICAqIGxhcmdlciBxdWFudGl0eSBvZiBwZWVycyB0aGFuIGF2YWlsYWJsZSBvciB0aGUgbnVtYmVyIG9mIGVycm9ycy9kdXBsaWNhdGVcbiAgICogcGVlcnMgZW5jb3VudGVyZWQgYnkgcmFuZG9taXplZCBzZWFyY2ggZXhjZWVkcyB0aGUgc3VtIG9mIHRoZSBmaWVsZHMgb2ZcbiAgICogW1t3YW50ZWROb2RlQ2FwYWJpbGl0eUNvdW50XV0gcGx1cyB0aGUgW1tfZXJyb3JUb2xlcmFuY2VdXSBmYWN0b3IuXG4gICAqL1xuICBhc3luYyBnZXRQZWVycyhcbiAgICBlbnJUcmVlVXJsczogc3RyaW5nW10sXG4gICAgd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudDogUGFydGlhbDxOb2RlQ2FwYWJpbGl0eUNvdW50PlxuICApOiBQcm9taXNlPEVOUltdPiB7XG4gICAgY29uc3QgbmV0d29ya0luZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZW5yVHJlZVVybHMubGVuZ3RoKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleSwgZG9tYWluIH0gPSBFTlJUcmVlLnBhcnNlVHJlZShlbnJUcmVlVXJsc1tuZXR3b3JrSW5kZXhdKTtcbiAgICBjb25zdCBjb250ZXh0OiBTZWFyY2hDb250ZXh0ID0ge1xuICAgICAgZG9tYWluLFxuICAgICAgcHVibGljS2V5LFxuICAgICAgdmlzaXRzOiB7fSxcbiAgICB9O1xuXG4gICAgY29uc3QgcGVlcnMgPSBhd2FpdCBmZXRjaE5vZGVzVW50aWxDYXBhYmlsaXRpZXNGdWxmaWxsZWQoXG4gICAgICB3YW50ZWROb2RlQ2FwYWJpbGl0eUNvdW50LFxuICAgICAgdGhpcy5fZXJyb3JUb2xlcmFuY2UsXG4gICAgICAoKSA9PiB0aGlzLl9zZWFyY2goZG9tYWluLCBjb250ZXh0KVxuICAgICk7XG4gICAgZGJnKFwicmV0cmlldmVkIHBlZXJzOiBcIiwgcGVlcnMpO1xuICAgIHJldHVybiBwZWVycztcbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihkbnM6IERuc0NsaWVudCkge1xuICAgIHRoaXMuX0ROU1RyZWVDYWNoZSA9IHt9O1xuICAgIHRoaXMuZG5zID0gZG5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSByZWN1cnNpdmUsIHJhbmRvbWl6ZWQgZGVzY2VudCBvZiB0aGUgRE5TIHRyZWUgdG8gcmV0cmlldmUgYSBzaW5nbGVcbiAgICogRU5SIHJlY29yZCBhcyBhbiBFTlIuIFJldHVybnMgbnVsbCBpZiBwYXJzaW5nIG9yIEROUyByZXNvbHV0aW9uIGZhaWxzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc2VhcmNoKFxuICAgIHN1YmRvbWFpbjogc3RyaW5nLFxuICAgIGNvbnRleHQ6IFNlYXJjaENvbnRleHRcbiAgKTogUHJvbWlzZTxFTlIgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdGhpcy5fZ2V0VFhUUmVjb3JkKHN1YmRvbWFpbiwgY29udGV4dCk7XG4gICAgICBjb250ZXh0LnZpc2l0c1tzdWJkb21haW5dID0gdHJ1ZTtcblxuICAgICAgbGV0IG5leHQ6IHN0cmluZztcbiAgICAgIGxldCBicmFuY2hlczogc3RyaW5nW107XG5cbiAgICAgIGNvbnN0IGVudHJ5VHlwZSA9IGdldEVudHJ5VHlwZShlbnRyeSk7XG4gICAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGVudHJ5VHlwZSkge1xuICAgICAgICAgIGNhc2UgRU5SVHJlZS5ST09UX1BSRUZJWDpcbiAgICAgICAgICAgIG5leHQgPSBFTlJUcmVlLnBhcnNlQW5kVmVyaWZ5Um9vdChlbnRyeSwgY29udGV4dC5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NlYXJjaChuZXh0LCBjb250ZXh0KTtcbiAgICAgICAgICBjYXNlIEVOUlRyZWUuQlJBTkNIX1BSRUZJWDpcbiAgICAgICAgICAgIGJyYW5jaGVzID0gRU5SVHJlZS5wYXJzZUJyYW5jaChlbnRyeSk7XG4gICAgICAgICAgICBuZXh0ID0gc2VsZWN0UmFuZG9tUGF0aChicmFuY2hlcywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2VhcmNoKG5leHQsIGNvbnRleHQpO1xuICAgICAgICAgIGNhc2UgRU5SVHJlZS5SRUNPUkRfUFJFRklYOlxuICAgICAgICAgICAgcmV0dXJuIEVOUi5kZWNvZGVUeHQoZW50cnkpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGJnKFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2VhcmNoIEROUyB0cmVlICR7ZW50cnlUeXBlfSBhdCBzdWJkb21haW4gJHtzdWJkb21haW59OiAke2Vycm9yfWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRiZyhgRmFpbGVkIHRvIHJldHJpZXZlIFRYVCByZWNvcmQgYXQgc3ViZG9tYWluICR7c3ViZG9tYWlufTogJHtlcnJvcn1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIFRYVCByZWNvcmQgc3RvcmVkIGF0IGEgbG9jYXRpb24gZnJvbSBlaXRoZXJcbiAgICogdGhpcyBETlMgdHJlZSBjYWNoZSBvciB2aWEgRE5TIHF1ZXJ5LlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIHRoZSBUWFQgUmVjb3JkIGNvbnRhaW5zIG5vbi1VVEYtOCB2YWx1ZXMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRUWFRSZWNvcmQoXG4gICAgc3ViZG9tYWluOiBzdHJpbmcsXG4gICAgY29udGV4dDogU2VhcmNoQ29udGV4dFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLl9ETlNUcmVlQ2FjaGVbc3ViZG9tYWluXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX0ROU1RyZWVDYWNoZVtzdWJkb21haW5dO1xuICAgIH1cblxuICAgIC8vIExvY2F0aW9uIGlzIGVpdGhlciB0aGUgdG9wIGxldmVsIHRyZWUgZW50cnkgaG9zdCBvciBhIHN1YmRvbWFpbiBvZiBpdC5cbiAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICBzdWJkb21haW4gIT09IGNvbnRleHQuZG9tYWluXG4gICAgICAgID8gYCR7c3ViZG9tYWlufS4ke2NvbnRleHQuZG9tYWlufWBcbiAgICAgICAgOiBjb250ZXh0LmRvbWFpbjtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kbnMucmVzb2x2ZVRYVChsb2NhdGlvbik7XG5cbiAgICBpZiAoIXJlc3BvbnNlLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGVtcHR5IHJlc3VsdCBhcnJheSB3aGlsZSBmZXRjaGluZyBUWFQgcmVjb3JkXCIpO1xuICAgIGlmICghcmVzcG9uc2VbMF0ubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlZCBlbXB0eSBUWFQgcmVjb3JkXCIpO1xuXG4gICAgLy8gQnJhbmNoIGVudHJpZXMgY2FuIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgY29tbWEgZGVsaW1pdGVkIHN1YmRvbWFpbnMsIHdpdGhcbiAgICAvLyBzb21lIHN1YmRvbWFpbiBzdHJpbmdzIHNwbGl0IGFjcm9zcyB0aGUgYXJyYXkgZWxlbWVudHNcbiAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5qb2luKFwiXCIpO1xuXG4gICAgdGhpcy5fRE5TVHJlZUNhY2hlW3N1YmRvbWFpbl0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbnRyeVR5cGUoZW50cnk6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChlbnRyeS5zdGFydHNXaXRoKEVOUlRyZWUuUk9PVF9QUkVGSVgpKSByZXR1cm4gRU5SVHJlZS5ST09UX1BSRUZJWDtcbiAgaWYgKGVudHJ5LnN0YXJ0c1dpdGgoRU5SVHJlZS5CUkFOQ0hfUFJFRklYKSkgcmV0dXJuIEVOUlRyZWUuQlJBTkNIX1BSRUZJWDtcbiAgaWYgKGVudHJ5LnN0YXJ0c1dpdGgoRU5SVHJlZS5SRUNPUkRfUFJFRklYKSkgcmV0dXJuIEVOUlRyZWUuUkVDT1JEX1BSRUZJWDtcblxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQgc3ViZG9tYWluIHN0cmluZyBmcm9tIHRoZSBsaXN0IHByb3ZpZGVkIGJ5IGEgYnJhbmNoXG4gKiBlbnRyeSByZWNvcmQuXG4gKlxuICogVGhlIGNsaWVudCBtdXN0IHRyYWNrIHN1YmRvbWFpbnMgd2hpY2ggYXJlIGFscmVhZHkgcmVzb2x2ZWQgdG8gYXZvaWRcbiAqIGdvaW5nIGludG8gYW4gaW5maW5pdGUgbG9vcCBiL2MgYnJhbmNoIGVudHJpZXMgY2FuIGNvbnRhaW5cbiAqIGNpcmN1bGFyIHJlZmVyZW5jZXMuIEl04oCZcyBpbiB0aGUgY2xpZW504oCZcyBiZXN0IGludGVyZXN0IHRvIHRyYXZlcnNlIHRoZVxuICogdHJlZSBpbiByYW5kb20gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdFJhbmRvbVBhdGgoYnJhbmNoZXM6IHN0cmluZ1tdLCBjb250ZXh0OiBTZWFyY2hDb250ZXh0KTogc3RyaW5nIHtcbiAgLy8gSWRlbnRpZnkgZG9tYWlucyBhbHJlYWR5IHZpc2l0ZWQgaW4gdGhpcyB0cmF2ZXJzYWwgb2YgdGhlIEROUyB0cmVlLlxuICAvLyBUaGVuIGZpbHRlciBhZ2FpbnN0IHRoZW0gdG8gcHJldmVudCBjeWNsZXMuXG4gIGNvbnN0IGNpcmN1bGFyUmVmczogeyBba2V5OiBudW1iZXJdOiBib29sZWFuIH0gPSB7fTtcbiAgZm9yIChjb25zdCBbaWR4LCBzdWJkb21haW5dIG9mIGJyYW5jaGVzLmVudHJpZXMoKSkge1xuICAgIGlmIChjb250ZXh0LnZpc2l0c1tzdWJkb21haW5dKSB7XG4gICAgICBjaXJjdWxhclJlZnNbaWR4XSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIElmIGFsbCBwb3NzaWJsZSBwYXRocyBhcmUgY2lyY3VsYXIuLi5cbiAgaWYgKE9iamVjdC5rZXlzKGNpcmN1bGFyUmVmcykubGVuZ3RoID09PSBicmFuY2hlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlc29sdmFibGUgY2lyY3VsYXIgcGF0aCBkZXRlY3RlZFwiKTtcbiAgfVxuXG4gIC8vIFJhbmRvbWx5IHNlbGVjdCBhIHZpYWJsZSBwYXRoXG4gIGxldCBpbmRleDtcbiAgZG8ge1xuICAgIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYnJhbmNoZXMubGVuZ3RoKTtcbiAgfSB3aGlsZSAoY2lyY3VsYXJSZWZzW2luZGV4XSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzW2luZGV4XTtcbn1cbiIsImltcG9ydCB7IFR4dEFuc3dlciB9IGZyb20gXCJkbnMtcGFja2V0XCI7XG5pbXBvcnQge1xuICBlbmRwb2ludHMgYXMgZGVmYXVsdEVuZHBvaW50cyxcbiAgRW5kcG9pbnQsXG4gIEVuZHBvaW50UHJvcHMsXG4gIHF1ZXJ5LFxufSBmcm9tIFwiZG5zLXF1ZXJ5XCI7XG5cbmltcG9ydCB7IGJ5dGVzVG9VdGY4IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCB7IERuc0NsaWVudCB9IGZyb20gXCIuL2Ruc1wiO1xuXG5jb25zdCB7IGNsb3VkZmxhcmUsIGdvb2dsZSwgb3BlbmRucyB9ID0gZGVmYXVsdEVuZHBvaW50cztcblxuZXhwb3J0IHR5cGUgRW5kcG9pbnRzID1cbiAgfCBcImRvaFwiXG4gIHwgXCJkbnNcIlxuICB8IEl0ZXJhYmxlPEVuZHBvaW50IHwgRW5kcG9pbnRQcm9wcyB8IHN0cmluZz47XG5cbmV4cG9ydCBjbGFzcyBEbnNPdmVySHR0cHMgaW1wbGVtZW50cyBEbnNDbGllbnQge1xuICAvKipcbiAgICogQ3JlYXRlIG5ldyBEbnMtT3Zlci1IdHRwIEROUyBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludHMgVGhlIGVuZHBvaW50cyBmb3IgRG5zLU92ZXItSHR0cHMgcXVlcmllcy5cbiAgICogU2VlIFtkbnMtcXVlcnldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Rucy1xdWVyeSkgZm9yIGRldGFpbHMuXG4gICAqIERlZmF1bHRzIHRvIGNsb3VkZmxhcmUsIGdvb2dsZSBhbmQgb3BlbmRucy5cbiAgICpcbiAgICogQHRocm93cyB7Y29kZTogc3RyaW5nfSBJZiBETlMgcXVlcnkgZmFpbHMuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGVuZHBvaW50czogRW5kcG9pbnRzID0gW2Nsb3VkZmxhcmUsIGdvb2dsZSwgb3BlbmRuc11cbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFRYVCByZWNvcmRcbiAgICpcbiAgICogQHBhcmFtIGRvbWFpbiBUaGUgZG9tYWluIG5hbWVcbiAgICpcbiAgICogQHRocm93cyBpZiB0aGUgcmVzdWx0IGlzIHByb3ZpZGVkIGluIGJ5dGUgZm9ybSB3aGljaCBjYW5ub3QgYmUgZGVjb2RlZFxuICAgKiB0byBVVEYtOFxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZVRYVChkb21haW46IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHF1ZXJ5KHtcbiAgICAgIHF1ZXN0aW9uczogW3sgdHlwZTogXCJUWFRcIiwgbmFtZTogZG9tYWluIH1dLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYW5zd2VycyA9IHJlc3BvbnNlLmFuc3dlcnMgYXMgVHh0QW5zd2VyW107XG5cbiAgICBjb25zdCBkYXRhID0gYW5zd2Vycy5tYXAoKGEpID0+IGEuZGF0YSk7XG5cbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgICBkYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgICBkLmZvckVhY2goKHNkKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChieXRlc1RvVXRmOChzZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1RvVXRmOChkKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBiYXNlMzIgZnJvbSBcImhpLWJhc2UzMlwiO1xuaW1wb3J0IHsgZnJvbVN0cmluZyB9IGZyb20gXCJ1aW50OGFycmF5cy9mcm9tLXN0cmluZ1wiO1xuXG5pbXBvcnQgeyBrZWNjYWsyNTYsIHZlcmlmeVNpZ25hdHVyZSB9IGZyb20gXCIuLi9jcnlwdG9cIjtcbmltcG9ydCB7IEVOUiB9IGZyb20gXCIuLi9lbnJcIjtcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmV4cG9ydCB0eXBlIEVOUlJvb3RWYWx1ZXMgPSB7XG4gIGVSb290OiBzdHJpbmc7XG4gIGxSb290OiBzdHJpbmc7XG4gIHNlcTogbnVtYmVyO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEVOUlRyZWVWYWx1ZXMgPSB7XG4gIHB1YmxpY0tleTogc3RyaW5nO1xuICBkb21haW46IHN0cmluZztcbn07XG5cbmV4cG9ydCBjbGFzcyBFTlJUcmVlIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBSRUNPUkRfUFJFRklYID0gRU5SLlJFQ09SRF9QUkVGSVg7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVFJFRV9QUkVGSVggPSBcImVucnRyZWU6XCI7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQlJBTkNIX1BSRUZJWCA9IFwiZW5ydHJlZS1icmFuY2g6XCI7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUk9PVF9QUkVGSVggPSBcImVucnRyZWUtcm9vdDpcIjtcblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGJyYW5jaCBzdWJkb21haW4gcmVmZXJlbmNlZCBieSBhIEROUyB0cmVlIHJvb3Qgc3RyaW5nIGFmdGVyIHZlcmlmeWluZ1xuICAgKiB0aGUgcm9vdCByZWNvcmQgc2lnbmF0dXJlIHdpdGggaXRzIGJhc2UzMiBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqL1xuICBzdGF0aWMgcGFyc2VBbmRWZXJpZnlSb290KHJvb3Q6IHN0cmluZywgcHVibGljS2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghcm9vdC5zdGFydHNXaXRoKHRoaXMuUk9PVF9QUkVGSVgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRU5SVHJlZSByb290IGVudHJ5IG11c3Qgc3RhcnQgd2l0aCAnJHt0aGlzLlJPT1RfUFJFRklYfSdgXG4gICAgICApO1xuXG4gICAgY29uc3Qgcm9vdFZhbHVlcyA9IEVOUlRyZWUucGFyc2VSb290VmFsdWVzKHJvb3QpO1xuICAgIGNvbnN0IGRlY29kZWRQdWJsaWNLZXkgPSBiYXNlMzIuZGVjb2RlLmFzQnl0ZXMocHVibGljS2V5KTtcblxuICAgIC8vIFRoZSBzaWduYXR1cmUgaXMgYSA2NS1ieXRlIHNlY3AyNTZrMSBvdmVyIHRoZSBrZWNjYWsyNTYgaGFzaFxuICAgIC8vIG9mIHRoZSByZWNvcmQgY29udGVudCwgZXhjbHVkaW5nIHRoZSBgc2lnPWAgcGFydCwgZW5jb2RlZCBhcyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5nXG4gICAgLy8gKFRyYWlsaW5nIHJlY292ZXJ5IGJpdCBtdXN0IGJlIHRyaW1tZWQgdG8gcGFzcyBgZWNkc2FWZXJpZnlgIG1ldGhvZClcbiAgICBjb25zdCBzaWduZWRDb21wb25lbnQgPSByb290LnNwbGl0KFwiIHNpZ1wiKVswXTtcbiAgICBjb25zdCBzaWduZWRDb21wb25lbnRCdWZmZXIgPSB1dGY4VG9CeXRlcyhzaWduZWRDb21wb25lbnQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IGZyb21TdHJpbmcocm9vdFZhbHVlcy5zaWduYXR1cmUsIFwiYmFzZTY0dXJsXCIpLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIDY0XG4gICAgKTtcblxuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSB2ZXJpZnlTaWduYXR1cmUoXG4gICAgICBzaWduYXR1cmVCdWZmZXIsXG4gICAgICBrZWNjYWsyNTYoc2lnbmVkQ29tcG9uZW50QnVmZmVyKSxcbiAgICAgIG5ldyBVaW50OEFycmF5KGRlY29kZWRQdWJsaWNLZXkpXG4gICAgKTtcblxuICAgIGlmICghaXNWZXJpZmllZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHZlcmlmeSBFTlJUcmVlIHJvb3Qgc2lnbmF0dXJlXCIpO1xuXG4gICAgcmV0dXJuIHJvb3RWYWx1ZXMuZVJvb3Q7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VSb290VmFsdWVzKHR4dDogc3RyaW5nKTogRU5SUm9vdFZhbHVlcyB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHR4dC5tYXRjaChcbiAgICAgIC9eZW5ydHJlZS1yb290OnYxIGU9KFteIF0rKSBsPShbXiBdKykgc2VxPShcXGQrKSBzaWc9KFteIF0rKSQvXG4gICAgKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXRjaGVzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBFTlJUcmVlIHJvb3QgZW50cnlcIik7XG5cbiAgICBtYXRjaGVzLnNoaWZ0KCk7IC8vIFRoZSBmaXJzdCBlbnRyeSBpcyB0aGUgZnVsbCBtYXRjaFxuICAgIGNvbnN0IFtlUm9vdCwgbFJvb3QsIHNlcSwgc2lnbmF0dXJlXSA9IG1hdGNoZXM7XG5cbiAgICBpZiAoIWVSb290KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlICdlJyB2YWx1ZSBmcm9tIEVOUlRyZWUgcm9vdCBlbnRyeVwiKTtcbiAgICBpZiAoIWxSb290KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlICdsJyB2YWx1ZSBmcm9tIEVOUlRyZWUgcm9vdCBlbnRyeVwiKTtcblxuICAgIGlmICghc2VxKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlICdzZXEnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuICAgIGlmICghc2lnbmF0dXJlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlICdzaWcnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuXG4gICAgcmV0dXJuIHsgZVJvb3QsIGxSb290LCBzZXE6IE51bWJlcihzZXEpLCBzaWduYXR1cmUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGFuZCB0b3AgbGV2ZWwgZG9tYWluIG9mIGFuIEVOUiB0cmVlIGVudHJ5LlxuICAgKiBUaGUgZG9tYWluIGlzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgdHJhdmVyc2luZyBhIHNldCBvZiBsaW5rZWQgRE5TIFRYVCByZWNvcmRzXG4gICAqIGFuZCB0aGUgcHVibGljIGtleSBpcyB1c2VkIHRvIHZlcmlmeSB0aGUgcm9vdCBlbnRyeSByZWNvcmRcbiAgICovXG4gIHN0YXRpYyBwYXJzZVRyZWUodHJlZTogc3RyaW5nKTogRU5SVHJlZVZhbHVlcyB7XG4gICAgaWYgKCF0cmVlLnN0YXJ0c1dpdGgodGhpcy5UUkVFX1BSRUZJWCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFTlJUcmVlIHRyZWUgZW50cnkgbXVzdCBzdGFydCB3aXRoICcke3RoaXMuVFJFRV9QUkVGSVh9J2BcbiAgICAgICk7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gdHJlZS5tYXRjaCgvXmVucnRyZWU6XFwvXFwvKFteQF0rKUAoLispJC8pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hdGNoZXMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIEVOUlRyZWUgdHJlZSBlbnRyeVwiKTtcblxuICAgIG1hdGNoZXMuc2hpZnQoKTsgLy8gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBmdWxsIG1hdGNoXG4gICAgY29uc3QgW3B1YmxpY0tleSwgZG9tYWluXSA9IG1hdGNoZXM7XG5cbiAgICBpZiAoIXB1YmxpY0tleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBwdWJsaWMga2V5IGZyb20gRU5SVHJlZSB0cmVlIGVudHJ5XCIpO1xuICAgIGlmICghZG9tYWluKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIGRvbWFpbiBmcm9tIEVOUlRyZWUgdHJlZSBlbnRyeVwiKTtcblxuICAgIHJldHVybiB7IHB1YmxpY0tleSwgZG9tYWluIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJkb21haW5zIGxpc3RlZCBpbiBhbiBFTlIgYnJhbmNoIGVudHJ5LiBUaGVzZSBpbiB0dXJuIGxlYWQgdG9cbiAgICogZWl0aGVyIGZ1cnRoZXIgYnJhbmNoIGVudHJpZXMgb3IgRU5SIHJlY29yZHMuXG4gICAqL1xuICBzdGF0aWMgcGFyc2VCcmFuY2goYnJhbmNoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCFicmFuY2guc3RhcnRzV2l0aCh0aGlzLkJSQU5DSF9QUkVGSVgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRU5SVHJlZSBicmFuY2ggZW50cnkgbXVzdCBzdGFydCB3aXRoICcke3RoaXMuQlJBTkNIX1BSRUZJWH0nYFxuICAgICAgKTtcblxuICAgIHJldHVybiBicmFuY2guc3BsaXQodGhpcy5CUkFOQ0hfUFJFRklYKVsxXS5zcGxpdChcIixcIik7XG4gIH1cbn1cbiIsImltcG9ydCB7IGRlYnVnIH0gZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCB7IEVOUiwgV2FrdTIgfSBmcm9tIFwiLi4vZW5yXCI7XG5cbmltcG9ydCB7IE5vZGVDYXBhYmlsaXR5Q291bnQgfSBmcm9tIFwiLi9kbnNcIjtcblxuY29uc3QgZGJnID0gZGVidWcoXCJ3YWt1OmRpc2NvdmVyeTpmZXRjaF9ub2Rlc1wiKTtcblxuLyoqXG4gKiBGZXRjaCBub2RlcyB1c2luZyBwYXNzZWQgW1tnZXROb2RlXV0gdW50aWwgYWxsIHdhbnRlZCBjYXBhYmlsaXRpZXMgYXJlXG4gKiBmdWxmaWxsZWQgb3IgdGhlIG51bWJlciBvZiBbW2dldE5vZGVdXSBjYWxsIGV4Y2VlZHMgdGhlIHN1bSBvZlxuICogW1t3YW50ZWROb2RlQ2FwYWJpbGl0eUNvdW50XV0gcGx1cyBbW2Vycm9yVG9sZXJhbmNlXV0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTm9kZXNVbnRpbENhcGFiaWxpdGllc0Z1bGZpbGxlZChcbiAgd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudDogUGFydGlhbDxOb2RlQ2FwYWJpbGl0eUNvdW50PixcbiAgZXJyb3JUb2xlcmFuY2U6IG51bWJlcixcbiAgZ2V0Tm9kZTogKCkgPT4gUHJvbWlzZTxFTlIgfCBudWxsPlxuKTogUHJvbWlzZTxFTlJbXT4ge1xuICBjb25zdCB3YW50ZWQgPSB7XG4gICAgcmVsYXk6IHdhbnRlZE5vZGVDYXBhYmlsaXR5Q291bnQucmVsYXkgPz8gMCxcbiAgICBzdG9yZTogd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudC5zdG9yZSA/PyAwLFxuICAgIGZpbHRlcjogd2FudGVkTm9kZUNhcGFiaWxpdHlDb3VudC5maWx0ZXIgPz8gMCxcbiAgICBsaWdodFB1c2g6IHdhbnRlZE5vZGVDYXBhYmlsaXR5Q291bnQubGlnaHRQdXNoID8/IDAsXG4gIH07XG5cbiAgY29uc3QgbWF4U2VhcmNoZXMgPVxuICAgIHdhbnRlZC5yZWxheSArIHdhbnRlZC5zdG9yZSArIHdhbnRlZC5maWx0ZXIgKyB3YW50ZWQubGlnaHRQdXNoO1xuXG4gIGNvbnN0IGFjdHVhbCA9IHtcbiAgICByZWxheTogMCxcbiAgICBzdG9yZTogMCxcbiAgICBmaWx0ZXI6IDAsXG4gICAgbGlnaHRQdXNoOiAwLFxuICB9O1xuXG4gIGxldCB0b3RhbFNlYXJjaGVzID0gMDtcbiAgY29uc3QgcGVlcnM6IEVOUltdID0gW107XG5cbiAgd2hpbGUgKFxuICAgICFpc1NhdGlzZmllZCh3YW50ZWQsIGFjdHVhbCkgJiZcbiAgICB0b3RhbFNlYXJjaGVzIDwgbWF4U2VhcmNoZXMgKyBlcnJvclRvbGVyYW5jZVxuICApIHtcbiAgICBjb25zdCBwZWVyID0gYXdhaXQgZ2V0Tm9kZSgpO1xuICAgIGlmIChwZWVyICYmIGlzTmV3UGVlcihwZWVyLCBwZWVycykpIHtcbiAgICAgIC8vIEVOUnMgd2l0aG91dCBhIHdha3UyIGtleSBhcmUgaWdub3JlZC5cbiAgICAgIGlmIChwZWVyLndha3UyKSB7XG4gICAgICAgIGlmIChoZWxwc1NhdGlzZnlDYXBhYmlsaXRpZXMocGVlci53YWt1Miwgd2FudGVkLCBhY3R1YWwpKSB7XG4gICAgICAgICAgYWRkQ2FwYWJpbGl0aWVzKHBlZXIud2FrdTIsIGFjdHVhbCk7XG4gICAgICAgICAgcGVlcnMucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGJnKGBnb3QgbmV3IHBlZXIgY2FuZGlkYXRlIGZyb20gRE5TIGFkZHJlc3M9JHtwZWVyLm5vZGVJZH1AJHtwZWVyLmlwfWApO1xuICAgIH1cblxuICAgIHRvdGFsU2VhcmNoZXMrKztcbiAgfVxuICByZXR1cm4gcGVlcnM7XG59XG5cbmZ1bmN0aW9uIGlzU2F0aXNmaWVkKFxuICB3YW50ZWQ6IE5vZGVDYXBhYmlsaXR5Q291bnQsXG4gIGFjdHVhbDogTm9kZUNhcGFiaWxpdHlDb3VudFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYWN0dWFsLnJlbGF5ID49IHdhbnRlZC5yZWxheSAmJlxuICAgIGFjdHVhbC5zdG9yZSA+PSB3YW50ZWQuc3RvcmUgJiZcbiAgICBhY3R1YWwuZmlsdGVyID49IHdhbnRlZC5maWx0ZXIgJiZcbiAgICBhY3R1YWwubGlnaHRQdXNoID49IHdhbnRlZC5saWdodFB1c2hcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNOZXdQZWVyKHBlZXI6IEVOUiwgcGVlcnM6IEVOUltdKTogYm9vbGVhbiB7XG4gIGlmICghcGVlci5ub2RlSWQpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGV4aXN0aW5nUGVlciBvZiBwZWVycykge1xuICAgIGlmIChwZWVyLm5vZGVJZCA9PT0gZXhpc3RpbmdQZWVyLm5vZGVJZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhZGRDYXBhYmlsaXRpZXMobm9kZTogV2FrdTIsIHRvdGFsOiBOb2RlQ2FwYWJpbGl0eUNvdW50KTogdm9pZCB7XG4gIGlmIChub2RlLnJlbGF5KSB0b3RhbC5yZWxheSArPSAxO1xuICBpZiAobm9kZS5zdG9yZSkgdG90YWwuc3RvcmUgKz0gMTtcbiAgaWYgKG5vZGUuZmlsdGVyKSB0b3RhbC5maWx0ZXIgKz0gMTtcbiAgaWYgKG5vZGUubGlnaHRQdXNoKSB0b3RhbC5saWdodFB1c2ggKz0gMTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3Bvc2VkIEVOUiBbW25vZGVdXSBoZWxwcyBzYXRpc2Z5IHRoZSBbW3dhbnRlZF1dIGNhcGFiaWxpdGllcyxcbiAqIGNvbnNpZGVyaW5nIHRoZSBbW2FjdHVhbF1dIGNhcGFiaWxpdGllcyBvZiBub2RlcyByZXRyaWV2ZWQgc28gZmFyLi5cbiAqXG4gKiBAdGhyb3dzIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgd2FudGVkIGNhcGFiaWxpdGllcyBhcmUgYWxyZWFkeSBmdWxmaWxsZWQuXG4gKi9cbmZ1bmN0aW9uIGhlbHBzU2F0aXNmeUNhcGFiaWxpdGllcyhcbiAgbm9kZTogV2FrdTIsXG4gIHdhbnRlZDogTm9kZUNhcGFiaWxpdHlDb3VudCxcbiAgYWN0dWFsOiBOb2RlQ2FwYWJpbGl0eUNvdW50XG4pOiBib29sZWFuIHtcbiAgaWYgKGlzU2F0aXNmaWVkKHdhbnRlZCwgYWN0dWFsKSkge1xuICAgIHRocm93IFwiSW50ZXJuYWwgRXJyb3I6IFdha3UyIHdhbnRlZCBjYXBhYmlsaXRpZXMgYXJlIGFscmVhZHkgZnVsZmlsbGVkXCI7XG4gIH1cblxuICBjb25zdCBtaXNzaW5nID0gbWlzc2luZ0NhcGFiaWxpdGllcyh3YW50ZWQsIGFjdHVhbCk7XG5cbiAgcmV0dXJuIChcbiAgICAobWlzc2luZy5yZWxheSAmJiBub2RlLnJlbGF5KSB8fFxuICAgIChtaXNzaW5nLnN0b3JlICYmIG5vZGUuc3RvcmUpIHx8XG4gICAgKG1pc3NpbmcuZmlsdGVyICYmIG5vZGUuZmlsdGVyKSB8fFxuICAgIChtaXNzaW5nLmxpZ2h0UHVzaCAmJiBub2RlLmxpZ2h0UHVzaClcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBbW1dha3UyXV0gT2JqZWN0IGZvciB3aGljaCBjYXBhYmlsaXRpZXMgYXJlIHNldCB0byB0cnVlIGlmIHRoZXkgYXJlXG4gKiBbW3dhbnRlZF1dIHlldCBtaXNzaW5nIGZyb20gW1thY3R1YWxdXS5cbiAqL1xuZnVuY3Rpb24gbWlzc2luZ0NhcGFiaWxpdGllcyhcbiAgd2FudGVkOiBOb2RlQ2FwYWJpbGl0eUNvdW50LFxuICBhY3R1YWw6IE5vZGVDYXBhYmlsaXR5Q291bnRcbik6IFdha3UyIHtcbiAgcmV0dXJuIHtcbiAgICByZWxheTogYWN0dWFsLnJlbGF5IDwgd2FudGVkLnJlbGF5LFxuICAgIHN0b3JlOiBhY3R1YWwuc3RvcmUgPCB3YW50ZWQuc3RvcmUsXG4gICAgZmlsdGVyOiBhY3R1YWwuZmlsdGVyIDwgd2FudGVkLmZpbHRlcixcbiAgICBsaWdodFB1c2g6IGFjdHVhbC5saWdodFB1c2ggPCB3YW50ZWQubGlnaHRQdXNoLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgc2h1ZmZsZSB9IGZyb20gXCJsaWJwMnAtZ29zc2lwc3ViL3NyYy91dGlsc1wiO1xuXG5leHBvcnQgeyBnZXRQcmVkZWZpbmVkQm9vdHN0cmFwTm9kZXMgfSBmcm9tIFwiLi9wcmVkZWZpbmVkXCI7XG5leHBvcnQgKiBhcyBwcmVkZWZpbmVkIGZyb20gXCIuL3ByZWRlZmluZWRcIjtcbmV4cG9ydCB7IEJvb3RzdHJhcCwgQm9vdHN0cmFwT3B0aW9ucyB9IGZyb20gXCIuL2Jvb3RzdHJhcFwiO1xuZXhwb3J0ICogYXMgZG5zIGZyb20gXCIuL2Ruc1wiO1xuZXhwb3J0IHsgRW5kcG9pbnRzLCBEbnNPdmVySHR0cHMgfSBmcm9tIFwiLi9kbnNfb3Zlcl9odHRwc1wiO1xuZXhwb3J0IHsgRU5SVHJlZSwgRU5SVHJlZVZhbHVlcywgRU5SUm9vdFZhbHVlcyB9IGZyb20gXCIuL2VucnRyZWVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBzZXVkb1JhbmRvbVN1YnNldDxUPihcbiAgdmFsdWVzOiBUW10sXG4gIHdhbnRlZE51bWJlcjogbnVtYmVyXG4pOiBUW10ge1xuICBpZiAodmFsdWVzLmxlbmd0aCA8PSB3YW50ZWROdW1iZXIpIHtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgcmV0dXJuIHNodWZmbGUodmFsdWVzKS5zbGljZSgwLCB3YW50ZWROdW1iZXIpO1xufVxuIiwiaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSBcIm11bHRpYWRkclwiO1xuXG5pbXBvcnQgeyBnZXRQc2V1ZG9SYW5kb21TdWJzZXQgfSBmcm9tIFwiLi9pbmRleFwiO1xuXG5leHBvcnQgY29uc3QgRGVmYXVsdFdhbnRlZE51bWJlciA9IDE7XG5cbmV4cG9ydCBlbnVtIEZsZWV0IHtcbiAgUHJvZCA9IFwicHJvZFwiLFxuICBUZXN0ID0gXCJ0ZXN0XCIsXG59XG5cbi8qKlxuICogUmV0dXJuIGxpc3Qgb2YgcHJlLWRlZmluZWQgKGhhcmRjb2RlZCkgYm9vdHN0cmFwIG5vZGVzLlxuICpcbiAqIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmV0dXJuIG5vZGVzIG9mIHRoZSBud2FrdSBTdGF0dXMgUHJvZCBmbGVldC5cbiAqXG4gKiBAcGFyYW0gZmxlZXQgVGhlIGZsZWV0IHRvIGJlIHJldHVybmVkLiBEZWZhdWx0cyB0byBwcm9kdWN0aW9uIGZsZWV0LlxuICogQHBhcmFtIHdhbnRlZE51bWJlciBUaGUgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGRlc2lyZWQuIERlZmF1bHRzIHRvIFtbRGVmYXVsdFdhbnRlZE51bWJlcl1dLlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG11bHRpYWRkcmVzc2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlZGVmaW5lZEJvb3RzdHJhcE5vZGVzKFxuICBmbGVldDogRmxlZXQgPSBGbGVldC5Qcm9kLFxuICB3YW50ZWROdW1iZXI6IG51bWJlciA9IERlZmF1bHRXYW50ZWROdW1iZXJcbik6IE11bHRpYWRkcltdIHtcbiAgaWYgKHdhbnRlZE51bWJlciA8PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgbGV0IG5vZGVzO1xuICBzd2l0Y2ggKGZsZWV0KSB7XG4gICAgY2FzZSBGbGVldC5Qcm9kOlxuICAgICAgbm9kZXMgPSBmbGVldHMuZmxlZXRzW1wid2FrdXYyLnByb2RcIl1bXCJ3YWt1LXdlYnNvY2tldFwiXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmxlZXQuVGVzdDpcbiAgICAgIG5vZGVzID0gZmxlZXRzLmZsZWV0c1tcIndha3V2Mi50ZXN0XCJdW1wid2FrdS13ZWJzb2NrZXRcIl07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZXMgPSBmbGVldHMuZmxlZXRzW1wid2FrdXYyLnByb2RcIl1bXCJ3YWt1LXdlYnNvY2tldFwiXTtcbiAgfVxuXG4gIG5vZGVzID0gT2JqZWN0LnZhbHVlcyhub2RlcykgYXMgc3RyaW5nW107XG5cbiAgbm9kZXMgPSBub2Rlcy5tYXAoKG5vZGU6IHN0cmluZykgPT4gbmV3IE11bHRpYWRkcihub2RlKSk7XG4gIHJldHVybiBnZXRQc2V1ZG9SYW5kb21TdWJzZXQobm9kZXMsIHdhbnRlZE51bWJlcik7XG59XG5cbmV4cG9ydCBjb25zdCBmbGVldHMgPSB7XG4gIGZsZWV0czoge1xuICAgIFwid2FrdXYyLnByb2RcIjoge1xuICAgICAgXCJ3YWt1LXdlYnNvY2tldFwiOiB7XG4gICAgICAgIFwibm9kZS0wMS5hYy1jbi1ob25na29uZy1jLndha3V2Mi5wcm9kXCI6XG4gICAgICAgICAgXCIvZG5zNC9ub2RlLTAxLmFjLWNuLWhvbmdrb25nLWMud2FrdXYyLnByb2Quc3RhdHVzaW0ubmV0L3RjcC80NDMvd3NzL3AycC8xNlVpdTJIQW00djg2VzNibVQxQmlINm9TUHpjc1NyMjRpRFFwU041UWE5OTJCQ2pqd2dyRFwiLFxuICAgICAgICBcIm5vZGUtMDEuZG8tYW1zMy53YWt1djIucHJvZFwiOlxuICAgICAgICAgIFwiL2RuczQvbm9kZS0wMS5kby1hbXMzLndha3V2Mi5wcm9kLnN0YXR1c2ltLm5ldC90Y3AvNDQzL3dzcy9wMnAvMTZVaXUySEFtTDVva1dvcFg3TnFaV0JVS1ZxVzhpVXhDRW1kNUdNSExWUHdDZ3pZelF2M2VcIixcbiAgICAgICAgXCJub2RlLTAxLmdjLXVzLWNlbnRyYWwxLWEud2FrdXYyLnByb2RcIjpcbiAgICAgICAgICBcIi9kbnM0L25vZGUtMDEuZ2MtdXMtY2VudHJhbDEtYS53YWt1djIucHJvZC5zdGF0dXNpbS5uZXQvdGNwLzQ0My93c3MvcDJwLzE2VWl1MkhBbVZrS250c0VDYVlmZWZSMVYyeUNSNzlDZWdMQVR1VFBFNkI5VHhneEJpaWlBXCIsXG4gICAgICB9LFxuICAgIH0sXG4gICAgXCJ3YWt1djIudGVzdFwiOiB7XG4gICAgICBcIndha3Utd2Vic29ja2V0XCI6IHtcbiAgICAgICAgXCJub2RlLTAxLmFjLWNuLWhvbmdrb25nLWMud2FrdXYyLnRlc3RcIjpcbiAgICAgICAgICBcIi9kbnM0L25vZGUtMDEuYWMtY24taG9uZ2tvbmctYy53YWt1djIudGVzdC5zdGF0dXNpbS5uZXQvdGNwLzQ0My93c3MvcDJwLzE2VWl1MkhBa3ZXaXlGc2dSaHVKRWI5SmZqWXhFa29ITGduVVFtcjFONW1LV25ZanhZUlZtXCIsXG4gICAgICAgIFwibm9kZS0wMS5kby1hbXMzLndha3V2Mi50ZXN0XCI6XG4gICAgICAgICAgXCIvZG5zNC9ub2RlLTAxLmRvLWFtczMud2FrdXYyLnRlc3Quc3RhdHVzaW0ubmV0L3RjcC80NDMvd3NzL3AycC8xNlVpdTJIQW1QTGU3TXptOFRzWVV1YmdDQVcxYUpvZUZTY3hyTGo4cHBIRml2UG85N2JVWlwiLFxuICAgICAgICBcIm5vZGUtMDEuZ2MtdXMtY2VudHJhbDEtYS53YWt1djIudGVzdFwiOlxuICAgICAgICAgIFwiL2RuczQvbm9kZS0wMS5nYy11cy1jZW50cmFsMS1hLndha3V2Mi50ZXN0LnN0YXR1c2ltLm5ldC90Y3AvNDQzL3dzcy9wMnAvMTZVaXUySEFtSmIyZTI4cUxYeFQ1a1p4VlVVb0p0NzJFTXpOR1hCNDdSeHg1aHczcTRZalNcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG4iLCIvLyBNYXhpbXVtIGVuY29kZWQgc2l6ZSBvZiBhbiBFTlJcbmV4cG9ydCBjb25zdCBNQVhfUkVDT1JEX1NJWkUgPSAzMDA7XG5cbmV4cG9ydCBjb25zdCBFUlJfSU5WQUxJRF9JRCA9IFwiSW52YWxpZCByZWNvcmQgaWRcIjtcblxuZXhwb3J0IGNvbnN0IEVSUl9OT19TSUdOQVRVUkUgPSBcIk5vIHZhbGlkIHNpZ25hdHVyZSBmb3VuZFwiO1xuXG4vLyBUaGUgbWF4aW11bSBsZW5ndGggb2YgYnl0ZSBzaXplIG9mIGEgbXVsdGlhZGRyIHRvIGVuY29kZSBpbiB0aGUgYG11bHRpYWRkcmAgZmllbGRcbi8vIFRoZSBzaXplIGlzIGEgYmlnIGVuZGlhbiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlclxuZXhwb3J0IGNvbnN0IE1VTFRJQUREUl9MRU5HVEhfU0laRSA9IDI7XG4iLCJpbXBvcnQgKiBhcyBSTFAgZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgTXVsdGlhZGRyLCBwcm90b2NvbHMgfSBmcm9tIFwibXVsdGlhZGRyXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlOiBObyB0eXBlcyBhdmFpbGFibGVcbmltcG9ydCBtdUNvbnZlcnQgZnJvbSBcIm11bHRpYWRkci9zcmMvY29udmVydFwiO1xuaW1wb3J0IFBlZXJJZCBmcm9tIFwicGVlci1pZFwiO1xuaW1wb3J0IHsgZnJvbVN0cmluZyB9IGZyb20gXCJ1aW50OGFycmF5cy9mcm9tLXN0cmluZ1wiO1xuaW1wb3J0IHsgdG9TdHJpbmcgfSBmcm9tIFwidWludDhhcnJheXMvdG8tc3RyaW5nXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgdmFyaW50RW5jb2RlIH0gZnJvbSBcInZhcmludFwiO1xuXG5pbXBvcnQgeyBjb21wcmVzc1B1YmxpY0tleSwga2VjY2FrMjU2LCB2ZXJpZnlTaWduYXR1cmUgfSBmcm9tIFwiLi4vY3J5cHRvXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBieXRlc1RvVXRmOCwgaGV4VG9CeXRlcywgdXRmOFRvQnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuaW1wb3J0IHsgRVJSX0lOVkFMSURfSUQsIEVSUl9OT19TSUdOQVRVUkUsIE1BWF9SRUNPUkRfU0laRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlS2V5cGFpcixcbiAgY3JlYXRlS2V5cGFpckZyb21QZWVySWQsXG4gIGNyZWF0ZVBlZXJJZEZyb21LZXlwYWlyLFxuICBJS2V5cGFpcixcbiAgS2V5cGFpclR5cGUsXG59IGZyb20gXCIuL2tleXBhaXJcIjtcbmltcG9ydCB7IGRlY29kZU11bHRpYWRkcnMsIGVuY29kZU11bHRpYWRkcnMgfSBmcm9tIFwiLi9tdWx0aWFkZHJzX2NvZGVjXCI7XG5pbXBvcnQgeyBFTlJLZXksIEVOUlZhbHVlLCBOb2RlSWQsIFNlcXVlbmNlTnVtYmVyIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCAqIGFzIHY0IGZyb20gXCIuL3Y0XCI7XG5pbXBvcnQgeyBkZWNvZGVXYWt1MiwgZW5jb2RlV2FrdTIsIFdha3UyIH0gZnJvbSBcIi4vd2FrdTJfY29kZWNcIjtcblxuY29uc3QgZGJnID0gZGVidWcoXCJ3YWt1OmVuclwiKTtcblxuZXhwb3J0IGNsYXNzIEVOUiBleHRlbmRzIE1hcDxFTlJLZXksIEVOUlZhbHVlPiB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkVDT1JEX1BSRUZJWCA9IFwiZW5yOlwiO1xuICBwdWJsaWMgc2VxOiBTZXF1ZW5jZU51bWJlcjtcbiAgcHVibGljIHNpZ25hdHVyZTogVWludDhBcnJheSB8IG51bGw7XG4gIHB1YmxpYyBwZWVySWQ/OiBQZWVySWQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBrdnM6IFJlY29yZDxFTlJLZXksIEVOUlZhbHVlPiA9IHt9LFxuICAgIHNlcTogU2VxdWVuY2VOdW1iZXIgPSBCaWdJbnQoMSksXG4gICAgc2lnbmF0dXJlOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgc3VwZXIoT2JqZWN0LmVudHJpZXMoa3ZzKSk7XG4gICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxuICAgIGt2czogUmVjb3JkPEVOUktleSwgRU5SVmFsdWU+ID0ge30sXG4gICAgc2VxOiBTZXF1ZW5jZU51bWJlciA9IEJpZ0ludCgxKSxcbiAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbFxuICApOiBQcm9taXNlPEVOUj4ge1xuICAgIGNvbnN0IGVuciA9IG5ldyBFTlIoa3ZzLCBzZXEsIHNpZ25hdHVyZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGVuci5wdWJsaWNLZXk7XG4gICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleXBhaXIgPSBjcmVhdGVLZXlwYWlyKGVuci5rZXlwYWlyVHlwZSwgdW5kZWZpbmVkLCBwdWJsaWNLZXkpO1xuICAgICAgICBlbnIucGVlcklkID0gYXdhaXQgY3JlYXRlUGVlcklkRnJvbUtleXBhaXIoa2V5cGFpcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGJnKFwiQ291bGQgbm90IGNhbGN1bGF0ZSBwZWVyIGlkIGZvciBFTlJcIiwgZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVucjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVWNChcbiAgICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXksXG4gICAga3ZzOiBSZWNvcmQ8RU5SS2V5LCBFTlJWYWx1ZT4gPSB7fVxuICApOiBQcm9taXNlPEVOUj4ge1xuICAgIC8vIEVJUC03Nzggc3BlY2lmaWVzIHRoYXQgdGhlIGtleSBtdXN0IGJlIGluIGNvbXByZXNzZWQgZm9ybWF0LCAzMyBieXRlc1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMykge1xuICAgICAgcHVibGljS2V5ID0gY29tcHJlc3NQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIEVOUi5jcmVhdGUoe1xuICAgICAgLi4ua3ZzLFxuICAgICAgaWQ6IHV0ZjhUb0J5dGVzKFwidjRcIiksXG4gICAgICBzZWNwMjU2azE6IHB1YmxpY0tleSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVGcm9tUGVlcklkKFxuICAgIHBlZXJJZDogUGVlcklkLFxuICAgIGt2czogUmVjb3JkPEVOUktleSwgRU5SVmFsdWU+ID0ge31cbiAgKTogUHJvbWlzZTxFTlI+IHtcbiAgICBjb25zdCBrZXlwYWlyID0gY3JlYXRlS2V5cGFpckZyb21QZWVySWQocGVlcklkKTtcbiAgICBzd2l0Y2ggKGtleXBhaXIudHlwZSkge1xuICAgICAgY2FzZSBLZXlwYWlyVHlwZS5zZWNwMjU2azE6XG4gICAgICAgIHJldHVybiBFTlIuY3JlYXRlVjQoa2V5cGFpci5wdWJsaWNLZXksIGt2cyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGVjb2RlRnJvbVZhbHVlcyhkZWNvZGVkOiBVaW50OEFycmF5W10pOiBQcm9taXNlPEVOUj4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkZWNvZGVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBFTlIgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKGRlY29kZWQubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBFTlIgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mIGVsZW1lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBbc2lnbmF0dXJlLCBzZXEsIC4uLmt2c10gPSBkZWNvZGVkO1xuICAgIGlmICghc2lnbmF0dXJlIHx8IEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjb2RlZCBFTlIgaW52YWxpZCBzaWduYXR1cmU6IG11c3QgYmUgYSBieXRlIGFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoIXNlcSB8fCBBcnJheS5pc0FycmF5KHNlcSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJEZWNvZGVkIEVOUiBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcjogbXVzdCBiZSBhIGJ5dGUgYXJyYXlcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb2JqOiBSZWNvcmQ8RU5SS2V5LCBFTlJWYWx1ZT4gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGt2cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqW2J5dGVzVG9VdGY4KGt2c1tpXSldID0ga3ZzW2kgKyAxXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGJnKFwiRmFpbGVkIHRvIGRlY29kZSBFTlIga2V5IHRvIFVURi04LCBza2lwcGluZyBpdFwiLCBrdnNbaV0sIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBzZXEgaXMgYW4gZW1wdHkgYXJyYXksIHRyYW5zbGF0ZSBhcyB2YWx1ZSAwXG4gICAgY29uc3QgaGV4U2VxID0gXCIweFwiICsgKHNlcS5sZW5ndGggPyBieXRlc1RvSGV4KHNlcSkgOiBcIjAwXCIpO1xuXG4gICAgY29uc3QgZW5yID0gYXdhaXQgRU5SLmNyZWF0ZShvYmosIEJpZ0ludChoZXhTZXEpLCBzaWduYXR1cmUpO1xuXG4gICAgY29uc3QgcmxwRW5jb2RlZEJ5dGVzID0gaGV4VG9CeXRlcyhSTFAuZW5jb2RlKFtzZXEsIC4uLmt2c10pKTtcbiAgICBpZiAoIWVuci52ZXJpZnkocmxwRW5jb2RlZEJ5dGVzLCBzaWduYXR1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gdmVyaWZ5IEVOUiBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIHJldHVybiBlbnI7XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlKGVuY29kZWQ6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPEVOUj4ge1xuICAgIGNvbnN0IGRlY29kZWQgPSBSTFAuZGVjb2RlKGVuY29kZWQpLm1hcChoZXhUb0J5dGVzKTtcbiAgICByZXR1cm4gRU5SLmRlY29kZUZyb21WYWx1ZXMoZGVjb2RlZCk7XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlVHh0KGVuY29kZWQ6IHN0cmluZyk6IFByb21pc2U8RU5SPiB7XG4gICAgaWYgKCFlbmNvZGVkLnN0YXJ0c1dpdGgodGhpcy5SRUNPUkRfUFJFRklYKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgXCJzdHJpbmcgZW5jb2RlZCBFTlIgbXVzdCBzdGFydCB3aXRoICcke3RoaXMuUkVDT1JEX1BSRUZJWH0nYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIEVOUi5kZWNvZGUoZnJvbVN0cmluZyhlbmNvZGVkLnNsaWNlKDQpLCBcImJhc2U2NHVybFwiKSk7XG4gIH1cblxuICBzZXQoazogRU5SS2V5LCB2OiBFTlJWYWx1ZSk6IHRoaXMge1xuICAgIHRoaXMuc2lnbmF0dXJlID0gbnVsbDtcbiAgICB0aGlzLnNlcSsrO1xuICAgIHJldHVybiBzdXBlci5zZXQoaywgdik7XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0KFwiaWRcIik7XG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKFwiaWQgbm90IGZvdW5kLlwiKTtcbiAgICByZXR1cm4gYnl0ZXNUb1V0ZjgoaWQpO1xuICB9XG5cbiAgZ2V0IGtleXBhaXJUeXBlKCk6IEtleXBhaXJUeXBlIHtcbiAgICBzd2l0Y2ggKHRoaXMuaWQpIHtcbiAgICAgIGNhc2UgXCJ2NFwiOlxuICAgICAgICByZXR1cm4gS2V5cGFpclR5cGUuc2VjcDI1NmsxO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0lEKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcHVibGljS2V5KCk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xuICAgIHN3aXRjaCAodGhpcy5pZCkge1xuICAgICAgY2FzZSBcInY0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInNlY3AyNTZrMVwiKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9JRCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGtleXBhaXIoKTogSUtleXBhaXIgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnB1YmxpY0tleSkge1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gdGhpcy5wdWJsaWNLZXk7XG4gICAgICByZXR1cm4gY3JlYXRlS2V5cGFpcih0aGlzLmtleXBhaXJUeXBlLCB1bmRlZmluZWQsIHB1YmxpY0tleSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldCBub2RlSWQoKTogTm9kZUlkIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKHRoaXMuaWQpIHtcbiAgICAgIGNhc2UgXCJ2NFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNLZXkgPyB2NC5ub2RlSWQodGhpcy5wdWJsaWNLZXkpIDogdW5kZWZpbmVkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0lEKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXAoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldChcImlwXCIpO1xuICAgIGlmIChyYXcpIHtcbiAgICAgIHJldHVybiBtdUNvbnZlcnQudG9TdHJpbmcocHJvdG9jb2xzLm5hbWVzLmlwNC5jb2RlLCByYXcpIGFzIHN0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXQgaXAoaXA6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChpcCkge1xuICAgICAgdGhpcy5zZXQoXCJpcFwiLCBtdUNvbnZlcnQudG9CeXRlcyhwcm90b2NvbHMubmFtZXMuaXA0LmNvZGUsIGlwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsZXRlKFwiaXBcIik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHRjcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KFwidGNwXCIpO1xuICAgIGlmIChyYXcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIobXVDb252ZXJ0LnRvU3RyaW5nKHByb3RvY29scy5uYW1lcy50Y3AuY29kZSwgcmF3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IHRjcChwb3J0OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlbGV0ZShcInRjcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoXCJ0Y3BcIiwgbXVDb252ZXJ0LnRvQnl0ZXMocHJvdG9jb2xzLm5hbWVzLnRjcC5jb2RlLCBwb3J0KSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHVkcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KFwidWRwXCIpO1xuICAgIGlmIChyYXcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIobXVDb252ZXJ0LnRvU3RyaW5nKHByb3RvY29scy5uYW1lcy51ZHAuY29kZSwgcmF3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IHVkcChwb3J0OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlbGV0ZShcInVkcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoXCJ1ZHBcIiwgbXVDb252ZXJ0LnRvQnl0ZXMocHJvdG9jb2xzLm5hbWVzLnVkcC5jb2RlLCBwb3J0KSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlwNigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KFwiaXA2XCIpO1xuICAgIGlmIChyYXcpIHtcbiAgICAgIHJldHVybiBtdUNvbnZlcnQudG9TdHJpbmcocHJvdG9jb2xzLm5hbWVzLmlwNi5jb2RlLCByYXcpIGFzIHN0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXQgaXA2KGlwOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXApIHtcbiAgICAgIHRoaXMuc2V0KFwiaXA2XCIsIG11Q29udmVydC50b0J5dGVzKHByb3RvY29scy5uYW1lcy5pcDYuY29kZSwgaXApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWxldGUoXCJpcDZcIik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHRjcDYoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldChcInRjcDZcIik7XG4gICAgaWYgKHJhdykge1xuICAgICAgcmV0dXJuIE51bWJlcihtdUNvbnZlcnQudG9TdHJpbmcocHJvdG9jb2xzLm5hbWVzLnRjcC5jb2RlLCByYXcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXQgdGNwNihwb3J0OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlbGV0ZShcInRjcDZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KFwidGNwNlwiLCBtdUNvbnZlcnQudG9CeXRlcyhwcm90b2NvbHMubmFtZXMudGNwLmNvZGUsIHBvcnQpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdWRwNigpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KFwidWRwNlwiKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG11Q29udmVydC50b1N0cmluZyhwcm90b2NvbHMubmFtZXMudWRwLmNvZGUsIHJhdykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldCB1ZHA2KHBvcnQ6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGVsZXRlKFwidWRwNlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoXCJ1ZHA2XCIsIG11Q29udmVydC50b0J5dGVzKHByb3RvY29scy5uYW1lcy51ZHAuY29kZSwgcG9ydCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBtdWx0aWFkZHJzYCBmaWVsZCBmcm9tIEVOUi5cbiAgICpcbiAgICogVGhpcyBmaWVsZCBpcyB1c2VkIHRvIHN0b3JlIG11bHRpYWRkcmVzc2VzIHRoYXQgY2Fubm90IGJlIHN0b3JlZCB3aXRoIHRoZSBjdXJyZW50IEVOUiBwcmUtZGVmaW5lZCBrZXlzLlxuICAgKiBUaGVzZSBjYW4gYmUgYSBtdWx0aWFkZHJlc3NlcyB0aGF0IGluY2x1ZGUgZW5jYXBzdWxhdGlvbiAoZS5nLiB3c3MpIG9yIGRvIG5vdCB1c2UgYGlwNGAgbm9yIGBpcDZgIGZvciB0aGUgaG9zdFxuICAgKiBhZGRyZXNzIChlLmcuIGBkbnM0YCwgYGRuc2FkZHJgLCBldGMpLi5cbiAgICpcbiAgICogSWYgdGhlIHBlZXIgaW5mb3JtYXRpb24gb25seSBjb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCB3aXRoIHRoZSBFTlIgcHJlLWRlZmluZWQga2V5c1xuICAgKiAoaXAsIHRjcCwgZXRjKSB0aGVuIHRoZSB1c2FnZSBvZiBbW2dldExvY2F0aW9uTXVsdGlhZGRyXV0gc2hvdWxkIGJlIHByZWZlcnJlZC5cbiAgICpcbiAgICogVGhlIG11bHRpYWRkcmVzc2VzIHN0b3JlZCBpbiB0aGlzIGZpZWxkIGFyZSBleHBlY3RlZCB0byBiZSBsb2NhdGlvbiBtdWx0aWFkZHJlc3NlcywgaWUsIHBlZXIgaWQgbGVzcy5cbiAgICovXG4gIGdldCBtdWx0aWFkZHJzKCk6IE11bHRpYWRkcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldChcIm11bHRpYWRkcnNcIik7XG5cbiAgICBpZiAocmF3KSByZXR1cm4gZGVjb2RlTXVsdGlhZGRycyhyYXcpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYG11bHRpYWRkcnNgIGZpZWxkIG9uIHRoZSBFTlIuXG4gICAqXG4gICAqIFRoaXMgZmllbGQgaXMgdXNlZCB0byBzdG9yZSBtdWx0aWFkZHJlc3NlcyB0aGF0IGNhbm5vdCBiZSBzdG9yZWQgd2l0aCB0aGUgY3VycmVudCBFTlIgcHJlLWRlZmluZWQga2V5cy5cbiAgICogVGhlc2UgY2FuIGJlIGEgbXVsdGlhZGRyZXNzZXMgdGhhdCBpbmNsdWRlIGVuY2Fwc3VsYXRpb24gKGUuZy4gd3NzKSBvciBkbyBub3QgdXNlIGBpcDRgIG5vciBgaXA2YCBmb3IgdGhlIGhvc3RcbiAgICogYWRkcmVzcyAoZS5nLiBgZG5zNGAsIGBkbnNhZGRyYCwgZXRjKS4uXG4gICAqXG4gICAqIElmIHRoZSBwZWVyIGluZm9ybWF0aW9uIG9ubHkgY29udGFpbnMgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgRU5SIHByZS1kZWZpbmVkIGtleXNcbiAgICogKGlwLCB0Y3AsIGV0YykgdGhlbiB0aGUgdXNhZ2Ugb2YgW1tzZXRMb2NhdGlvbk11bHRpYWRkcl1dIHNob3VsZCBiZSBwcmVmZXJyZWQuXG4gICAqIFRoZSBtdWx0aWFkZHJlc3NlcyBzdG9yZWQgaW4gdGhpcyBmaWVsZCBtdXN0IGJlIGxvY2F0aW9uIG11bHRpYWRkcmVzc2VzLFxuICAgKiBpZSwgd2l0aG91dCBhIHBlZXIgaWQuXG4gICAqL1xuICBzZXQgbXVsdGlhZGRycyhtdWx0aWFkZHJzOiBNdWx0aWFkZHJbXSB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChtdWx0aWFkZHJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGVsZXRlKFwibXVsdGlhZGRyc1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXVsdGlhZGRyc0J1ZiA9IGVuY29kZU11bHRpYWRkcnMobXVsdGlhZGRycyk7XG4gICAgICB0aGlzLnNldChcIm11bHRpYWRkcnNcIiwgbXVsdGlhZGRyc0J1Zik7XG4gICAgfVxuICB9XG5cbiAgZ2V0TG9jYXRpb25NdWx0aWFkZHIoXG4gICAgcHJvdG9jb2w6IFwidWRwXCIgfCBcInVkcDRcIiB8IFwidWRwNlwiIHwgXCJ0Y3BcIiB8IFwidGNwNFwiIHwgXCJ0Y3A2XCJcbiAgKTogTXVsdGlhZGRyIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAocHJvdG9jb2wgPT09IFwidWRwXCIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoXCJ1ZHA0XCIpIHx8IHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoXCJ1ZHA2XCIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocHJvdG9jb2wgPT09IFwidGNwXCIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoXCJ0Y3A0XCIpIHx8IHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoXCJ0Y3A2XCIpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpc0lwdjYgPSBwcm90b2NvbC5lbmRzV2l0aChcIjZcIik7XG4gICAgY29uc3QgaXBWYWwgPSB0aGlzLmdldChpc0lwdjYgPyBcImlwNlwiIDogXCJpcFwiKTtcbiAgICBpZiAoIWlwVmFsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVWRwID0gcHJvdG9jb2wuc3RhcnRzV2l0aChcInVkcFwiKTtcbiAgICBjb25zdCBpc1RjcCA9IHByb3RvY29sLnN0YXJ0c1dpdGgoXCJ0Y3BcIik7XG4gICAgbGV0IHByb3RvTmFtZSwgcHJvdG9WYWw7XG4gICAgaWYgKGlzVWRwKSB7XG4gICAgICBwcm90b05hbWUgPSBcInVkcFwiO1xuICAgICAgcHJvdG9WYWwgPSBpc0lwdjYgPyB0aGlzLmdldChcInVkcDZcIikgOiB0aGlzLmdldChcInVkcFwiKTtcbiAgICB9IGVsc2UgaWYgKGlzVGNwKSB7XG4gICAgICBwcm90b05hbWUgPSBcInRjcFwiO1xuICAgICAgcHJvdG9WYWwgPSBpc0lwdjYgPyB0aGlzLmdldChcInRjcDZcIikgOiB0aGlzLmdldChcInRjcFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFwcm90b1ZhbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgcmF3IG11bHRpYWRkciBidWZmZXJcbiAgICAvLyBtdWx0aWFkZHIgbGVuZ3RoIGlzOlxuICAgIC8vICAxIGJ5dGUgZm9yIHRoZSBpcCBwcm90b2NvbCAoaXA0IG9yIGlwNilcbiAgICAvLyAgTiBieXRlcyBmb3IgdGhlIGlwIGFkZHJlc3NcbiAgICAvLyAgMSBvciAyIGJ5dGVzIGZvciB0aGUgcHJvdG9jb2wgYXMgYnVmZmVyICh0Y3Agb3IgdWRwKVxuICAgIC8vICAyIGJ5dGVzIGZvciB0aGUgcG9ydFxuICAgIGNvbnN0IGlwTWEgPSBwcm90b2NvbHMubmFtZXNbaXNJcHY2ID8gXCJpcDZcIiA6IFwiaXA0XCJdO1xuICAgIGNvbnN0IGlwQnl0ZUxlbiA9IGlwTWEuc2l6ZSAvIDg7XG4gICAgY29uc3QgcHJvdG9NYSA9IHByb3RvY29scy5uYW1lc1twcm90b05hbWVdO1xuICAgIGNvbnN0IHByb3RvQnVmID0gdmFyaW50RW5jb2RlKHByb3RvTWEuY29kZSk7XG4gICAgY29uc3QgbWFCdWYgPSBuZXcgVWludDhBcnJheSgzICsgaXBCeXRlTGVuICsgcHJvdG9CdWYubGVuZ3RoKTtcbiAgICBtYUJ1ZlswXSA9IGlwTWEuY29kZTtcbiAgICBtYUJ1Zi5zZXQoaXBWYWwsIDEpO1xuICAgIG1hQnVmLnNldChwcm90b0J1ZiwgMSArIGlwQnl0ZUxlbik7XG4gICAgbWFCdWYuc2V0KHByb3RvVmFsLCAxICsgaXBCeXRlTGVuICsgcHJvdG9CdWYubGVuZ3RoKTtcblxuICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKG1hQnVmKTtcbiAgfVxuXG4gIHNldExvY2F0aW9uTXVsdGlhZGRyKG11bHRpYWRkcjogTXVsdGlhZGRyKTogdm9pZCB7XG4gICAgY29uc3QgcHJvdG9OYW1lcyA9IG11bHRpYWRkci5wcm90b05hbWVzKCk7XG4gICAgaWYgKFxuICAgICAgcHJvdG9OYW1lcy5sZW5ndGggIT09IDIgJiZcbiAgICAgIHByb3RvTmFtZXNbMV0gIT09IFwidWRwXCIgJiZcbiAgICAgIHByb3RvTmFtZXNbMV0gIT09IFwidGNwXCJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbXVsdGlhZGRyXCIpO1xuICAgIH1cbiAgICBjb25zdCB0dXBsZXMgPSBtdWx0aWFkZHIudHVwbGVzKCk7XG4gICAgaWYgKCF0dXBsZXNbMF1bMV0gfHwgIXR1cGxlc1sxXVsxXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtdWx0aWFkZHJcIik7XG4gICAgfVxuXG4gICAgLy8gSVB2NFxuICAgIGlmICh0dXBsZXNbMF1bMF0gPT09IDQpIHtcbiAgICAgIHRoaXMuc2V0KFwiaXBcIiwgdHVwbGVzWzBdWzFdKTtcbiAgICAgIHRoaXMuc2V0KHByb3RvTmFtZXNbMV0sIHR1cGxlc1sxXVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KFwiaXA2XCIsIHR1cGxlc1swXVsxXSk7XG4gICAgICB0aGlzLnNldChwcm90b05hbWVzWzFdICsgXCI2XCIsIHR1cGxlc1sxXVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGwgbXVsdGlhZGRyIGZyb20gdGhlIEVOUiBmaWVsZHMgbWF0Y2hpbmcgdGhlIHByb3ZpZGVkXG4gICAqIGBwcm90b2NvbGAgcGFyYW1ldGVyLlxuICAgKiBUbyByZXR1cm4gZnVsbCBtdWx0aWFkZHJzIGZyb20gdGhlIGBtdWx0aWFkZHJzYCBFTlIgZmllbGQsXG4gICAqIHVzZSBbW0VOUi5nZXRGdWxsTXVsdGlhZGRyc11dXG4gICAqXG4gICAqIEBwYXJhbSBwcm90b2NvbFxuICAgKi9cbiAgZ2V0RnVsbE11bHRpYWRkcihcbiAgICBwcm90b2NvbDogXCJ1ZHBcIiB8IFwidWRwNFwiIHwgXCJ1ZHA2XCIgfCBcInRjcFwiIHwgXCJ0Y3A0XCIgfCBcInRjcDZcIlxuICApOiBNdWx0aWFkZHIgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnBlZXJJZCkge1xuICAgICAgY29uc3QgbG9jYXRpb25NdWx0aWFkZHIgPSB0aGlzLmdldExvY2F0aW9uTXVsdGlhZGRyKHByb3RvY29sKTtcbiAgICAgIGlmIChsb2NhdGlvbk11bHRpYWRkcikge1xuICAgICAgICByZXR1cm4gbG9jYXRpb25NdWx0aWFkZHIuZW5jYXBzdWxhdGUoXG4gICAgICAgICAgYC9wMnAvJHt0aGlzLnBlZXJJZC50b0I1OFN0cmluZygpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGwgbXVsdGlhZGRycyBmcm9tIHRoZSBgbXVsdGlhZGRyc2AgRU5SIGZpZWxkLlxuICAgKi9cbiAgZ2V0RnVsbE11bHRpYWRkcnMoKTogTXVsdGlhZGRyW10ge1xuICAgIGlmICh0aGlzLnBlZXJJZCAmJiB0aGlzLm11bHRpYWRkcnMpIHtcbiAgICAgIGNvbnN0IHBlZXJJZCA9IHRoaXMucGVlcklkO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlhZGRycy5tYXAoKG1hKSA9PiB7XG4gICAgICAgIHJldHVybiBtYS5lbmNhcHN1bGF0ZShgL3AycC8ke3BlZXJJZC50b0I1OFN0cmluZygpfWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGB3YWt1MmAgZmllbGQgZnJvbSBFTlIuXG4gICAqL1xuICBnZXQgd2FrdTIoKTogV2FrdTIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KFwid2FrdTJcIik7XG4gICAgaWYgKHJhdykgcmV0dXJuIGRlY29kZVdha3UyKHJhd1swXSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBgd2FrdTJgIGZpZWxkIG9uIHRoZSBFTlIuXG4gICAqL1xuICBzZXQgd2FrdTIod2FrdTI6IFdha3UyIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHdha3UyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGVsZXRlKFwid2FrdTJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSBlbmNvZGVXYWt1Mih3YWt1Mik7XG4gICAgICB0aGlzLnNldChcIndha3UyXCIsIG5ldyBVaW50OEFycmF5KFtieXRlXSkpO1xuICAgIH1cbiAgfVxuXG4gIHZlcmlmeShkYXRhOiBVaW50OEFycmF5LCBzaWduYXR1cmU6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuZ2V0KFwiaWRcIikgfHwgdGhpcy5pZCAhPT0gXCJ2NFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfSUQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdmVyaWZ5IEVOUjogTm8gcHVibGljIGtleVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcmlmeVNpZ25hdHVyZShzaWduYXR1cmUsIGtlY2NhazI1NihkYXRhKSwgdGhpcy5wdWJsaWNLZXkpO1xuICB9XG5cbiAgYXN5bmMgc2lnbihkYXRhOiBVaW50OEFycmF5LCBwcml2YXRlS2V5OiBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgc3dpdGNoICh0aGlzLmlkKSB7XG4gICAgICBjYXNlIFwidjRcIjpcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBhd2FpdCB2NC5zaWduKHByaXZhdGVLZXksIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9JRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZTtcbiAgfVxuXG4gIGFzeW5jIGVuY29kZVRvVmFsdWVzKFxuICAgIHByaXZhdGVLZXk/OiBVaW50OEFycmF5XG4gICk6IFByb21pc2U8KEVOUktleSB8IEVOUlZhbHVlIHwgbnVtYmVyW10pW10+IHtcbiAgICAvLyBzb3J0IGtleXMgYW5kIGZsYXR0ZW4gaW50byBbaywgdiwgaywgdiwgLi4uXVxuICAgIGNvbnN0IGNvbnRlbnQ6IEFycmF5PEVOUktleSB8IEVOUlZhbHVlIHwgbnVtYmVyW10+ID0gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpXG4gICAgICAubWFwKChrKSA9PiBbaywgdGhpcy5nZXQoayldIGFzIFtFTlJLZXksIEVOUlZhbHVlXSlcbiAgICAgIC5tYXAoKFtrLCB2XSkgPT4gW3V0ZjhUb0J5dGVzKGspLCB2XSlcbiAgICAgIC5mbGF0KCk7XG4gICAgY29udGVudC51bnNoaWZ0KG5ldyBVaW50OEFycmF5KFtOdW1iZXIodGhpcy5zZXEpXSkpO1xuICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICBjb250ZW50LnVuc2hpZnQoXG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbihoZXhUb0J5dGVzKFJMUC5lbmNvZGUoY29udGVudCkpLCBwcml2YXRlS2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PX1NJR05BVFVSRSk7XG4gICAgICB9XG4gICAgICBjb250ZW50LnVuc2hpZnQodGhpcy5zaWduYXR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGFzeW5jIGVuY29kZShwcml2YXRlS2V5PzogVWludDhBcnJheSk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIGNvbnN0IGVuY29kZWQgPSBoZXhUb0J5dGVzKFxuICAgICAgUkxQLmVuY29kZShhd2FpdCB0aGlzLmVuY29kZVRvVmFsdWVzKHByaXZhdGVLZXkpKVxuICAgICk7XG4gICAgaWYgKGVuY29kZWQubGVuZ3RoID49IE1BWF9SRUNPUkRfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRU5SIG11c3QgYmUgbGVzcyB0aGFuIDMwMCBieXRlc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH1cblxuICBhc3luYyBlbmNvZGVUeHQocHJpdmF0ZUtleT86IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiAoXG4gICAgICBFTlIuUkVDT1JEX1BSRUZJWCArIHRvU3RyaW5nKGF3YWl0IHRoaXMuZW5jb2RlKHByaXZhdGVLZXkpLCBcImJhc2U2NHVybFwiKVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHY0Q3J5cHRvIGZyb20gXCIuL3Y0XCI7XG5leHBvcnQgY29uc3QgdjQgPSB2NENyeXB0bztcbmV4cG9ydCAqIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZW5yXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4va2V5cGFpclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vd2FrdTJfY29kZWNcIjtcbiIsImltcG9ydCB7IGtleXMgfSBmcm9tIFwibGlicDJwLWNyeXB0b1wiO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tIFwibXVsdGlmb3JtYXRzL2hhc2hlcy9pZGVudGl0eVwiO1xuaW1wb3J0IFBlZXJJZCBmcm9tIFwicGVlci1pZFwiO1xuXG5pbXBvcnQgeyBTZWNwMjU2azFLZXlwYWlyIH0gZnJvbSBcIi4vc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBJS2V5cGFpciwgS2V5cGFpclR5cGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5jb25zdCB7IGtleXNQQk0sIHN1cHBvcnRlZEtleXMgfSA9IGtleXM7XG5cbmV4cG9ydCBjb25zdCBFUlJfVFlQRV9OT1RfSU1QTEVNRU5URUQgPSBcIktleXBhaXIgdHlwZSBub3QgaW1wbGVtZW50ZWRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZWNwMjU2azFcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5cGFpcih0eXBlOiBLZXlwYWlyVHlwZSk6IFByb21pc2U8SUtleXBhaXI+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBLZXlwYWlyVHlwZS5zZWNwMjU2azE6XG4gICAgICByZXR1cm4gYXdhaXQgU2VjcDI1NmsxS2V5cGFpci5nZW5lcmF0ZSgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX1RZUEVfTk9UX0lNUExFTUVOVEVEKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5cGFpcihcbiAgdHlwZTogS2V5cGFpclR5cGUsXG4gIHByaXZhdGVLZXk/OiBVaW50OEFycmF5LFxuICBwdWJsaWNLZXk/OiBVaW50OEFycmF5XG4pOiBJS2V5cGFpciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgS2V5cGFpclR5cGUuc2VjcDI1NmsxOlxuICAgICAgcmV0dXJuIG5ldyBTZWNwMjU2azFLZXlwYWlyKHByaXZhdGVLZXksIHB1YmxpY0tleSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfVFlQRV9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQZWVySWRGcm9tS2V5cGFpcihcbiAga2V5cGFpcjogSUtleXBhaXJcbik6IFByb21pc2U8UGVlcklkPiB7XG4gIHN3aXRjaCAoa2V5cGFpci50eXBlKSB7XG4gICAgY2FzZSBLZXlwYWlyVHlwZS5zZWNwMjU2azE6IHtcbiAgICAgIC8vIG1hbnVhbGx5IGNyZWF0ZSBhIHBlZXIgaWQgdG8gYXZvaWQgZXhwZW5zaXZlIG9wc1xuICAgICAgY29uc3QgcHJpdktleSA9IGtleXBhaXIuaGFzUHJpdmF0ZUtleSgpXG4gICAgICAgID8gbmV3IHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxLlNlY3AyNTZrMVByaXZhdGVLZXkoXG4gICAgICAgICAgICBrZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICBrZXlwYWlyLnB1YmxpY0tleVxuICAgICAgICAgIClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHB1YktleSA9IG5ldyBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS5TZWNwMjU2azFQdWJsaWNLZXkoXG4gICAgICAgIGtleXBhaXIucHVibGljS2V5XG4gICAgICApO1xuICAgICAgY29uc3QgaWQgPSBhd2FpdCBpZGVudGl0eS5kaWdlc3QocHViS2V5LmJ5dGVzKTtcbiAgICAgIHJldHVybiBuZXcgUGVlcklkKGlkLmJ5dGVzLCBwcml2S2V5LCBwdWJLZXkpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9UWVBFX05PVF9JTVBMRU1FTlRFRCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleXBhaXJGcm9tUGVlcklkKHBlZXJJZDogUGVlcklkKTogSUtleXBhaXIge1xuICAvLyBwdWIvcHJpdmF0ZSBrZXkgYnl0ZXMgZnJvbSBwZWVyLWlkIGFyZSBlbmNvZGVkIGluIHByb3RvYnVmIGZvcm1hdFxuICBjb25zdCBwdWIgPSBrZXlzUEJNLlB1YmxpY0tleS5kZWNvZGUocGVlcklkLnB1YktleS5ieXRlcyk7XG4gIHJldHVybiBjcmVhdGVLZXlwYWlyKFxuICAgIHB1Yi5UeXBlIGFzIEtleXBhaXJUeXBlLFxuICAgIHBlZXJJZC5wcml2S2V5ID8gcGVlcklkLnByaXZLZXkubWFyc2hhbCgpIDogdW5kZWZpbmVkLFxuICAgIHB1Yi5EYXRhXG4gICk7XG59XG4iLCJpbXBvcnQgKiBhcyBzZWNwIGZyb20gXCJAbm9ibGUvc2VjcDI1NmsxXCI7XG5cbmltcG9ydCB7IGNvbXByZXNzUHVibGljS2V5LCByYW5kb21CeXRlcyB9IGZyb20gXCIuLi8uLi9jcnlwdG9cIjtcblxuaW1wb3J0IHsgSUtleXBhaXIsIEtleXBhaXJUeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IGNsYXNzIFNlY3AyNTZrMUtleXBhaXIgaW1wbGVtZW50cyBJS2V5cGFpciB7XG4gIHJlYWRvbmx5IHR5cGU6IEtleXBhaXJUeXBlO1xuICBfcHJpdmF0ZUtleT86IFVpbnQ4QXJyYXk7XG4gIHJlYWRvbmx5IF9wdWJsaWNLZXk/OiBVaW50OEFycmF5O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXk/OiBVaW50OEFycmF5LCBwdWJsaWNLZXk/OiBVaW50OEFycmF5KSB7XG4gICAgbGV0IHB1YiA9IHB1YmxpY0tleTtcbiAgICBpZiAocHViKSB7XG4gICAgICBwdWIgPSBjb21wcmVzc1B1YmxpY0tleShwdWIpO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5KSAmJiAhdGhpcy5wcml2YXRlS2V5VmVyaWZ5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGlmICgodGhpcy5fcHVibGljS2V5ID0gcHViKSAmJiAhdGhpcy5wdWJsaWNLZXlWZXJpZnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJsaWMga2V5XCIpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IEtleXBhaXJUeXBlLnNlY3AyNTZrMTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZW5lcmF0ZSgpOiBQcm9taXNlPFNlY3AyNTZrMUtleXBhaXI+IHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3AuZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpO1xuICAgIHJldHVybiBuZXcgU2VjcDI1NmsxS2V5cGFpcihwcml2YXRlS2V5LCBwdWJsaWNLZXkpO1xuICB9XG5cbiAgcHJpdmF0ZUtleVZlcmlmeShrZXkgPSB0aGlzLl9wcml2YXRlS2V5KTogYm9vbGVhbiB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIHNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWNLZXlWZXJpZnkoa2V5ID0gdGhpcy5fcHVibGljS2V5KTogYm9vbGVhbiB7XG4gICAgaWYgKGtleSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VjcC5Qb2ludC5mcm9tSGV4KGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgcHJpdmF0ZUtleSgpOiBVaW50OEFycmF5IHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleTtcbiAgfVxuXG4gIGdldCBwdWJsaWNLZXkoKTogVWludDhBcnJheSB7XG4gICAgaWYgKCF0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5O1xuICB9XG5cbiAgaGFzUHJpdmF0ZUtleSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9wcml2YXRlS2V5O1xuICB9XG59XG4iLCJleHBvcnQgZW51bSBLZXlwYWlyVHlwZSB7XG4gIHJzYSA9IDAsXG4gIGVkMjU1MTkgPSAxLFxuICBzZWNwMjU2azEgPSAyLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElLZXlwYWlyIHtcbiAgdHlwZTogS2V5cGFpclR5cGU7XG4gIHByaXZhdGVLZXk6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpY0tleTogVWludDhBcnJheTtcbiAgcHJpdmF0ZUtleVZlcmlmeSgpOiBib29sZWFuO1xuICBwdWJsaWNLZXlWZXJpZnkoKTogYm9vbGVhbjtcbiAgaGFzUHJpdmF0ZUtleSgpOiBib29sZWFuO1xufVxuIiwiaW1wb3J0IHsgTXVsdGlhZGRyIH0gZnJvbSBcIm11bHRpYWRkclwiO1xuXG5pbXBvcnQgeyBNVUxUSUFERFJfTEVOR1RIX1NJWkUgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU11bHRpYWRkcnMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBNdWx0aWFkZHJbXSB7XG4gIGNvbnN0IG11bHRpYWRkcnMgPSBbXTtcblxuICBsZXQgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IHNpemVEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhcbiAgICAgIGJ5dGVzLmJ1ZmZlcixcbiAgICAgIGluZGV4LFxuICAgICAgTVVMVElBRERSX0xFTkdUSF9TSVpFXG4gICAgKTtcbiAgICBjb25zdCBzaXplID0gc2l6ZURhdGFWaWV3LmdldFVpbnQxNigwKTtcbiAgICBpbmRleCArPSBNVUxUSUFERFJfTEVOR1RIX1NJWkU7XG5cbiAgICBjb25zdCBtdWx0aWFkZHJCeXRlcyA9IGJ5dGVzLnNsaWNlKGluZGV4LCBpbmRleCArIHNpemUpO1xuICAgIGluZGV4ICs9IHNpemU7XG5cbiAgICBjb25zdCBtdWx0aWFkZHIgPSBuZXcgTXVsdGlhZGRyKG11bHRpYWRkckJ5dGVzKTtcbiAgICBtdWx0aWFkZHJzLnB1c2gobXVsdGlhZGRyKTtcbiAgfVxuICByZXR1cm4gbXVsdGlhZGRycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU11bHRpYWRkcnMobXVsdGlhZGRyczogTXVsdGlhZGRyW10pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgdG90YWxMZW5ndGggPSBtdWx0aWFkZHJzLnJlZHVjZShcbiAgICAoYWNjLCBtYSkgPT4gYWNjICsgTVVMVElBRERSX0xFTkdUSF9TSVpFICsgbWEuYnl0ZXMubGVuZ3RoLFxuICAgIDBcbiAgKTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlcik7XG5cbiAgbGV0IGluZGV4ID0gMDtcbiAgbXVsdGlhZGRycy5mb3JFYWNoKChtdWx0aWFkZHIpID0+IHtcbiAgICBpZiAobXVsdGlhZGRyLmdldFBlZXJJZCgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG11bHRpYWRkcmAgZmllbGQgTVVTVCBub3QgY29udGFpbiBwZWVyIGlkXCIpO1xuXG4gICAgLy8gUHJlcGVuZCB0aGUgc2l6ZSBvZiB0aGUgbmV4dCBlbnRyeVxuICAgIGRhdGFWaWV3LnNldFVpbnQxNihpbmRleCwgbXVsdGlhZGRyLmJ5dGVzLmxlbmd0aCk7XG4gICAgaW5kZXggKz0gTVVMVElBRERSX0xFTkdUSF9TSVpFO1xuXG4gICAgYnl0ZXMuc2V0KG11bHRpYWRkci5ieXRlcywgaW5kZXgpO1xuICAgIGluZGV4ICs9IG11bHRpYWRkci5ieXRlcy5sZW5ndGg7XG4gIH0pO1xuXG4gIHJldHVybiBieXRlcztcbn1cbiIsIi8vIEN1c3RvbSBhbmQgYWxpYXNlZCB0eXBlcyBmb3IgRU5Sc1xuXG4vKipcbiAqIFdlIHJlcHJlc2VudCBOb2RlSWQgYXMgYSBoZXggc3RyaW5nLCBzaW5jZSBub2RlIGVxdWFsaXR5IGlzIHVzZWQgdmVyeSBoZWF2aWx5XG4gKiBhbmQgaXQgaXMgY29udmVuaWVudCB0byBpbmRleCBkYXRhIGJ5IE5vZGVJZFxuICovXG5leHBvcnQgdHlwZSBOb2RlSWQgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBTZXF1ZW5jZU51bWJlciA9IGJpZ2ludDtcblxuZXhwb3J0IHR5cGUgRU5SS2V5ID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgRU5SVmFsdWUgPSBVaW50OEFycmF5O1xuIiwiaW1wb3J0ICogYXMgc2VjcCBmcm9tIFwiQG5vYmxlL3NlY3AyNTZrMVwiO1xuXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCB7IE5vZGVJZCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduKFxuICBwcml2S2V5OiBVaW50OEFycmF5LFxuICBtc2c6IFVpbnQ4QXJyYXlcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICByZXR1cm4gc2VjcC5zaWduKGtlY2NhazI1Nihtc2cpLCBwcml2S2V5LCB7XG4gICAgZGVyOiBmYWxzZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlSWQocHViS2V5OiBVaW50OEFycmF5KTogTm9kZUlkIHtcbiAgY29uc3QgcHVibGljS2V5ID0gc2VjcC5Qb2ludC5mcm9tSGV4KHB1YktleSk7XG4gIGNvbnN0IHVuY29tcHJlc3NlZFB1YmtleSA9IHB1YmxpY0tleS50b1Jhd0J5dGVzKGZhbHNlKTtcblxuICByZXR1cm4gYnl0ZXNUb0hleChrZWNjYWsyNTYodW5jb21wcmVzc2VkUHVia2V5LnNsaWNlKDEpKSk7XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIFdha3UyIHtcbiAgcmVsYXk6IGJvb2xlYW47XG4gIHN0b3JlOiBib29sZWFuO1xuICBmaWx0ZXI6IGJvb2xlYW47XG4gIGxpZ2h0UHVzaDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVdha3UyKHByb3RvY29sczogV2FrdTIpOiBudW1iZXIge1xuICBsZXQgYnl0ZSA9IDA7XG5cbiAgaWYgKHByb3RvY29scy5saWdodFB1c2gpIGJ5dGUgKz0gMTtcbiAgYnl0ZSA9IGJ5dGUgPDwgMTtcbiAgaWYgKHByb3RvY29scy5maWx0ZXIpIGJ5dGUgKz0gMTtcbiAgYnl0ZSA9IGJ5dGUgPDwgMTtcbiAgaWYgKHByb3RvY29scy5zdG9yZSkgYnl0ZSArPSAxO1xuICBieXRlID0gYnl0ZSA8PCAxO1xuICBpZiAocHJvdG9jb2xzLnJlbGF5KSBieXRlICs9IDE7XG5cbiAgcmV0dXJuIGJ5dGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVXYWt1MihieXRlOiBudW1iZXIpOiBXYWt1MiB7XG4gIGNvbnN0IHdha3UyID0ge1xuICAgIHJlbGF5OiBmYWxzZSxcbiAgICBzdG9yZTogZmFsc2UsXG4gICAgZmlsdGVyOiBmYWxzZSxcbiAgICBsaWdodFB1c2g6IGZhbHNlLFxuICB9O1xuXG4gIGlmIChieXRlICUgMikgd2FrdTIucmVsYXkgPSB0cnVlO1xuICBieXRlID0gYnl0ZSA+PiAxO1xuICBpZiAoYnl0ZSAlIDIpIHdha3UyLnN0b3JlID0gdHJ1ZTtcbiAgYnl0ZSA9IGJ5dGUgPj4gMTtcbiAgaWYgKGJ5dGUgJSAyKSB3YWt1Mi5maWx0ZXIgPSB0cnVlO1xuICBieXRlID0gYnl0ZSA+PiAxO1xuICBpZiAoYnl0ZSAlIDIpIHdha3UyLmxpZ2h0UHVzaCA9IHRydWU7XG5cbiAgcmV0dXJuIHdha3UyO1xufVxuIiwiaW1wb3J0IExpYnAycCBmcm9tIFwibGlicDJwXCI7XG5pbXBvcnQgeyBQZWVyIH0gZnJvbSBcImxpYnAycC9zcmMvcGVlci1zdG9yZVwiO1xuXG4vKipcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyB0aGUgZ2l2ZW4gcHJvdG9jb2wuXG4gKiBVc2VmdWwgZm9yIHByb3RvY29scyBzdWNoIGFzIHN0b3JlIGFuZCBsaWdodCBwdXNoXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWxlY3RSYW5kb21QZWVyKFxuICBwZWVyc0l0ZXI6IEFzeW5jSXRlcmFibGU8UGVlcj5cbik6IFByb21pc2U8UGVlciB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBwZWVycyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHBlZXIgb2YgcGVlcnNJdGVyKSB7XG4gICAgcGVlcnMucHVzaChwZWVyKTtcbiAgfVxuXG4gIGlmIChwZWVycy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICBjb25zdCBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChwZWVycy5sZW5ndGggLSAxKSk7XG4gIHJldHVybiBwZWVyc1tpbmRleF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBwZWVycyB0aGF0IHN1cHBvcnRzIHRoZSBnaXZlbiBwcm90b2NvbC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBnZXRQZWVyc0ZvclByb3RvY29sKFxuICBsaWJwMnA6IExpYnAycCxcbiAgcHJvdG9jb2xzOiBzdHJpbmdbXVxuKTogQXN5bmNJdGVyYWJsZTxQZWVyPiB7XG4gIGZvciBhd2FpdCAoY29uc3QgcGVlciBvZiBsaWJwMnAucGVlclN0b3JlLmdldFBlZXJzKCkpIHtcbiAgICBsZXQgcGVlckZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm90b2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwZWVyLnByb3RvY29scy5pbmNsdWRlcyhwcm90b2NvbHNbaV0pKSB7XG4gICAgICAgIHBlZXJGb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBlZXJGb3VuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIHBlZXI7XG4gIH1cbn1cbiIsImltcG9ydCB7IGZyb21TdHJpbmcgfSBmcm9tIFwidWludDhhcnJheXMvZnJvbS1zdHJpbmdcIjtcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSBcInVpbnQ4YXJyYXlzL3RvLXN0cmluZ1wiO1xuXG4vKipcbiAqIENvbnZlcnQgaW5wdXQgdG8gYSBieXRlIGFycmF5LlxuICpcbiAqIEhhbmRsZXMgYm90aCBgMHhgIHByZWZpeGVkIGFuZCBub24tcHJlZml4ZWQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcgfCBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2YgaGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgX2hleCA9IGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoX2hleCwgXCJiYXNlMTZcIik7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZyAobm8gYDB4YCBwcmVmaXgpLlxuICovXG5leHBvcnQgY29uc3QgYnl0ZXNUb0hleCA9IChieXRlczogVWludDhBcnJheSk6IHN0cmluZyA9PlxuICB0b1N0cmluZyhieXRlcywgXCJiYXNlMTZcIik7XG5cbi8qKlxuICogRGVjb2RlIGJ5dGUgYXJyYXkgdG8gdXRmLTggc3RyaW5nLlxuICovXG5leHBvcnQgY29uc3QgYnl0ZXNUb1V0ZjggPSAoYjogVWludDhBcnJheSk6IHN0cmluZyA9PiB0b1N0cmluZyhiLCBcInV0ZjhcIik7XG5cbi8qKlxuICogRW5jb2RlIHV0Zi04IHN0cmluZyB0byBieXRlIGFycmF5LlxuICovXG5leHBvcnQgY29uc3QgdXRmOFRvQnl0ZXMgPSAoczogc3RyaW5nKTogVWludDhBcnJheSA9PiBmcm9tU3RyaW5nKHMsIFwidXRmOFwiKTtcbiIsImltcG9ydCB7IE5vaXNlIH0gZnJvbSBcIkBjaGFpbnNhZmUvbGlicDJwLW5vaXNlXCI7XG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgTGlicDJwLCB7IENvbm5lY3Rpb24sIExpYnAycE1vZHVsZXMsIExpYnAycE9wdGlvbnMgfSBmcm9tIFwibGlicDJwXCI7XG5pbXBvcnQgTGlicDJwQm9vdHN0cmFwIGZyb20gXCJsaWJwMnAtYm9vdHN0cmFwXCI7XG5pbXBvcnQgeyBNdXhlZFN0cmVhbSB9IGZyb20gXCJsaWJwMnAtaW50ZXJmYWNlcy9kaXN0L3NyYy9zdHJlYW0tbXV4ZXIvdHlwZXNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmU6IE5vIHR5cGVzIGF2YWlsYWJsZVxuaW1wb3J0IE1wbGV4IGZyb20gXCJsaWJwMnAtbXBsZXhcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmU6IE5vIHR5cGVzIGF2YWlsYWJsZVxuaW1wb3J0IFdlYnNvY2tldHMgZnJvbSBcImxpYnAycC13ZWJzb2NrZXRzXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlOiBObyB0eXBlcyBhdmFpbGFibGVcbmltcG9ydCBmaWx0ZXJzIGZyb20gXCJsaWJwMnAtd2Vic29ja2V0cy9zcmMvZmlsdGVyc1wiO1xuaW1wb3J0IFBpbmdTZXJ2aWNlIGZyb20gXCJsaWJwMnAvc3JjL3BpbmdcIjtcbmltcG9ydCB7IE11bHRpYWRkciwgbXVsdGlhZGRyIH0gZnJvbSBcIm11bHRpYWRkclwiO1xuaW1wb3J0IFBlZXJJZCBmcm9tIFwicGVlci1pZFwiO1xuXG5pbXBvcnQgeyBCb290c3RyYXAsIEJvb3RzdHJhcE9wdGlvbnMgfSBmcm9tIFwiLi9kaXNjb3ZlcnlcIjtcbmltcG9ydCB7IEZpbHRlckNvZGVjLCBXYWt1RmlsdGVyIH0gZnJvbSBcIi4vd2FrdV9maWx0ZXJcIjtcbmltcG9ydCB7IExpZ2h0UHVzaENvZGVjLCBXYWt1TGlnaHRQdXNoIH0gZnJvbSBcIi4vd2FrdV9saWdodF9wdXNoXCI7XG5pbXBvcnQgeyBEZWNyeXB0aW9uTWV0aG9kLCBXYWt1TWVzc2FnZSB9IGZyb20gXCIuL3dha3VfbWVzc2FnZVwiO1xuaW1wb3J0IHsgUmVsYXlDb2RlY3MsIFdha3VSZWxheSB9IGZyb20gXCIuL3dha3VfcmVsYXlcIjtcbmltcG9ydCB7IFJlbGF5UGluZ0NvbnRlbnRUb3BpYyB9IGZyb20gXCIuL3dha3VfcmVsYXkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBTdG9yZUNvZGVjcywgV2FrdVN0b3JlIH0gZnJvbSBcIi4vd2FrdV9zdG9yZVwiO1xuXG5jb25zdCB3ZWJzb2NrZXRzVHJhbnNwb3J0S2V5ID0gV2Vic29ja2V0cy5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcblxuZXhwb3J0IGNvbnN0IERlZmF1bHRQaW5nS2VlcEFsaXZlVmFsdWVTZWNzID0gMDtcbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVsYXlLZWVwQWxpdmVWYWx1ZVNlY3MgPSA1ICogNjA7XG5cbi8qKlxuICogRGVmYXVsdFB1YlN1YlRvcGljIGlzIHRoZSBkZWZhdWx0IGdvc3NpcHN1YiB0b3BpYyB0byB1c2UgZm9yIFdha3UuXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0UHViU3ViVG9waWMgPSBcIi93YWt1LzIvZGVmYXVsdC13YWt1L3Byb3RvXCI7XG5cbmNvbnN0IGRiZyA9IGRlYnVnKFwid2FrdTp3YWt1XCIpO1xuXG5leHBvcnQgZW51bSBQcm90b2NvbHMge1xuICBSZWxheSA9IFwicmVsYXlcIixcbiAgU3RvcmUgPSBcInN0b3JlXCIsXG4gIExpZ2h0UHVzaCA9IFwibGlnaHRwdXNoXCIsXG4gIEZpbHRlciA9IFwiZmlsdGVyXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgUHViU3ViIFRvcGljIHRvIHVzZS4gRGVmYXVsdHMgdG8ge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY30uXG4gICAqXG4gICAqIE9uZSBhbmQgb25seSBvbmUgcHVic3ViIHRvcGljIGlzIHVzZWQgYnkgV2FrdS4gVGhpcyBpcyB1c2VkIGJ5OlxuICAgKiAtIFdha3VSZWxheSB0byByZWNlaXZlLCByb3V0ZSBhbmQgc2VuZCBtZXNzYWdlcyxcbiAgICogLSBXYWt1TGlnaHRQdXNoIHRvIHNlbmQgbWVzc2FnZXMsXG4gICAqIC0gV2FrdVN0b3JlIHRvIHJldHJpZXZlIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhlIGRlZmF1bHQgcHVic3ViIHRvcGljIGlzIHJlY29tbWVuZGVkLlxuICAgKiBTZWUgW1dha3UgdjIgVG9waWMgVXNhZ2UgUmVjb21tZW5kYXRpb25zXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjMvKSBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY31cbiAgICovXG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xuICAvKipcbiAgICogU2V0IGtlZXAgYWxpdmUgZnJlcXVlbmN5IGluIHNlY29uZHM6IFdha3Ugd2lsbCBzZW5kIGEgYC9pcGZzL3BpbmcvMS4wLjBgXG4gICAqIHJlcXVlc3QgdG8gZWFjaCBwZWVyIGFmdGVyIHRoZSBzZXQgbnVtYmVyIG9mIHNlY29uZHMuIFNldCB0byAwIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2Vjc31cbiAgICovXG4gIHBpbmdLZWVwQWxpdmU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBTZXQga2VlcCBhbGl2ZSBmcmVxdWVuY3kgaW4gc2Vjb25kczogV2FrdSB3aWxsIHNlbmQgYSBwaW5nIG1lc3NhZ2Ugb3ZlclxuICAgKiByZWxheSB0byBlYWNoIHBlZXIgYWZ0ZXIgdGhlIHNldCBudW1iZXIgb2Ygc2Vjb25kcy4gU2V0IHRvIDAgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIERlZmF1bHRSZWxheUtlZXBBbGl2ZVZhbHVlU2Vjc31cbiAgICovXG4gIHJlbGF5S2VlcEFsaXZlPzogbnVtYmVyO1xuICAvKipcbiAgICogWW91IGNhbiBwYXNzIG9wdGlvbnMgdG8gdGhlIGBMaWJwMnBgIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFdha3V9IHVzaW5nIHRoZSB7QGxpbmsgQ3JlYXRlT3B0aW9ucy5saWJwMnB9IHByb3BlcnR5LlxuICAgKiBUaGlzIHByb3BlcnR5IGlzIHRoZSBzYW1lIHR5cGUgdGhhbiB0aGUgb25lIHBhc3NlZCB0byBbYExpYnAycC5jcmVhdGVgXShodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL2pzLWxpYnAycC9ibG9iL21hc3Rlci9kb2MvQVBJLm1kI2NyZWF0ZSlcbiAgICogYXBhcnQgdGhhdCB3ZSBtYWRlIHRoZSBgbW9kdWxlc2AgcHJvcGVydHkgb3B0aW9uYWwgYW5kIHBhcnRpYWwsXG4gICAqIGFsbG93aW5nIGl0cyBvbWlzc2lvbiBhbmQgbGV0dGluZyBXYWt1IHNldCBnb29kIGRlZmF1bHRzLlxuICAgKiBOb3RlcyB0aGF0IHNvbWUgdmFsdWVzIGFyZSBvdmVycmlkZGVuIGJ5IHtAbGluayBXYWt1fSB0byBlbnN1cmUgaXQgaW1wbGVtZW50cyB0aGUgV2FrdSBwcm90b2NvbC5cbiAgICovXG4gIGxpYnAycD86IE9taXQ8TGlicDJwT3B0aW9ucyAmIGltcG9ydChcImxpYnAycFwiKS5DcmVhdGVPcHRpb25zLCBcIm1vZHVsZXNcIj4gJiB7XG4gICAgbW9kdWxlcz86IFBhcnRpYWw8TGlicDJwTW9kdWxlcz47XG4gIH07XG4gIC8qKlxuICAgKiBCeXRlIGFycmF5IHVzZWQgYXMga2V5IGZvciB0aGUgbm9pc2UgcHJvdG9jb2wgdXNlZCBmb3IgY29ubmVjdGlvbiBlbmNyeXB0aW9uXG4gICAqIGJ5IFtgTGlicDJwLmNyZWF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWJwMnAvanMtbGlicDJwL2Jsb2IvbWFzdGVyL2RvYy9BUEkubWQjY3JlYXRlKVxuICAgKiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgdGVzdCBwdXJwb3NlcyB0byBub3QgcnVuIG91dCBvZiBlbnRyb3B5IGR1cmluZyBDSSBydW5zLlxuICAgKi9cbiAgc3RhdGljTm9pc2VLZXk/OiBVaW50OEFycmF5O1xuICAvKipcbiAgICogVXNlIGxpYnAycC1ib290c3RyYXAgdG8gZGlzY292ZXIgYW5kIGNvbm5lY3QgdG8gbmV3IG5vZGVzLlxuICAgKlxuICAgKiBTZWUgW1tCb290c3RyYXBPcHRpb25zXV0gZm9yIGF2YWlsYWJsZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBOb3RlOiBJdCBvdmVycmlkZXMgYW55IG90aGVyIHBlZXJEaXNjb3ZlcnkgbW9kdWxlcyB0aGF0IG1heSBoYXZlIGJlZW4gc2V0IHZpYVxuICAgKiB7QGxpbmsgQ3JlYXRlT3B0aW9ucy5saWJwMnB9LlxuICAgKi9cbiAgYm9vdHN0cmFwPzogQm9vdHN0cmFwT3B0aW9ucztcbiAgZGVjcnlwdGlvbktleXM/OiBBcnJheTxVaW50OEFycmF5IHwgc3RyaW5nPjtcbn1cblxuZXhwb3J0IGNsYXNzIFdha3Uge1xuICBwdWJsaWMgbGlicDJwOiBMaWJwMnA7XG4gIHB1YmxpYyByZWxheTogV2FrdVJlbGF5O1xuICBwdWJsaWMgc3RvcmU6IFdha3VTdG9yZTtcbiAgcHVibGljIGZpbHRlcjogV2FrdUZpbHRlcjtcbiAgcHVibGljIGxpZ2h0UHVzaDogV2FrdUxpZ2h0UHVzaDtcblxuICBwcml2YXRlIHBpbmdLZWVwQWxpdmVUaW1lcnM6IHtcbiAgICBbcGVlcjogc3RyaW5nXTogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuICB9O1xuICBwcml2YXRlIHJlbGF5S2VlcEFsaXZlVGltZXJzOiB7XG4gICAgW3BlZXI6IHN0cmluZ106IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcbiAgfTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIG9wdGlvbnM6IENyZWF0ZU9wdGlvbnMsXG4gICAgbGlicDJwOiBMaWJwMnAsXG4gICAgc3RvcmU6IFdha3VTdG9yZSxcbiAgICBsaWdodFB1c2g6IFdha3VMaWdodFB1c2gsXG4gICAgZmlsdGVyOiBXYWt1RmlsdGVyXG4gICkge1xuICAgIHRoaXMubGlicDJwID0gbGlicDJwO1xuICAgIHRoaXMucmVsYXkgPSBsaWJwMnAucHVic3ViIGFzIHVua25vd24gYXMgV2FrdVJlbGF5O1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICB0aGlzLmxpZ2h0UHVzaCA9IGxpZ2h0UHVzaDtcbiAgICB0aGlzLnBpbmdLZWVwQWxpdmVUaW1lcnMgPSB7fTtcbiAgICB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzID0ge307XG5cbiAgICBjb25zdCBwaW5nS2VlcEFsaXZlID1cbiAgICAgIG9wdGlvbnMucGluZ0tlZXBBbGl2ZSB8fCBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2VjcztcbiAgICBjb25zdCByZWxheUtlZXBBbGl2ZSA9XG4gICAgICBvcHRpb25zLnJlbGF5S2VlcEFsaXZlIHx8IERlZmF1bHRSZWxheUtlZXBBbGl2ZVZhbHVlU2VjcztcblxuICAgIGxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5vbihcInBlZXI6Y29ubmVjdFwiLCAoY29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgdGhpcy5zdGFydEtlZXBBbGl2ZShjb25uZWN0aW9uLnJlbW90ZVBlZXIsIHBpbmdLZWVwQWxpdmUsIHJlbGF5S2VlcEFsaXZlKTtcbiAgICB9KTtcblxuICAgIGxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5vbihcInBlZXI6ZGlzY29ubmVjdFwiLCAoY29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgdGhpcy5zdG9wS2VlcEFsaXZlKGNvbm5lY3Rpb24ucmVtb3RlUGVlcik7XG4gICAgfSk7XG5cbiAgICBvcHRpb25zPy5kZWNyeXB0aW9uS2V5cz8uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLmFkZERlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHN0YXJ0IG5ldyB3YWt1IG5vZGUuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKG9wdGlvbnM/OiBDcmVhdGVPcHRpb25zKTogUHJvbWlzZTxXYWt1PiB7XG4gICAgLy8gR2V0IGFuIG9iamVjdCBpbiBjYXNlIG9wdGlvbnMgb3IgbGlicDJwIGFyZSB1bmRlZmluZWRcbiAgICBjb25zdCBsaWJwMnBPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucz8ubGlicDJwKTtcblxuICAgIC8vIERlZmF1bHQgZm9yIFdlYnNvY2tldCBmaWx0ZXIgaXMgYGFsbGA6XG4gICAgLy8gUmV0dXJucyBhbGwgVENQIGFuZCBETlMgYmFzZWQgYWRkcmVzc2VzLCBib3RoIHdpdGggd3Mgb3Igd3NzLlxuICAgIGxpYnAycE9wdHMuY29uZmlnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgdHJhbnNwb3J0OiB7XG4gICAgICAgICAgW3dlYnNvY2tldHNUcmFuc3BvcnRLZXldOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnMuYWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgb3B0aW9ucz8ubGlicDJwPy5jb25maWdcbiAgICApO1xuXG4gICAgLy8gUGFzcyBwdWJzdWIgdG9waWMgdG8gcmVsYXlcbiAgICBpZiAob3B0aW9ucz8ucHViU3ViVG9waWMpIHtcbiAgICAgIGxpYnAycE9wdHMuY29uZmlnLnB1YnN1YiA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHsgcHViU3ViVG9waWM6IG9wdGlvbnMucHViU3ViVG9waWMgfSxcbiAgICAgICAgbGlicDJwT3B0cy5jb25maWcucHVic3ViXG4gICAgICApO1xuICAgIH1cblxuICAgIGxpYnAycE9wdHMubW9kdWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnM/LmxpYnAycD8ubW9kdWxlcyk7XG5cbiAgICAvLyBEZWZhdWx0IHRyYW5zcG9ydCBmb3IgbGlicDJwIGlzIFdlYnNvY2tldHNcbiAgICBsaWJwMnBPcHRzLm1vZHVsZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICB0cmFuc3BvcnQ6IFtXZWJzb2NrZXRzXSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zPy5saWJwMnA/Lm1vZHVsZXNcbiAgICApO1xuXG4gICAgLy8gc3RyZWFtTXV4ZXIsIGNvbm5lY3Rpb24gZW5jcnlwdGlvbiBhbmQgcHVic3ViIGFyZSBvdmVycmlkZGVuXG4gICAgLy8gYXMgdGhvc2UgYXJlIHRoZSBvbmx5IG9uZXMgY3VycmVudGx5IHN1cHBvcnRlZCBieSBXYWt1IG5vZGVzLlxuICAgIGxpYnAycE9wdHMubW9kdWxlcyA9IE9iamVjdC5hc3NpZ24obGlicDJwT3B0cy5tb2R1bGVzLCB7XG4gICAgICBzdHJlYW1NdXhlcjogW01wbGV4XSxcbiAgICAgIGNvbm5FbmNyeXB0aW9uOiBbbmV3IE5vaXNlKG9wdGlvbnM/LnN0YXRpY05vaXNlS2V5KV0sXG4gICAgICBwdWJzdWI6IFdha3VSZWxheSxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zPy5ib290c3RyYXApIHtcbiAgICAgIGNvbnN0IGJvb3RzdHJhcCA9IG5ldyBCb290c3RyYXAob3B0aW9ucz8uYm9vdHN0cmFwKTtcblxuICAgICAgaWYgKGJvb3RzdHJhcC5nZXRCb290c3RyYXBQZWVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IGF3YWl0IGJvb3RzdHJhcC5nZXRCb290c3RyYXBQZWVycygpO1xuXG4gICAgICAgICAgLy8gTm90ZTogdGhpcyBvdmVycmlkZXMgYW55IG90aGVyIHBlZXIgZGlzY292ZXJcbiAgICAgICAgICBsaWJwMnBPcHRzLm1vZHVsZXMgPSBPYmplY3QuYXNzaWduKGxpYnAycE9wdHMubW9kdWxlcywge1xuICAgICAgICAgICAgcGVlckRpc2NvdmVyeTogW0xpYnAycEJvb3RzdHJhcF0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBsaWJwMnBPcHRzLmNvbmZpZy5wZWVyRGlzY292ZXJ5ID0ge1xuICAgICAgICAgICAgW0xpYnAycEJvb3RzdHJhcC50YWddOiB7XG4gICAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkYmcoXCJGYWlsZWQgdG8gcmV0cmlldmUgYm9vdHN0cmFwIG5vZGVzXCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmU6IG1vZHVsZXMgcHJvcGVydHkgaXMgY29ycmVjdGx5IHNldCB0aGFua3MgdG8gdm9vZG9vXG4gICAgY29uc3QgbGlicDJwID0gYXdhaXQgTGlicDJwLmNyZWF0ZShsaWJwMnBPcHRzKTtcblxuICAgIGNvbnN0IHdha3VTdG9yZSA9IG5ldyBXYWt1U3RvcmUobGlicDJwLCB7XG4gICAgICBwdWJTdWJUb3BpYzogb3B0aW9ucz8ucHViU3ViVG9waWMsXG4gICAgfSk7XG4gICAgY29uc3Qgd2FrdUxpZ2h0UHVzaCA9IG5ldyBXYWt1TGlnaHRQdXNoKGxpYnAycCk7XG4gICAgY29uc3Qgd2FrdUZpbHRlciA9IG5ldyBXYWt1RmlsdGVyKGxpYnAycCk7XG5cbiAgICBhd2FpdCBsaWJwMnAuc3RhcnQoKTtcblxuICAgIHJldHVybiBuZXcgV2FrdShcbiAgICAgIG9wdGlvbnMgPyBvcHRpb25zIDoge30sXG4gICAgICBsaWJwMnAsXG4gICAgICB3YWt1U3RvcmUsXG4gICAgICB3YWt1TGlnaHRQdXNoLFxuICAgICAgd2FrdUZpbHRlclxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGlhbHMgdG8gdGhlIHByb3ZpZGVkIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSBwZWVyIFRoZSBwZWVyIHRvIGRpYWxcbiAgICogQHBhcmFtIHByb3RvY29scyBXYWt1IHByb3RvY29scyB3ZSBleHBlY3QgZnJvbSB0aGUgcGVlcjsgRGVmYXVsdCB0byBSZWxheVxuICAgKi9cbiAgYXN5bmMgZGlhbChcbiAgICBwZWVyOiBQZWVySWQgfCBNdWx0aWFkZHIgfCBzdHJpbmcsXG4gICAgcHJvdG9jb2xzPzogUHJvdG9jb2xzW11cbiAgKTogUHJvbWlzZTx7XG4gICAgc3RyZWFtOiBNdXhlZFN0cmVhbTtcbiAgICBwcm90b2NvbDogc3RyaW5nO1xuICB9PiB7XG4gICAgY29uc3QgX3Byb3RvY29scyA9IHByb3RvY29scyA/PyBbUHJvdG9jb2xzLlJlbGF5XTtcblxuICAgIGNvbnN0IGNvZGVjczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoX3Byb3RvY29scy5pbmNsdWRlcyhQcm90b2NvbHMuUmVsYXkpKSB7XG4gICAgICBSZWxheUNvZGVjcy5mb3JFYWNoKChjb2RlYykgPT4gY29kZWNzLnB1c2goY29kZWMpKTtcbiAgICB9XG4gICAgaWYgKF9wcm90b2NvbHMuaW5jbHVkZXMoUHJvdG9jb2xzLlN0b3JlKSkge1xuICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBPYmplY3QudmFsdWVzKFN0b3JlQ29kZWNzKSkge1xuICAgICAgICBjb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfcHJvdG9jb2xzLmluY2x1ZGVzKFByb3RvY29scy5MaWdodFB1c2gpKSB7XG4gICAgICBjb2RlY3MucHVzaChMaWdodFB1c2hDb2RlYyk7XG4gICAgfVxuICAgIGlmIChfcHJvdG9jb2xzLmluY2x1ZGVzKFByb3RvY29scy5GaWx0ZXIpKSB7XG4gICAgICBjb2RlY3MucHVzaChGaWx0ZXJDb2RlYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlicDJwLmRpYWxQcm90b2NvbChwZWVyLCBjb2RlY3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwZWVyIHRvIGFkZHJlc3MgYm9vaywgaXQgd2lsbCBiZSBhdXRvLWRpYWxlZCBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIGFkZFBlZXJUb0FkZHJlc3NCb29rKFxuICAgIHBlZXJJZDogUGVlcklkIHwgc3RyaW5nLFxuICAgIG11bHRpYWRkcnM6IE11bHRpYWRkcltdIHwgc3RyaW5nW11cbiAgKTogdm9pZCB7XG4gICAgbGV0IHBlZXI7XG4gICAgaWYgKHR5cGVvZiBwZWVySWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBlZXIgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVySWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyID0gcGVlcklkO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzZXMgPSBtdWx0aWFkZHJzLm1hcCgoYWRkcjogTXVsdGlhZGRyIHwgc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGFkZHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG11bHRpYWRkcihhZGRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubGlicDJwLnBlZXJTdG9yZS5hZGRyZXNzQm9vay5zZXQocGVlciwgYWRkcmVzc2VzKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3AoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMubGlicDJwLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGRlY3J5cHRpb24ga2V5IHRvIGF0dGVtcHQgZGVjcnlwdGlvbiBvZiBtZXNzYWdlcyByZWNlaXZlZCB2aWFcbiAgICogW1tXYWt1UmVsYXldXSBhbmQgW1tXYWt1U3RvcmVdXS4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpYyBrZXkuXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgYWRkRGVjcnlwdGlvbktleShcbiAgICBrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgbWV0aG9kPzogRGVjcnlwdGlvbk1ldGhvZDsgY29udGVudFRvcGljcz86IHN0cmluZ1tdIH1cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5yZWxheS5hZGREZWNyeXB0aW9uS2V5KGtleSwgb3B0aW9ucyk7XG4gICAgdGhpcy5zdG9yZS5hZGREZWNyeXB0aW9uS2V5KGtleSwgb3B0aW9ucyk7XG4gICAgdGhpcy5maWx0ZXIuYWRkRGVjcnlwdGlvbktleShrZXksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRlY3J5cHRpb24ga2V5IHRoYXQgd2FzIHVzZWQgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzXG4gICAqIHJlY2VpdmVkIHZpYSBbW1dha3VSZWxheV1dIG9yIFtbV2FrdVN0b3JlXV0uXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgZGVsZXRlRGVjcnlwdGlvbktleShrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJlbGF5LmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB0aGlzLmZpbHRlci5kZWxldGVEZWNyeXB0aW9uS2V5KGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsb2NhbCBtdWx0aWFkZHIgd2l0aCBwZWVyIGlkIG9uIHdoaWNoIGxpYnAycCBpcyBsaXN0ZW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3MgaWYgbGlicDJwIGlzIG5vdCBsaXN0ZW5pbmcgb24gbG9jYWxob3N0LlxuICAgKi9cbiAgZ2V0TG9jYWxNdWx0aWFkZHJXaXRoSUQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBsb2NhbE11bHRpYWRkciA9IHRoaXMubGlicDJwLm11bHRpYWRkcnMuZmluZCgoYWRkcikgPT5cbiAgICAgIGFkZHIudG9TdHJpbmcoKS5tYXRjaCgvMTI3XFwuMFxcLjBcXC4xLylcbiAgICApO1xuICAgIGlmICghbG9jYWxNdWx0aWFkZHIgfHwgbG9jYWxNdWx0aWFkZHIudG9TdHJpbmcoKSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgXCJOb3QgbGlzdGVuaW5nIG9uIGxvY2FsaG9zdFwiO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxNdWx0aWFkZHIgKyBcIi9wMnAvXCIgKyB0aGlzLmxpYnAycC5wZWVySWQudG9CNThTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciBhIHJlbW90ZSBwZWVyIHRvIGJlIHJlYWR5IGdpdmVuIHRoZSBwYXNzZWQgcHJvdG9jb2xzLlxuICAgKiBVc2VmdWwgd2hlbiB1c2luZyB0aGUgW1tDcmVhdGVPcHRpb25zLmJvb3RzdHJhcF1dIHdpdGggW1tXYWt1LmNyZWF0ZV1dLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvdG9jb2xzIFRoZSBwcm90b2NvbHMgdGhhdCBuZWVkIHRvIGJlIGVuYWJsZWQgYnkgcmVtb3RlIHBlZXJzLlxuICAgKiBAcGFyYW0gdGltZW91dE1zIEEgdGltZW91dCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCAqKnJlc29sdmVzKiogaWYgYWxsIGRlc2lyZWQgcHJvdG9jb2xzIGFyZSBmdWxmaWxsZWQgYnlcbiAgICogcmVtb3RlIG5vZGVzLCAqKnJlamVjdHMqKiBpZiB0aGUgdGltZW91dE1zIGlzIHJlYWNoZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IFJlbW90ZSBwZWVyIG11c3QgaGF2ZSBXYWt1IFJlbGF5IGVuYWJsZWQgYW5kIG5vIHRpbWUgb3V0IGlzIGFwcGxpZWQuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUmVtb3RlUGVlcihcbiAgICBwcm90b2NvbHM/OiBQcm90b2NvbHNbXSxcbiAgICB0aW1lb3V0TXM/OiBudW1iZXJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcHJvdG9jb2xzID0gcHJvdG9jb2xzID8/IFtQcm90b2NvbHMuUmVsYXldO1xuXG4gICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xuXG4gICAgaWYgKHByb3RvY29scy5pbmNsdWRlcyhQcm90b2NvbHMuUmVsYXkpKSB7XG4gICAgICBjb25zdCBwZWVycyA9IHRoaXMucmVsYXkuZ2V0UGVlcnMoKTtcblxuICAgICAgaWYgKHBlZXJzLnNpemUgPT0gMCkge1xuICAgICAgICAvLyBObyBwZWVyIHlldCBhdmFpbGFibGUsIHdhaXQgZm9yIGEgc3Vic2NyaXB0aW9uXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHRoaXMubGlicDJwLnB1YnN1Yi5vbmNlKFwicHVic3ViOnN1YnNjcmlwdGlvbi1jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVtb3RlIHBlZXIgc3Vic2NyaWJlZCB0byB0b3BpYywgbm93IHdhaXQgZm9yIGEgaGVhcnRiZWF0XG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBtZXNoIGlzIHVwZGF0ZWQgYW5kIHRoZSByZW1vdGUgcGVlciBhZGRlZCB0byBpdFxuICAgICAgICAgICAgdGhpcy5saWJwMnAucHVic3ViLm9uY2UoXCJnb3NzaXBzdWI6aGVhcnRiZWF0XCIsIHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmluY2x1ZGVzKFByb3RvY29scy5TdG9yZSkpIHtcbiAgICAgIGNvbnN0IHN0b3JlUHJvbWlzZSA9IChhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGVlciBvZiB0aGlzLnN0b3JlLnBlZXJzKSB7XG4gICAgICAgICAgZGJnKFwiU3RvcmUgcGVlciBmb3VuZFwiLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgcHJvbWlzZXMucHVzaChzdG9yZVByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChwcm90b2NvbHMuaW5jbHVkZXMoUHJvdG9jb2xzLkxpZ2h0UHVzaCkpIHtcbiAgICAgIGNvbnN0IGxpZ2h0UHVzaFByb21pc2UgPSAoYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBlZXIgb2YgdGhpcy5saWdodFB1c2gucGVlcnMpIHtcbiAgICAgICAgICBkYmcoXCJMaWdodCBQdXNoIHBlZXIgZm91bmRcIiwgcGVlci5pZC50b0I1OFN0cmluZygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICAgIHByb21pc2VzLnB1c2gobGlnaHRQdXNoUHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29scy5pbmNsdWRlcyhQcm90b2NvbHMuRmlsdGVyKSkge1xuICAgICAgY29uc3QgZmlsdGVyUHJvbWlzZSA9IChhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGVlciBvZiB0aGlzLmZpbHRlci5wZWVycykge1xuICAgICAgICAgIGRiZyhcIkZpbHRlciBwZWVyIGZvdW5kXCIsIHBlZXIuaWQudG9CNThTdHJpbmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBwcm9taXNlcy5wdXNoKGZpbHRlclByb21pc2UpO1xuICAgIH1cblxuICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgIGF3YWl0IHJlamVjdE9uVGltZW91dChcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLFxuICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgIFwiVGltZWQgb3V0IHdhaXRpbmcgZm9yIGEgcmVtb3RlIHBlZXIuXCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0S2VlcEFsaXZlKFxuICAgIHBlZXJJZDogUGVlcklkLFxuICAgIHBpbmdQZXJpb2RTZWNzOiBudW1iZXIsXG4gICAgcmVsYXlQZXJpb2RTZWNzOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gSnVzdCBpbiBjYXNlIGEgdGltZXIgYWxyZWFkeSBleGlzdCBmb3IgdGhpcyBwZWVyXG4gICAgdGhpcy5zdG9wS2VlcEFsaXZlKHBlZXJJZCk7XG5cbiAgICBjb25zdCBwZWVySWRTdHIgPSBwZWVySWQudG9CNThTdHJpbmcoKTtcblxuICAgIGlmIChwaW5nUGVyaW9kU2VjcyAhPT0gMCkge1xuICAgICAgY29uc3QgcGluZ1NlcnZpY2UgPSBuZXcgUGluZ1NlcnZpY2UodGhpcy5saWJwMnApO1xuICAgICAgdGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHBpbmdTZXJ2aWNlLnBpbmcocGVlcklkKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGRiZyhgUGluZyBmYWlsZWQgKCR7cGVlcklkU3RyfSlgLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBwaW5nUGVyaW9kU2VjcyAqIDEwMDApO1xuICAgIH1cblxuICAgIGlmIChyZWxheVBlcmlvZFNlY3MgIT09IDApIHtcbiAgICAgIHRoaXMucmVsYXlLZWVwQWxpdmVUaW1lcnNbcGVlcklkU3RyXSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgV2FrdU1lc3NhZ2UuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KCksIFJlbGF5UGluZ0NvbnRlbnRUb3BpYykudGhlbihcbiAgICAgICAgICAod2FrdU1zZykgPT4gdGhpcy5yZWxheS5zZW5kKHdha3VNc2cpXG4gICAgICAgICk7XG4gICAgICB9LCByZWxheVBlcmlvZFNlY3MgKiAxMDAwKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0b3BLZWVwQWxpdmUocGVlcklkOiBQZWVySWQpOiB2b2lkIHtcbiAgICBjb25zdCBwZWVySWRTdHIgPSBwZWVySWQudG9CNThTdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnBpbmdLZWVwQWxpdmVUaW1lcnNbcGVlcklkU3RyXSkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBpbmdLZWVwQWxpdmVUaW1lcnNbcGVlcklkU3RyXSk7XG4gICAgICBkZWxldGUgdGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVsYXlLZWVwQWxpdmVUaW1lcnNbcGVlcklkU3RyXSkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pO1xuICAgICAgZGVsZXRlIHRoaXMucmVsYXlLZWVwQWxpdmVUaW1lcnNbcGVlcklkU3RyXTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYXdhaXRUaW1lb3V0ID0gKG1zOiBudW1iZXIsIHJlamVjdFJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PlxuICBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QocmVqZWN0UmVhc29uKSwgbXMpKTtcblxuY29uc3QgcmVqZWN0T25UaW1lb3V0ID0gKFxuICBwcm9taXNlOiBQcm9taXNlPGFueT4sXG4gIHRpbWVvdXRNczogbnVtYmVyLFxuICByZWplY3RSZWFzb246IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiA9PlxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UsIGF3YWl0VGltZW91dCh0aW1lb3V0TXMsIHJlamVjdFJlYXNvbildKTtcbiIsImltcG9ydCB7IFJlYWRlciB9IGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tIFwidXVpZFwiO1xuXG5pbXBvcnQgKiBhcyBwcm90byBmcm9tIFwiLi4vLi4vcHJvdG8vd2FrdS92Mi9maWx0ZXJcIjtcblxuZXhwb3J0IHR5cGUgQ29udGVudEZpbHRlciA9IHtcbiAgY29udGVudFRvcGljOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEZpbHRlclJQQyByZXByZXNlbnRzIGEgbWVzc2FnZSBjb25mb3JtaW5nIHRvIHRoZSBXYWt1IEZpbHRlciBwcm90b2NvbFxuICovXG5leHBvcnQgY2xhc3MgRmlsdGVyUlBDIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm90bzogcHJvdG8uRmlsdGVyUlBDKSB7fVxuXG4gIHN0YXRpYyBjcmVhdGVSZXF1ZXN0KFxuICAgIHRvcGljOiBzdHJpbmcsXG4gICAgY29udGVudEZpbHRlcnM6IENvbnRlbnRGaWx0ZXJbXSxcbiAgICByZXF1ZXN0SWQ/OiBzdHJpbmcsXG4gICAgc3Vic2NyaWJlID0gdHJ1ZVxuICApOiBGaWx0ZXJSUEMge1xuICAgIHJldHVybiBuZXcgRmlsdGVyUlBDKHtcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkIHx8IHV1aWQoKSxcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICB0b3BpYyxcbiAgICAgICAgY29udGVudEZpbHRlcnMsXG4gICAgICB9LFxuICAgICAgcHVzaDogdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyBVaW50OEFycmF5IG9mIGJ5dGVzIGZyb20gYSBGaWx0ZXJSUEMgbWVzc2FnZVxuICAgKiBAcmV0dXJucyBGaWx0ZXJSUENcbiAgICovXG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBGaWx0ZXJSUEMge1xuICAgIGNvbnN0IHJlcyA9IHByb3RvLkZpbHRlclJQQy5kZWNvZGUoUmVhZGVyLmNyZWF0ZShieXRlcykpO1xuICAgIHJldHVybiBuZXcgRmlsdGVyUlBDKHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIHRoZSBjdXJyZW50IEZpbHRlclJQQyByZXF1ZXN0IHRvIGJ5dGVzXG4gICAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAgICovXG4gIGVuY29kZSgpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gcHJvdG8uRmlsdGVyUlBDLmVuY29kZSh0aGlzLnByb3RvKS5maW5pc2goKTtcbiAgfVxuXG4gIGdldCBwdXNoKCk6IHByb3RvLk1lc3NhZ2VQdXNoIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5wdXNoO1xuICB9XG5cbiAgZ2V0IHJlcXVlc3RJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnByb3RvLnJlcXVlc3RJZDtcbiAgfVxufVxuIiwiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IGxwIGZyb20gXCJpdC1sZW5ndGgtcHJlZml4ZWRcIjtcbmltcG9ydCB7IHBpcGUgfSBmcm9tIFwiaXQtcGlwZVwiO1xuaW1wb3J0IExpYnAycCwgeyBNdXhlZFN0cmVhbSB9IGZyb20gXCJsaWJwMnBcIjtcbmltcG9ydCB7IFBlZXIsIFBlZXJJZCB9IGZyb20gXCJsaWJwMnAvc3JjL3BlZXItc3RvcmVcIjtcblxuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgYXMgV2FrdU1lc3NhZ2VQcm90byB9IGZyb20gXCIuLi8uLi9wcm90by93YWt1L3YyL21lc3NhZ2VcIjtcbmltcG9ydCB7IGdldFBlZXJzRm9yUHJvdG9jb2wsIHNlbGVjdFJhbmRvbVBlZXIgfSBmcm9tIFwiLi4vc2VsZWN0X3BlZXJcIjtcbmltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gXCIuLi93YWt1XCI7XG5pbXBvcnQgeyBEZWNyeXB0aW9uTWV0aG9kLCBXYWt1TWVzc2FnZSB9IGZyb20gXCIuLi93YWt1X21lc3NhZ2VcIjtcblxuaW1wb3J0IHsgQ29udGVudEZpbHRlciwgRmlsdGVyUlBDIH0gZnJvbSBcIi4vZmlsdGVyX3JwY1wiO1xuXG5leHBvcnQgY29uc3QgRmlsdGVyQ29kZWMgPSBcIi92YWMvd2FrdS9maWx0ZXIvMi4wLjAtYmV0YTFcIjtcblxuY29uc3QgbG9nID0gZGVidWcoXCJ3YWt1OmZpbHRlclwiKTtcblxudHlwZSBGaWx0ZXJTdWJzY3JpcHRpb25PcHRzID0ge1xuICAvKipcbiAgICogVGhlIFB1YnN1YiB0b3BpYyBmb3IgdGhlIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcHVic3ViVG9waWM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IHNwZWNpZnkgYSBQZWVySWQgZm9yIHRoZSBzdWJzY3JpcHRpb24uIElmIG5vdCBpbmNsdWRlZCwgd2lsbCB1c2UgYSByYW5kb20gcGVlci5cbiAgICovXG4gIHBlZXJJZD86IFBlZXJJZDtcbn07XG5cbnR5cGUgRmlsdGVyQ2FsbGJhY2sgPSAobXNnOiBXYWt1TWVzc2FnZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG5cbnR5cGUgVW5zdWJzY3JpYmVGdW5jdGlvbiA9ICgpID0+IFByb21pc2U8dm9pZD47XG5cbi8qKlxuICogSW1wbGVtZW50cyBjbGllbnQgc2lkZSBvZiB0aGUgW1dha3UgdjIgRmlsdGVyIHByb3RvY29sXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTIvKS5cbiAqXG4gKiBOb3RlIHRoaXMgY3VycmVudGx5IG9ubHkgd29ya3MgaW4gTm9kZUpTIHdoZW4gdGhlIFdha3Ugbm9kZSBpcyBsaXN0ZW5pbmcgb24gYSBwb3J0LCBzZWU6XG4gKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0dXMtaW0vZ28td2FrdS9pc3N1ZXMvMjQ1XG4gKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0dXMtaW0vbndha3UvaXNzdWVzLzk0OFxuICovXG5leHBvcnQgY2xhc3MgV2FrdUZpbHRlciB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogTWFwPHN0cmluZywgRmlsdGVyQ2FsbGJhY2s+O1xuICBwdWJsaWMgZGVjcnlwdGlvbktleXM6IE1hcDxcbiAgICBVaW50OEFycmF5LFxuICAgIHsgbWV0aG9kPzogRGVjcnlwdGlvbk1ldGhvZDsgY29udGVudFRvcGljcz86IHN0cmluZ1tdIH1cbiAgPjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGlicDJwOiBMaWJwMnApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZWNyeXB0aW9uS2V5cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmxpYnAycC5oYW5kbGUoRmlsdGVyQ29kZWMsIHRoaXMub25SZXF1ZXN0LmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb250ZW50VG9waWNzIEFycmF5IG9mIENvbnRlbnRUb3BpY3MgdG8gc3Vic2NyaWJlIHRvLiBJZiBlbXB0eSwgbm8gbWVzc2FnZXMgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBtZXNzYWdlIHJldHVybmVkIGJ5IHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBGaWx0ZXJTdWJzY3JpcHRpb25PcHRzIHVzZWQgdG8gbmFycm93IHdoaWNoIG1lc3NhZ2VzIGFyZSByZXR1cm5lZCwgYW5kIHdoaWNoIHBlZXIgdG8gY29ubmVjdCB0by5cbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBlbmQgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZShcbiAgICBjYWxsYmFjazogRmlsdGVyQ2FsbGJhY2ssXG4gICAgY29udGVudFRvcGljczogc3RyaW5nW10sXG4gICAgb3B0cz86IEZpbHRlclN1YnNjcmlwdGlvbk9wdHNcbiAgKTogUHJvbWlzZTxVbnN1YnNjcmliZUZ1bmN0aW9uPiB7XG4gICAgY29uc3QgdG9waWMgPSBvcHRzPy5wdWJzdWJUb3BpYyB8fCBEZWZhdWx0UHViU3ViVG9waWM7XG4gICAgY29uc3QgY29udGVudEZpbHRlcnMgPSBjb250ZW50VG9waWNzLm1hcCgoY29udGVudFRvcGljKSA9PiAoe1xuICAgICAgY29udGVudFRvcGljLFxuICAgIH0pKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gRmlsdGVyUlBDLmNyZWF0ZVJlcXVlc3QoXG4gICAgICB0b3BpYyxcbiAgICAgIGNvbnRlbnRGaWx0ZXJzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBjb25zdCBwZWVyID0gYXdhaXQgdGhpcy5nZXRQZWVyKG9wdHM/LnBlZXJJZCk7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5uZXdTdHJlYW0ocGVlcik7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcGlwZShbcmVxdWVzdC5lbmNvZGUoKV0sIGxwLmVuY29kZSgpLCBzdHJlYW0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyhcbiAgICAgICAgXCJFcnJvciBzdWJzY3JpYmluZyB0byBwZWVyIFwiLFxuICAgICAgICBwZWVyLmlkLnRvQjU4U3RyaW5nKCksXG4gICAgICAgIFwiZm9yIGNvbnRlbnQgdG9waWNzXCIsXG4gICAgICAgIGNvbnRlbnRUb3BpY3MsXG4gICAgICAgIFwiOiBcIixcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDYWxsYmFjayhyZXF1ZXN0LnJlcXVlc3RJZCwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMudW5zdWJzY3JpYmUodG9waWMsIGNvbnRlbnRGaWx0ZXJzLCByZXF1ZXN0LnJlcXVlc3RJZCwgcGVlcik7XG4gICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrKHJlcXVlc3QucmVxdWVzdElkKTtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBvblJlcXVlc3QoeyBzdHJlYW0gfTogTGlicDJwLkhhbmRsZXJQcm9wcyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxvZyhcIlJlY2VpdmluZyBtZXNzYWdlIHB1c2hcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHBpcGUoXG4gICAgICAgIHN0cmVhbS5zb3VyY2UsXG4gICAgICAgIGxwLmRlY29kZSgpLFxuICAgICAgICBhc3luYyAoc291cmNlOiBBc3luY0l0ZXJhYmxlPEJ1ZmZlcj4pID0+IHtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gRmlsdGVyUlBDLmRlY29kZShieXRlcy5zbGljZSgpKTtcbiAgICAgICAgICAgIGlmIChyZXMucHVzaD8ubWVzc2FnZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1c2hNZXNzYWdlcyhyZXMucmVxdWVzdElkLCByZXMucHVzaC5tZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyhcIkVycm9yIGRlY29kaW5nIG1lc3NhZ2VcIiwgZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwdXNoTWVzc2FnZXMoXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgbWVzc2FnZXM6IFdha3VNZXNzYWdlUHJvdG9bXVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVxdWVzdElkKTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBsb2coYE5vIGNhbGxiYWNrIHJlZ2lzdGVyZWQgZm9yIHJlcXVlc3QgSUQgJHtyZXF1ZXN0SWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGlvbktleXMgPSBBcnJheS5mcm9tKHRoaXMuZGVjcnlwdGlvbktleXMpLm1hcChcbiAgICAgIChba2V5LCB7IG1ldGhvZCwgY29udGVudFRvcGljcyB9XSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY29udGVudFRvcGljcyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgV2FrdU1lc3NhZ2UuZGVjb2RlUHJvdG8obWVzc2FnZSwgZGVjcnlwdGlvbktleXMpO1xuICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgIGxvZyhcIk5vdCBhYmxlIHRvIGRlY29kZSBtZXNzYWdlXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGRlY29kZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWRkQ2FsbGJhY2socmVxdWVzdElkOiBzdHJpbmcsIGNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVxdWVzdElkLCBjYWxsYmFjayk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUNhbGxiYWNrKHJlcXVlc3RJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB1bnN1YnNjcmliZShcbiAgICB0b3BpYzogc3RyaW5nLFxuICAgIGNvbnRlbnRGaWx0ZXJzOiBDb250ZW50RmlsdGVyW10sXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgcGVlcjogUGVlclxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB1bnN1YnNjcmliZVJlcXVlc3QgPSBGaWx0ZXJSUEMuY3JlYXRlUmVxdWVzdChcbiAgICAgIHRvcGljLFxuICAgICAgY29udGVudEZpbHRlcnMsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLm5ld1N0cmVhbShwZWVyKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcGlwZShbdW5zdWJzY3JpYmVSZXF1ZXN0LmVuY29kZSgpXSwgbHAuZW5jb2RlKCksIHN0cmVhbS5zaW5rKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2coXCJFcnJvciB1bnN1YnNjcmliaW5nXCIsIGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG5ld1N0cmVhbShwZWVyOiBQZWVyKTogUHJvbWlzZTxNdXhlZFN0cmVhbT4ge1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5nZXQocGVlci5pZCk7XG4gICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGEgY29ubmVjdGlvbiB0byB0aGUgcGVlclwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0cmVhbSB9ID0gYXdhaXQgY29ubmVjdGlvbi5uZXdTdHJlYW0oRmlsdGVyQ29kZWMpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFBlZXIocGVlcklkPzogUGVlcklkKTogUHJvbWlzZTxQZWVyPiB7XG4gICAgbGV0IHBlZXI7XG4gICAgaWYgKHBlZXJJZCkge1xuICAgICAgcGVlciA9IGF3YWl0IHRoaXMubGlicDJwLnBlZXJTdG9yZS5nZXQocGVlcklkKTtcbiAgICAgIGlmICghcGVlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byByZXRyaWV2ZSBjb25uZWN0aW9uIGRldGFpbHMgZm9yIHByb3ZpZGVkIHBlZXIgaW4gcGVlciBzdG9yZTogJHtwZWVySWQudG9CNThTdHJpbmcoKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZXIgPSBhd2FpdCB0aGlzLnJhbmRvbVBlZXI7XG4gICAgICBpZiAoIXBlZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGZpbmQga25vd24gcGVlciB0aGF0IHJlZ2lzdGVycyB3YWt1IGZpbHRlciBwcm90b2NvbFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwZWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzIHJlY2VpdmVkIGluIGFueVxuICAgKiBzdWJzZXF1ZW50IFtbc3Vic2NyaWJlXV0gY2FsbC4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpYyBrZXkuIFtbV2FrdVN0b3JlXV0gd2lsbCBhdHRlbXB0IHRvXG4gICAqIGRlY3J5cHQgbWVzc2FnZXMgdXNpbmcgYm90aCBtZXRob2RzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoXG4gICAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuc2V0KGhleFRvQnl0ZXMoa2V5KSwgb3B0aW9ucyA/PyB7fSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZGVjcnlwdGlvbiBrZXkgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBpbiBmdXR1cmUgW1tzdWJzY3JpYmVdXSBjYWxsc1xuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGRlbGV0ZURlY3J5cHRpb25LZXkoa2V5OiBVaW50OEFycmF5IHwgc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kZWNyeXB0aW9uS2V5cy5kZWxldGUoaGV4VG9CeXRlcyhrZXkpKTtcbiAgfVxuXG4gIGdldCBwZWVycygpOiBBc3luY0l0ZXJhYmxlPFBlZXI+IHtcbiAgICByZXR1cm4gZ2V0UGVlcnNGb3JQcm90b2NvbCh0aGlzLmxpYnAycCwgW0ZpbHRlckNvZGVjXSk7XG4gIH1cblxuICBnZXQgcmFuZG9tUGVlcigpOiBQcm9taXNlPFBlZXIgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gc2VsZWN0UmFuZG9tUGVlcih0aGlzLnBlZXJzKTtcbiAgfVxufVxuIiwiaW1wb3J0IGNvbmNhdCBmcm9tIFwiaXQtY29uY2F0XCI7XG5pbXBvcnQgbHAgZnJvbSBcIml0LWxlbmd0aC1wcmVmaXhlZFwiO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gXCJpdC1waXBlXCI7XG5pbXBvcnQgTGlicDJwIGZyb20gXCJsaWJwMnBcIjtcbmltcG9ydCB7IFBlZXIgfSBmcm9tIFwibGlicDJwL3NyYy9wZWVyLXN0b3JlXCI7XG5pbXBvcnQgUGVlcklkIGZyb20gXCJwZWVyLWlkXCI7XG5cbmltcG9ydCB7IFB1c2hSZXNwb25zZSB9IGZyb20gXCIuLi8uLi9wcm90by93YWt1L3YyL2xpZ2h0X3B1c2hcIjtcbmltcG9ydCB7IGdldFBlZXJzRm9yUHJvdG9jb2wsIHNlbGVjdFJhbmRvbVBlZXIgfSBmcm9tIFwiLi4vc2VsZWN0X3BlZXJcIjtcbmltcG9ydCB7IERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gXCIuLi93YWt1XCI7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gXCIuLi93YWt1X21lc3NhZ2VcIjtcblxuaW1wb3J0IHsgUHVzaFJQQyB9IGZyb20gXCIuL3B1c2hfcnBjXCI7XG5cbmV4cG9ydCBjb25zdCBMaWdodFB1c2hDb2RlYyA9IFwiL3ZhYy93YWt1L2xpZ2h0cHVzaC8yLjAuMC1iZXRhMVwiO1xuZXhwb3J0IHsgUHVzaFJlc3BvbnNlIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgUHViU3ViIFRvcGljIHRvIHVzZS4gRGVmYXVsdHMgdG8ge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY30uXG4gICAqXG4gICAqIFRoZSB1c2FnZSBvZiB0aGUgZGVmYXVsdCBwdWJzdWIgdG9waWMgaXMgcmVjb21tZW5kZWQuXG4gICAqIFNlZSBbV2FrdSB2MiBUb3BpYyBVc2FnZSBSZWNvbW1lbmRhdGlvbnNdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yMy8pIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgRGVmYXVsdFB1YlN1YlRvcGljfVxuICAgKi9cbiAgcHViU3ViVG9waWM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaE9wdGlvbnMge1xuICBwZWVySWQ/OiBQZWVySWQ7XG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFtXYWt1IHYyIExpZ2h0IFB1c2ggcHJvdG9jb2xdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8xOS8pLlxuICovXG5leHBvcnQgY2xhc3MgV2FrdUxpZ2h0UHVzaCB7XG4gIHB1YlN1YlRvcGljOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGxpYnAycDogTGlicDJwLCBvcHRpb25zPzogQ3JlYXRlT3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5wdWJTdWJUb3BpYykge1xuICAgICAgdGhpcy5wdWJTdWJUb3BpYyA9IG9wdGlvbnMucHViU3ViVG9waWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHViU3ViVG9waWMgPSBEZWZhdWx0UHViU3ViVG9waWM7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHVzaChcbiAgICBtZXNzYWdlOiBXYWt1TWVzc2FnZSxcbiAgICBvcHRzPzogUHVzaE9wdGlvbnNcbiAgKTogUHJvbWlzZTxQdXNoUmVzcG9uc2UgfCBudWxsPiB7XG4gICAgbGV0IHBlZXI7XG4gICAgaWYgKG9wdHM/LnBlZXJJZCkge1xuICAgICAgcGVlciA9IGF3YWl0IHRoaXMubGlicDJwLnBlZXJTdG9yZS5nZXQob3B0cy5wZWVySWQpO1xuICAgICAgaWYgKCFwZWVyKSB0aHJvdyBcIlBlZXIgaXMgdW5rbm93blwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyID0gYXdhaXQgdGhpcy5yYW5kb21QZWVyO1xuICAgIH1cbiAgICBpZiAoIXBlZXIpIHRocm93IFwiTm8gcGVlciBhdmFpbGFibGVcIjtcbiAgICBpZiAoIXBlZXIucHJvdG9jb2xzLmluY2x1ZGVzKExpZ2h0UHVzaENvZGVjKSlcbiAgICAgIHRocm93IFwiUGVlciBkb2VzIG5vdCByZWdpc3RlciB3YWt1IGxpZ2h0IHB1c2ggcHJvdG9jb2xcIjtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5nZXQocGVlci5pZCk7XG4gICAgaWYgKCFjb25uZWN0aW9uKSB0aHJvdyBcIkZhaWxlZCB0byBnZXQgYSBjb25uZWN0aW9uIHRvIHRoZSBwZWVyXCI7XG5cbiAgICBjb25zdCB7IHN0cmVhbSB9ID0gYXdhaXQgY29ubmVjdGlvbi5uZXdTdHJlYW0oTGlnaHRQdXNoQ29kZWMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJTdWJUb3BpYyA9IG9wdHM/LnB1YlN1YlRvcGljXG4gICAgICAgID8gb3B0cy5wdWJTdWJUb3BpY1xuICAgICAgICA6IHRoaXMucHViU3ViVG9waWM7XG4gICAgICBjb25zdCBxdWVyeSA9IFB1c2hSUEMuY3JlYXRlUmVxdWVzdChtZXNzYWdlLCBwdWJTdWJUb3BpYyk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwaXBlKFxuICAgICAgICBbcXVlcnkuZW5jb2RlKCldLFxuICAgICAgICBscC5lbmNvZGUoKSxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBscC5kZWNvZGUoKSxcbiAgICAgICAgY29uY2F0XG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBQdXNoUlBDLmRlY29kZShyZXMuc2xpY2UoKSkucmVzcG9uc2U7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gcmVzcG9uc2UgaW4gUHVzaFJQQ1wiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBkZWNvZGUgcHVzaCByZXBseVwiLCBlcnIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gc2VuZCB3YWt1IGxpZ2h0IHB1c2ggcmVxdWVzdFwiLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGtub3duIHBlZXJzIGZyb20gdGhlIGFkZHJlc3MgYm9vayAoYGxpYnAycC5wZWVyU3RvcmVgKSB0aGF0IHN1cHBvcnRcbiAgICogbGlnaHQgcHVzaCBwcm90b2NvbC4gV2FrdSBtYXkgb3IgIG1heSBub3QgYmUgY3VycmVudGx5IGNvbm5lY3RlZCB0byB0aGVzZSBwZWVycy5cbiAgICovXG4gIGdldCBwZWVycygpOiBBc3luY0l0ZXJhYmxlPFBlZXI+IHtcbiAgICByZXR1cm4gZ2V0UGVlcnNGb3JQcm90b2NvbCh0aGlzLmxpYnAycCwgW0xpZ2h0UHVzaENvZGVjXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJhbmRvbSBwZWVyIHRoYXQgc3VwcG9ydHMgbGlnaHQgcHVzaCBwcm90b2NvbCBmcm9tIHRoZSBhZGRyZXNzXG4gICAqIGJvb2sgKGBsaWJwMnAucGVlclN0b3JlYCkuIFdha3UgbWF5IG9yICBtYXkgbm90IGJlIGN1cnJlbnRseSBjb25uZWN0ZWQgdG9cbiAgICogdGhpcyBwZWVyLlxuICAgKi9cbiAgZ2V0IHJhbmRvbVBlZXIoKTogUHJvbWlzZTxQZWVyIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHNlbGVjdFJhbmRvbVBlZXIodGhpcy5wZWVycyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFJlYWRlciB9IGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tIFwidXVpZFwiO1xuXG5pbXBvcnQgKiBhcyBwcm90byBmcm9tIFwiLi4vLi4vcHJvdG8vd2FrdS92Mi9saWdodF9wdXNoXCI7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gXCIuLi93YWt1X21lc3NhZ2VcIjtcblxuZXhwb3J0IGNsYXNzIFB1c2hSUEMge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHByb3RvOiBwcm90by5QdXNoUlBDKSB7fVxuXG4gIHN0YXRpYyBjcmVhdGVSZXF1ZXN0KG1lc3NhZ2U6IFdha3VNZXNzYWdlLCBwdWJTdWJUb3BpYzogc3RyaW5nKTogUHVzaFJQQyB7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHtcbiAgICAgIHJlcXVlc3RJZDogdXVpZCgpLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLnByb3RvLFxuICAgICAgICBwdWJTdWJUb3BpYzogcHViU3ViVG9waWMsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBQdXNoUlBDIHtcbiAgICBjb25zdCByZXMgPSBwcm90by5QdXNoUlBDLmRlY29kZShSZWFkZXIuY3JlYXRlKGJ5dGVzKSk7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHJlcyk7XG4gIH1cblxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHByb3RvLlB1c2hSUEMuZW5jb2RlKHRoaXMucHJvdG8pLmZpbmlzaCgpO1xuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IHByb3RvLlB1c2hSZXF1ZXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5yZXF1ZXN0O1xuICB9XG5cbiAgZ2V0IHJlc3BvbnNlKCk6IHByb3RvLlB1c2hSZXNwb25zZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucmVzcG9uc2U7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHNlY3AgZnJvbSBcIkBub2JsZS9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCJ1aW50OGFycmF5cy9jb25jYXRcIjtcblxuaW1wb3J0IHsgZ2V0U3VidGxlLCByYW5kb21CeXRlcywgc2hhMjU2IH0gZnJvbSBcIi4uL2NyeXB0b1wiO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyB9IGZyb20gXCIuLi91dGlsc1wiO1xuLyoqXG4gKiBIS0RGIGFzIGltcGxlbWVudGVkIGluIGdvLWV0aGVyZXVtLlxuICovXG5mdW5jdGlvbiBrZGYoc2VjcmV0OiBVaW50OEFycmF5LCBvdXRwdXRMZW5ndGg6IG51bWJlcik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBsZXQgY3RyID0gMTtcbiAgbGV0IHdyaXR0ZW4gPSAwO1xuICBsZXQgd2lsbEJlUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKG5ldyBVaW50OEFycmF5KCkpO1xuICB3aGlsZSAod3JpdHRlbiA8IG91dHB1dExlbmd0aCkge1xuICAgIGNvbnN0IGNvdW50ZXJzID0gbmV3IFVpbnQ4QXJyYXkoW2N0ciA+PiAyNCwgY3RyID4+IDE2LCBjdHIgPj4gOCwgY3RyXSk7XG4gICAgY29uc3QgY291bnRlcnNTZWNyZXQgPSBjb25jYXQoXG4gICAgICBbY291bnRlcnMsIHNlY3JldF0sXG4gICAgICBjb3VudGVycy5sZW5ndGggKyBzZWNyZXQubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCB3aWxsQmVIYXNoUmVzdWx0ID0gc2hhMjU2KGNvdW50ZXJzU2VjcmV0KTtcbiAgICB3aWxsQmVSZXN1bHQgPSB3aWxsQmVSZXN1bHQudGhlbigocmVzdWx0KSA9PlxuICAgICAgd2lsbEJlSGFzaFJlc3VsdC50aGVuKChoYXNoUmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IF9oYXNoUmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaFJlc3VsdCk7XG4gICAgICAgIHJldHVybiBjb25jYXQoXG4gICAgICAgICAgW3Jlc3VsdCwgX2hhc2hSZXN1bHRdLFxuICAgICAgICAgIHJlc3VsdC5sZW5ndGggKyBfaGFzaFJlc3VsdC5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB3cml0dGVuICs9IDMyO1xuICAgIGN0ciArPSAxO1xuICB9XG4gIHJldHVybiB3aWxsQmVSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFlc0N0ckVuY3J5cHQoXG4gIGNvdW50ZXI6IFVpbnQ4QXJyYXksXG4gIGtleTogQXJyYXlCdWZmZXJMaWtlLFxuICBkYXRhOiBBcnJheUJ1ZmZlckxpa2Vcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICByZXR1cm4gZ2V0U3VidGxlKClcbiAgICAuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgXCJBRVMtQ1RSXCIsIGZhbHNlLCBbXCJlbmNyeXB0XCJdKVxuICAgIC50aGVuKChjcnlwdG9LZXkpID0+XG4gICAgICBnZXRTdWJ0bGUoKS5lbmNyeXB0KFxuICAgICAgICB7IG5hbWU6IFwiQUVTLUNUUlwiLCBjb3VudGVyOiBjb3VudGVyLCBsZW5ndGg6IDEyOCB9LFxuICAgICAgICBjcnlwdG9LZXksXG4gICAgICAgIGRhdGFcbiAgICAgIClcbiAgICApXG4gICAgLnRoZW4oKGJ5dGVzKSA9PiBuZXcgVWludDhBcnJheShieXRlcykpO1xufVxuXG5mdW5jdGlvbiBhZXNDdHJEZWNyeXB0KFxuICBjb3VudGVyOiBVaW50OEFycmF5LFxuICBrZXk6IEFycmF5QnVmZmVyTGlrZSxcbiAgZGF0YTogQXJyYXlCdWZmZXJMaWtlXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgcmV0dXJuIGdldFN1YnRsZSgpXG4gICAgLmltcG9ydEtleShcInJhd1wiLCBrZXksIFwiQUVTLUNUUlwiLCBmYWxzZSwgW1wiZGVjcnlwdFwiXSlcbiAgICAudGhlbigoY3J5cHRvS2V5KSA9PlxuICAgICAgZ2V0U3VidGxlKCkuZGVjcnlwdChcbiAgICAgICAgeyBuYW1lOiBcIkFFUy1DVFJcIiwgY291bnRlcjogY291bnRlciwgbGVuZ3RoOiAxMjggfSxcbiAgICAgICAgY3J5cHRvS2V5LFxuICAgICAgICBkYXRhXG4gICAgICApXG4gICAgKVxuICAgIC50aGVuKChieXRlcykgPT4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbn1cblxuZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oXG4gIGtleTogQXJyYXlCdWZmZXJMaWtlLFxuICBtc2c6IEFycmF5QnVmZmVyTGlrZVxuKTogUHJvbWlzZUxpa2U8VWludDhBcnJheT4ge1xuICBjb25zdCBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7IG5hbWU6IFwiU0hBLTI1NlwiIH0gfTtcbiAgcmV0dXJuIGdldFN1YnRsZSgpXG4gICAgLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIl0pXG4gICAgLnRoZW4oKGNyeXB0b0tleSkgPT4gZ2V0U3VidGxlKCkuc2lnbihhbGdvcml0aG0sIGNyeXB0b0tleSwgbXNnKSlcbiAgICAudGhlbigoYnl0ZXMpID0+IG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG59XG5cbmZ1bmN0aW9uIGhtYWNTaGEyNTZWZXJpZnkoXG4gIGtleTogQXJyYXlCdWZmZXJMaWtlLFxuICBtc2c6IEFycmF5QnVmZmVyTGlrZSxcbiAgc2lnOiBBcnJheUJ1ZmZlckxpa2Vcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiB7IG5hbWU6IFwiU0hBLTI1NlwiIH0gfTtcbiAgY29uc3QgX2tleSA9IGdldFN1YnRsZSgpLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZ29yaXRobSwgZmFsc2UsIFtcInZlcmlmeVwiXSk7XG4gIHJldHVybiBfa2V5LnRoZW4oKGNyeXB0b0tleSkgPT5cbiAgICBnZXRTdWJ0bGUoKS52ZXJpZnkoYWxnb3JpdGhtLCBjcnlwdG9LZXksIHNpZywgbXNnKVxuICApO1xufVxuXG4vKipcbiAqIERlcml2ZSBzaGFyZWQgc2VjcmV0IGZvciBnaXZlbiBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAqXG4gKiBAcGFyYW0gIHByaXZhdGVLZXlBIFNlbmRlcidzIHByaXZhdGUga2V5ICgzMiBieXRlcylcbiAqIEBwYXJhbSAgcHVibGljS2V5QiBSZWNpcGllbnQncyBwdWJsaWMga2V5ICg2NSBieXRlcylcbiAqIEByZXR1cm5zICBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkZXJpdmVkIHNoYXJlZCBzZWNyZXQgKFB4LCAzMiBieXRlcylcbiAqIEB0aHJvd3MgRXJyb3IgSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZShwcml2YXRlS2V5QTogVWludDhBcnJheSwgcHVibGljS2V5QjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBpZiAocHJpdmF0ZUtleUEubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBCYWQgcHJpdmF0ZSBrZXksIGl0IHNob3VsZCBiZSAzMiBieXRlcyBidXQgaXQncyBhY3R1YWxseSAke3ByaXZhdGVLZXlBLmxlbmd0aH0gYnl0ZXMgbG9uZ2BcbiAgICApO1xuICB9IGVsc2UgaWYgKHB1YmxpY0tleUIubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBCYWQgcHVibGljIGtleSwgaXQgc2hvdWxkIGJlIDY1IGJ5dGVzIGJ1dCBpdCdzIGFjdHVhbGx5ICR7cHVibGljS2V5Qi5sZW5ndGh9IGJ5dGVzIGxvbmdgXG4gICAgKTtcbiAgfSBlbHNlIGlmIChwdWJsaWNLZXlCWzBdICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHB1YmxpYyBrZXksIGEgdmFsaWQgcHVibGljIGtleSB3b3VsZCBiZWdpbiB3aXRoIDRcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHggPSBzZWNwLmdldFNoYXJlZFNlY3JldChwcml2YXRlS2V5QSwgcHVibGljS2V5QiwgdHJ1ZSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBjb21wcmVzc2lvbiBwcmVmaXhcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGV4VG9CeXRlcyhweCkuc2xpY2UoMSkpO1xuICB9XG59XG5cbi8qKlxuICogRW5jcnlwdCBtZXNzYWdlIGZvciBnaXZlbiByZWNpcGllbnQncyBwdWJsaWMga2V5LlxuICpcbiAqIEBwYXJhbSAgcHVibGljS2V5VG8gUmVjaXBpZW50J3MgcHVibGljIGtleSAoNjUgYnl0ZXMpXG4gKiBAcGFyYW0gIG1zZyBUaGUgbWVzc2FnZSBiZWluZyBlbmNyeXB0ZWRcbiAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgRUNJRVMgc3RydWN0dXJlIHNlcmlhbGl6ZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQoXG4gIHB1YmxpY0tleVRvOiBVaW50OEFycmF5LFxuICBtc2c6IFVpbnQ4QXJyYXlcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBlcGhlbVByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG5cbiAgY29uc3Qgc2hhcmVkUHggPSBhd2FpdCBkZXJpdmUoZXBoZW1Qcml2YXRlS2V5LCBwdWJsaWNLZXlUbyk7XG5cbiAgY29uc3QgaGFzaCA9IGF3YWl0IGtkZihzaGFyZWRQeCwgMzIpO1xuXG4gIGNvbnN0IGl2ID0gcmFuZG9tQnl0ZXMoMTYpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAxNik7XG4gIGNvbnN0IGNpcGhlclRleHQgPSBhd2FpdCBhZXNDdHJFbmNyeXB0KGl2LCBlbmNyeXB0aW9uS2V5LCBtc2cpO1xuXG4gIGNvbnN0IGl2Q2lwaGVyVGV4dCA9IGNvbmNhdChbaXYsIGNpcGhlclRleHRdLCBpdi5sZW5ndGggKyBjaXBoZXJUZXh0Lmxlbmd0aCk7XG5cbiAgY29uc3QgbWFjS2V5ID0gYXdhaXQgc2hhMjU2KGhhc2guc2xpY2UoMTYpKTtcbiAgY29uc3QgaG1hYyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKG1hY0tleSwgaXZDaXBoZXJUZXh0KTtcbiAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBzZWNwLmdldFB1YmxpY0tleShlcGhlbVByaXZhdGVLZXksIGZhbHNlKTtcblxuICByZXR1cm4gY29uY2F0KFxuICAgIFtlcGhlbVB1YmxpY0tleSwgaXZDaXBoZXJUZXh0LCBobWFjXSxcbiAgICBlcGhlbVB1YmxpY0tleS5sZW5ndGggKyBpdkNpcGhlclRleHQubGVuZ3RoICsgaG1hYy5sZW5ndGhcbiAgKTtcbn1cblxuY29uc3QgbWV0YUxlbmd0aCA9IDEgKyA2NCArIDE2ICsgMzI7XG5cbi8qKlxuICogRGVjcnlwdCBtZXNzYWdlIHVzaW5nIGdpdmVuIHByaXZhdGUga2V5LlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgMzItYnl0ZSBwcml2YXRlIGtleSBvZiByZWNpcGllbnQgb2YgdGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSBlbmNyeXB0ZWQgRUNJRVMgc2VyaWFsaXplZCBzdHJ1Y3R1cmUgKHJlc3VsdCBvZiBFQ0lFUyBlbmNyeXB0aW9uKVxuICogQHJldHVybnMgVGhlIGNsZWFyIHRleHRcbiAqIEB0aHJvd3MgRXJyb3IgSWYgZGVjcnlwdGlvbiBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChcbiAgcHJpdmF0ZUtleTogVWludDhBcnJheSxcbiAgZW5jcnlwdGVkOiBVaW50OEFycmF5XG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgaWYgKGVuY3J5cHRlZC5sZW5ndGggPD0gbWV0YUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIENpcGhlcnRleHQuIERhdGEgaXMgdG9vIHNtYWxsLiBJdCBzaG91bGQgYmEgYXQgbGVhc3QgJHttZXRhTGVuZ3RofSBieXRlc2BcbiAgICApO1xuICB9IGVsc2UgaWYgKGVuY3J5cHRlZFswXSAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBOb3QgYSB2YWxpZCBjaXBoZXJ0ZXh0LiBJdCBzaG91bGQgYmVnaW4gd2l0aCA0IGJ1dCBhY3R1YWxseSBiZWdpbiB3aXRoICR7ZW5jcnlwdGVkWzBdfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlc2VyaWFsaXplXG4gICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBlbmNyeXB0ZWQuc2xpY2UoMCwgNjUpO1xuICAgIGNvbnN0IGNpcGhlclRleHRMZW5ndGggPSBlbmNyeXB0ZWQubGVuZ3RoIC0gbWV0YUxlbmd0aDtcbiAgICBjb25zdCBpdiA9IGVuY3J5cHRlZC5zbGljZSg2NSwgNjUgKyAxNik7XG4gICAgY29uc3QgY2lwaGVyQW5kSXYgPSBlbmNyeXB0ZWQuc2xpY2UoNjUsIDY1ICsgMTYgKyBjaXBoZXJUZXh0TGVuZ3RoKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gY2lwaGVyQW5kSXYuc2xpY2UoMTYpO1xuICAgIGNvbnN0IG1zZ01hYyA9IGVuY3J5cHRlZC5zbGljZSg2NSArIDE2ICsgY2lwaGVyVGV4dExlbmd0aCk7XG5cbiAgICAvLyBjaGVjayBITUFDXG4gICAgY29uc3QgcHggPSBkZXJpdmUocHJpdmF0ZUtleSwgZXBoZW1QdWJsaWNLZXkpO1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBrZGYocHgsIDMyKTtcbiAgICBjb25zdCBbZW5jcnlwdGlvbktleSwgbWFjS2V5XSA9IGF3YWl0IHNoYTI1NihoYXNoLnNsaWNlKDE2KSkudGhlbihcbiAgICAgIChtYWNLZXkpID0+IFtoYXNoLnNsaWNlKDAsIDE2KSwgbWFjS2V5XVxuICAgICk7XG5cbiAgICBpZiAoIShhd2FpdCBobWFjU2hhMjU2VmVyaWZ5KG1hY0tleSwgY2lwaGVyQW5kSXYsIG1zZ01hYykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgTUFDXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhZXNDdHJEZWNyeXB0KGl2LCBlbmNyeXB0aW9uS2V5LCBjaXBoZXJ0ZXh0KTtcbiAgfVxufVxuIiwiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCB7IFJlYWRlciB9IGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcblxuaW1wb3J0ICogYXMgcHJvdG8gZnJvbSBcIi4uLy4uL3Byb3RvL3dha3UvdjIvbWVzc2FnZVwiO1xuaW1wb3J0IHsgYnl0ZXNUb1V0ZjgsIHV0ZjhUb0J5dGVzIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCAqIGFzIHZlcnNpb25fMSBmcm9tIFwiLi92ZXJzaW9uXzFcIjtcblxuY29uc3QgRGVmYXVsdFZlcnNpb24gPSAwO1xuY29uc3QgZGJnID0gZGVidWcoXCJ3YWt1Om1lc3NhZ2VcIik7XG5cbmV4cG9ydCBlbnVtIERlY3J5cHRpb25NZXRob2Qge1xuICBBc3ltbWV0cmljID0gXCJhc3ltbWV0cmljXCIsXG4gIFN5bW1ldHJpYyA9IFwic3ltbWV0cmljXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgdG8gc2V0IG9uIHRoZSBtZXNzYWdlLCBkZWZhdWx0cyB0byBub3cgaWYgbm90IHBhc3NlZC5cbiAgICovXG4gIHRpbWVzdGFtcD86IERhdGU7XG4gIC8qKlxuICAgKiBQdWJsaWMgS2V5IHRvIHVzZSB0byBlbmNyeXB0IHRoZSBtZXNzYWdlcyB1c2luZyBFQ0lFUyAoQXN5bW1ldHJpYyBFbmNyeXB0aW9uKS5cbiAgICpcbiAgICogQHRocm93cyBpZiBib3RoIGBlbmNQdWJsaWNLZXlgIGFuZCBgc3ltS2V5YCBhcmUgcGFzc2VkXG4gICAqL1xuICBlbmNQdWJsaWNLZXk/OiBVaW50OEFycmF5IHwgc3RyaW5nO1xuICAvKipcbiAgICogS2V5IHRvIHVzZSB0byBlbmNyeXB0IHRoZSBtZXNzYWdlcyB1c2luZyBBRVMgKFN5bW1ldHJpYyBFbmNyeXB0aW9uKS5cbiAgICpcbiAgICogQHRocm93cyBpZiBib3RoIGBlbmNQdWJsaWNLZXlgIGFuZCBgc3ltS2V5YCBhcmUgcGFzc2VkXG4gICAqL1xuICBzeW1LZXk/OiBVaW50OEFycmF5IHwgc3RyaW5nO1xuICAvKipcbiAgICogUHJpdmF0ZSBrZXkgdG8gdXNlIHRvIHNpZ24gdGhlIG1lc3NhZ2UsIGVpdGhlciBgZW5jUHVibGljS2V5YCBvciBgc3ltS2V5YCBtdXN0IGJlIHByb3ZpZGVkIGFzIG9ubHlcbiAgICogZW5jcnlwdGVkIG1lc3NhZ2VzIGFyZSBzaWduZWQuXG4gICAqL1xuICBzaWdQcml2S2V5PzogVWludDhBcnJheTtcbn1cblxuZXhwb3J0IGNsYXNzIFdha3VNZXNzYWdlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcHJvdG86IHByb3RvLldha3VNZXNzYWdlLFxuICAgIHByaXZhdGUgX3NpZ25hdHVyZVB1YmxpY0tleT86IFVpbnQ4QXJyYXksXG4gICAgcHJpdmF0ZSBfc2lnbmF0dXJlPzogVWludDhBcnJheVxuICApIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBNZXNzYWdlIHdpdGggYW4gdXRmLTggc3RyaW5nIGFzIHBheWxvYWQuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbVV0ZjhTdHJpbmcoXG4gICAgdXRmODogc3RyaW5nLFxuICAgIGNvbnRlbnRUb3BpYzogc3RyaW5nLFxuICAgIG9wdHM/OiBPcHRpb25zXG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2U+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gdXRmOFRvQnl0ZXModXRmOCk7XG4gICAgcmV0dXJuIFdha3VNZXNzYWdlLmZyb21CeXRlcyhwYXlsb2FkLCBjb250ZW50VG9waWMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFdha3UgTWVzc2FnZSB3aXRoIHRoZSBnaXZlbiBwYXlsb2FkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgcGF5bG9hZCBpcyBrZXB0IGNsZWFyICh2ZXJzaW9uIDApLlxuICAgKiBJZiBgb3B0cy5lbmNQdWJsaWNLZXlgIGlzIHBhc3NlZCwgdGhlIHBheWxvYWQgaXMgZW5jcnlwdGVkIHVzaW5nXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiAodmVyc2lvbiAxKS5cbiAgICpcbiAgICogSWYgYG9wdHMuc2lnUHJpdktleWAgaXMgcGFzc2VkIGFuZCB2ZXJzaW9uIDEgaXMgdXNlZCwgdGhlIHBheWxvYWQgaXMgc2lnbmVkXG4gICAqIGJlZm9yZSBlbmNyeXB0aW9uLlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIGJvdGggYG9wdHMuZW5jUHVibGljS2V5YCBhbmQgYG9wdC5zeW1LZXlgIGFyZSBwYXNzZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tQnl0ZXMoXG4gICAgcGF5bG9hZDogVWludDhBcnJheSxcbiAgICBjb250ZW50VG9waWM6IHN0cmluZyxcbiAgICBvcHRzPzogT3B0aW9uc1xuICApOiBQcm9taXNlPFdha3VNZXNzYWdlPiB7XG4gICAgY29uc3QgeyB0aW1lc3RhbXAsIGVuY1B1YmxpY0tleSwgc3ltS2V5LCBzaWdQcml2S2V5IH0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgeyB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfSxcbiAgICAgIG9wdHMgPyBvcHRzIDoge31cbiAgICApO1xuXG4gICAgbGV0IF9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICBsZXQgdmVyc2lvbiA9IERlZmF1bHRWZXJzaW9uO1xuICAgIGxldCBzaWc7XG5cbiAgICBpZiAoZW5jUHVibGljS2V5ICYmIHN5bUtleSkge1xuICAgICAgdGhyb3cgXCJQYXNzIGVpdGhlciBgZW5jUHVibGljS2V5YCBvciBgc3ltS2V5YCwgbm90IGJvdGguXCI7XG4gICAgfVxuXG4gICAgaWYgKGVuY1B1YmxpY0tleSkge1xuICAgICAgY29uc3QgZW5jID0gYXdhaXQgdmVyc2lvbl8xLmNsZWFyRW5jb2RlKF9wYXlsb2FkLCBzaWdQcml2S2V5KTtcbiAgICAgIF9wYXlsb2FkID0gYXdhaXQgdmVyc2lvbl8xLmVuY3J5cHRBc3ltbWV0cmljKGVuYy5wYXlsb2FkLCBlbmNQdWJsaWNLZXkpO1xuICAgICAgc2lnID0gZW5jLnNpZztcbiAgICAgIHZlcnNpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoc3ltS2V5KSB7XG4gICAgICBjb25zdCBlbmMgPSBhd2FpdCB2ZXJzaW9uXzEuY2xlYXJFbmNvZGUoX3BheWxvYWQsIHNpZ1ByaXZLZXkpO1xuICAgICAgX3BheWxvYWQgPSBhd2FpdCB2ZXJzaW9uXzEuZW5jcnlwdFN5bW1ldHJpYyhlbmMucGF5bG9hZCwgc3ltS2V5KTtcbiAgICAgIHNpZyA9IGVuYy5zaWc7XG4gICAgICB2ZXJzaW9uID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdha3VNZXNzYWdlKFxuICAgICAge1xuICAgICAgICBwYXlsb2FkOiBfcGF5bG9hZCxcbiAgICAgICAgdGltZXN0YW1wRGVwcmVjYXRlZDogdGltZXN0YW1wLnZhbHVlT2YoKSAvIDEwMDAsXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kcyAxMF4tMyB0byBuYW5vc2Vjb25kcyAxMF4tOVxuICAgICAgICB0aW1lc3RhbXA6IExvbmcuZnJvbU51bWJlcih0aW1lc3RhbXAudmFsdWVPZigpKS5tdWwoMV8wMDBfMDAwKSxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgY29udGVudFRvcGljLFxuICAgICAgfSxcbiAgICAgIHNpZz8ucHVibGljS2V5LFxuICAgICAgc2lnPy5zaWduYXR1cmVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGJ5dGUgYXJyYXkgaW50byBXYWt1IE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbXMgYnl0ZXMgVGhlIG1lc3NhZ2UgZW5jb2RlZCB1c2luZyBwcm90b2J1ZiBhcyBkZWZpbmVkIGluIFsxNC9XQUtVMi1NRVNTQUdFXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTQvKS5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcnVuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGUoXG4gICAgYnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgZGVjcnlwdGlvbktleXM/OiBBcnJheTx7XG4gICAgICBrZXk6IFVpbnQ4QXJyYXk7XG4gICAgICBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kO1xuICAgICAgY29udGVudFRvcGljPzogc3RyaW5nW107XG4gICAgfT5cbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHByb3RvQnVmID0gcHJvdG8uV2FrdU1lc3NhZ2UuZGVjb2RlKFJlYWRlci5jcmVhdGUoYnl0ZXMpKTtcblxuICAgIHJldHVybiBXYWt1TWVzc2FnZS5kZWNvZGVQcm90byhwcm90b0J1ZiwgZGVjcnlwdGlvbktleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbmQgZGVjcnlwdCBXYWt1IE1lc3NhZ2UgUHJvdG9idWYgT2JqZWN0IGludG8gV2FrdSBNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW1zIHByb3RvQnVmIFRoZSBtZXNzYWdlIHRvIGRlY29kZSBhbmQgZGVjcnlwdC5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcnVuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGVQcm90byhcbiAgICBwcm90b0J1ZjogcHJvdG8uV2FrdU1lc3NhZ2UsXG4gICAgZGVjcnlwdGlvbktleXM/OiBBcnJheTx7XG4gICAgICBrZXk6IFVpbnQ4QXJyYXk7XG4gICAgICBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kO1xuICAgICAgY29udGVudFRvcGljcz86IHN0cmluZ1tdO1xuICAgIH0+XG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2UgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAocHJvdG9CdWYucGF5bG9hZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYmcoXCJQYXlsb2FkIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHByb3RvQnVmLnBheWxvYWQ7XG5cbiAgICBsZXQgc2lnbmF0dXJlUHVibGljS2V5O1xuICAgIGxldCBzaWduYXR1cmU7XG4gICAgaWYgKHByb3RvQnVmLnZlcnNpb24gPT09IDEgJiYgcHJvdG9CdWYucGF5bG9hZCkge1xuICAgICAgaWYgKGRlY3J5cHRpb25LZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGJnKFwiUGF5bG9hZCBpcyBlbmNyeXB0ZWQgYnV0IG5vIHByaXZhdGUga2V5cyBoYXZlIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybnMgYSBidW5jaCBvZiBgdW5kZWZpbmVkYCBhbmQgaG9wZWZ1bGx5IG9uZSBkZWNyeXB0ZWQgcmVzdWx0XG4gICAgICBjb25zdCBhbGxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGRlY3J5cHRpb25LZXlzLm1hcChhc3luYyAoeyBrZXksIG1ldGhvZCwgY29udGVudFRvcGljcyB9KSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWNvbnRlbnRUb3BpY3MgfHxcbiAgICAgICAgICAgIChwcm90b0J1Zi5jb250ZW50VG9waWMgJiZcbiAgICAgICAgICAgICAgY29udGVudFRvcGljcy5pbmNsdWRlcyhwcm90b0J1Zi5jb250ZW50VG9waWMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSBEZWNyeXB0aW9uTWV0aG9kLkFzeW1tZXRyaWM6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB2ZXJzaW9uXzEuZGVjcnlwdEFzeW1tZXRyaWMocGF5bG9hZCwga2V5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBkYmcoXG4gICAgICAgICAgICAgICAgICAgIFwiRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBhc3ltbWV0cmljIGVuY3J5cHRpb24gZGVzcGl0ZSBkZWNyeXB0aW9uIG1ldGhvZCBiZWluZyBzcGVjaWZpZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgRGVjcnlwdGlvbk1ldGhvZC5TeW1tZXRyaWM6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB2ZXJzaW9uXzEuZGVjcnlwdFN5bW1ldHJpYyhwYXlsb2FkLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGRiZyhcbiAgICAgICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gZGVjcnlwdCBtZXNzYWdlIHVzaW5nIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBkZXNwaXRlIGRlY3J5cHRpb24gbWV0aG9kIGJlaW5nIHNwZWNpZmllZFwiLFxuICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0U3ltbWV0cmljKHBheWxvYWQsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZGJnKFxuICAgICAgICAgICAgICAgICAgICBcIkZhaWxlZCB0byBkZWNyeXB0IG1lc3NhZ2UgdXNpbmcgc3ltbWV0cmljIGVuY3J5cHRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB2ZXJzaW9uXzEuZGVjcnlwdEFzeW1tZXRyaWMocGF5bG9hZCwga2V5KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGJnKFxuICAgICAgICAgICAgICAgICAgICAgIFwiRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBhc3ltbWV0cmljIGVuY3J5cHRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGtleSBhdmFpbGFibGUgZm9yIHRoaXMgY29udGVudCB0b3BpY1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlzRGVmaW5lZCA9IChkZWM6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBkZWMgaXMgVWludDhBcnJheSA9PiB7XG4gICAgICAgIHJldHVybiAhIWRlYztcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGRlY29kZWRSZXN1bHRzID0gYWxsUmVzdWx0cy5maWx0ZXIoaXNEZWZpbmVkKTtcblxuICAgICAgaWYgKGRlY29kZWRSZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkYmcoXCJGYWlsZWQgdG8gZGVjcnlwdCBwYXlsb2FkLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjID0gZGVjb2RlZFJlc3VsdHNbMF07XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcnNpb25fMS5jbGVhckRlY29kZShkZWMpO1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgZGJnKFwiRmFpbGVkIHRvIGRlY29kZSBwYXlsb2FkLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihwcm90b0J1ZiwgeyBwYXlsb2FkOiByZXMucGF5bG9hZCB9KTtcbiAgICAgIHNpZ25hdHVyZVB1YmxpY0tleSA9IHJlcy5zaWc/LnB1YmxpY0tleTtcbiAgICAgIHNpZ25hdHVyZSA9IHJlcy5zaWc/LnNpZ25hdHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdha3VNZXNzYWdlKHByb3RvQnVmLCBzaWduYXR1cmVQdWJsaWNLZXksIHNpZ25hdHVyZSk7XG4gIH1cblxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHByb3RvLldha3VNZXNzYWdlLmVuY29kZSh0aGlzLnByb3RvKS5maW5pc2goKTtcbiAgfVxuXG4gIGdldCBwYXlsb2FkQXNVdGY4KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnBheWxvYWQpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYnl0ZXNUb1V0ZjgodGhpcy5wYXlsb2FkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYmcoXCJDb3VsZCBub3QgZGVjb2RlIGJ5dGUgYXMgVVRGLThcIiwgZSk7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cblxuICBnZXQgcGF5bG9hZCgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5wcm90by5wYXlsb2FkKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcm90by5wYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRUb3BpYygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnByb3RvLmNvbnRlbnRUb3BpYztcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8udmVyc2lvbjtcbiAgfVxuXG4gIGdldCB0aW1lc3RhbXAoKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgLy8gSW4gdGhlIGNhc2Ugd2UgcmVjZWl2ZSBhIHZhbHVlIHRoYXQgaXMgYmlnZ2VyIHRoYW4gSlMncyBtYXggbnVtYmVyLFxuICAgIC8vIHdlIGNhdGNoIHRoZSBlcnJvciBhbmQgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHJvdG8udGltZXN0YW1wKSB7XG4gICAgICAgIC8vIG5hbm9zZWNvbmRzIDEwXi05IHRvIG1pbGxpc2Vjb25kcyAxMF4tM1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSB0aGlzLnByb3RvLnRpbWVzdGFtcC5kaXYoMV8wMDBfMDAwKS50b051bWJlcigpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvdG8udGltZXN0YW1wRGVwcmVjYXRlZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5wcm90by50aW1lc3RhbXBEZXByZWNhdGVkICogMTAwMCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgdXNlZCB0byBzaWduIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBNQVkgYmUgcHJlc2VudCBpZiB0aGUgbWVzc2FnZSBpcyB2ZXJzaW9uIDEuXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlUHVibGljS2V5KCk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVQdWJsaWNLZXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogTUFZIGJlIHByZXNlbnQgaWYgdGhlIG1lc3NhZ2UgaXMgdmVyc2lvbiAxLlxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRTdWJ0bGUsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcIi4uL2NyeXB0b1wiO1xuXG5leHBvcnQgY29uc3QgS2V5U2l6ZSA9IDMyO1xuZXhwb3J0IGNvbnN0IEl2U2l6ZSA9IDEyO1xuZXhwb3J0IGNvbnN0IFRhZ1NpemUgPSAxNjtcblxuY29uc3QgQWxnb3JpdGhtID0geyBuYW1lOiBcIkFFUy1HQ01cIiwgbGVuZ3RoOiAxMjggfTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQoXG4gIGl2OiBVaW50OEFycmF5LFxuICBrZXk6IFVpbnQ4QXJyYXksXG4gIGNsZWFyVGV4dDogVWludDhBcnJheVxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBnZXRTdWJ0bGUoKVxuICAgIC5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBBbGdvcml0aG0sIGZhbHNlLCBbXCJlbmNyeXB0XCJdKVxuICAgIC50aGVuKChjcnlwdG9LZXkpID0+XG4gICAgICBnZXRTdWJ0bGUoKS5lbmNyeXB0KHsgaXYsIC4uLkFsZ29yaXRobSB9LCBjcnlwdG9LZXksIGNsZWFyVGV4dClcbiAgICApXG4gICAgLnRoZW4oKGNpcGhlcikgPT4gbmV3IFVpbnQ4QXJyYXkoY2lwaGVyKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KFxuICBpdjogVWludDhBcnJheSxcbiAga2V5OiBVaW50OEFycmF5LFxuICBjaXBoZXJUZXh0OiBVaW50OEFycmF5XG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgcmV0dXJuIGdldFN1YnRsZSgpXG4gICAgLmltcG9ydEtleShcInJhd1wiLCBrZXksIEFsZ29yaXRobSwgZmFsc2UsIFtcImRlY3J5cHRcIl0pXG4gICAgLnRoZW4oKGNyeXB0b0tleSkgPT5cbiAgICAgIGdldFN1YnRsZSgpLmRlY3J5cHQoeyBpdiwgLi4uQWxnb3JpdGhtIH0sIGNyeXB0b0tleSwgY2lwaGVyVGV4dClcbiAgICApXG4gICAgLnRoZW4oKGNsZWFyKSA9PiBuZXcgVWludDhBcnJheShjbGVhcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJdigpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHJhbmRvbUJ5dGVzKEl2U2l6ZSk7XG59XG4iLCJpbXBvcnQgKiBhcyBzZWNwIGZyb20gXCJAbm9ibGUvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tIFwidWludDhhcnJheXMvY29uY2F0XCI7XG5cbmltcG9ydCB7IGtlY2NhazI1NiwgcmFuZG9tQnl0ZXMsIHNpZ24gfSBmcm9tIFwiLi4vY3J5cHRvXCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCAqIGFzIGVjaWVzIGZyb20gXCIuL2VjaWVzXCI7XG5pbXBvcnQgKiBhcyBzeW1tZXRyaWMgZnJvbSBcIi4vc3ltbWV0cmljXCI7XG5cbmNvbnN0IEZsYWdzTGVuZ3RoID0gMTtcbmNvbnN0IEZsYWdNYXNrID0gMzsgLy8gMDAxMVxuY29uc3QgSXNTaWduZWRNYXNrID0gNDsgLy8gMDEwMFxuY29uc3QgUGFkZGluZ1RhcmdldCA9IDI1NjtcbmNvbnN0IFNpZ25hdHVyZUxlbmd0aCA9IDY1O1xuXG5leHBvcnQgY29uc3QgUHJpdmF0ZUtleVNpemUgPSAzMjtcblxuZXhwb3J0IHR5cGUgU2lnbmF0dXJlID0ge1xuICBzaWduYXR1cmU6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpY0tleTogVWludDhBcnJheSB8IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5jb2RlIHRoZSBwYXlsb2FkIHByZS1lbmNyeXB0aW9uLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG1lc3NhZ2VQYXlsb2FkOiBUaGUgcGF5bG9hZCB0byBpbmNsdWRlIGluIHRoZSBtZXNzYWdlXG4gKiBAcGFyYW0gc2lnUHJpdktleTogSWYgc2V0LCBhIHNpZ25hdHVyZSB1c2luZyB0aGlzIHByaXZhdGUga2V5IGlzIGFkZGVkLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgcGF5bG9hZCwgcmVhZHkgZm9yIGVuY3J5cHRpb24gdXNpbmcge0BsaW5rIGVuY3J5cHRBc3ltbWV0cmljfVxuICogb3Ige0BsaW5rIGVuY3J5cHRTeW1tZXRyaWN9LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJFbmNvZGUoXG4gIG1lc3NhZ2VQYXlsb2FkOiBVaW50OEFycmF5LFxuICBzaWdQcml2S2V5PzogVWludDhBcnJheVxuKTogUHJvbWlzZTx7IHBheWxvYWQ6IFVpbnQ4QXJyYXk7IHNpZz86IFNpZ25hdHVyZSB9PiB7XG4gIGxldCBlbnZlbG9wZSA9IG5ldyBVaW50OEFycmF5KFswXSk7IC8vIE5vIGZsYWdzXG4gIGVudmVsb3BlID0gYWRkUGF5bG9hZFNpemVGaWVsZChlbnZlbG9wZSwgbWVzc2FnZVBheWxvYWQpO1xuICBlbnZlbG9wZSA9IGNvbmNhdChbZW52ZWxvcGUsIG1lc3NhZ2VQYXlsb2FkXSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHBhZGRpbmc6XG4gIGxldCByYXdTaXplID1cbiAgICBGbGFnc0xlbmd0aCArXG4gICAgY29tcHV0ZVNpemVPZlBheWxvYWRTaXplRmllbGQobWVzc2FnZVBheWxvYWQpICtcbiAgICBtZXNzYWdlUGF5bG9hZC5sZW5ndGg7XG5cbiAgaWYgKHNpZ1ByaXZLZXkpIHtcbiAgICByYXdTaXplICs9IFNpZ25hdHVyZUxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmRlciA9IHJhd1NpemUgJSBQYWRkaW5nVGFyZ2V0O1xuICBjb25zdCBwYWRkaW5nU2l6ZSA9IFBhZGRpbmdUYXJnZXQgLSByZW1haW5kZXI7XG4gIGNvbnN0IHBhZCA9IHJhbmRvbUJ5dGVzKHBhZGRpbmdTaXplKTtcblxuICBpZiAoIXZhbGlkYXRlRGF0YUludGVncml0eShwYWQsIHBhZGRpbmdTaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBnZW5lcmF0ZSByYW5kb20gcGFkZGluZyBvZiBzaXplIFwiICsgcGFkZGluZ1NpemUpO1xuICB9XG5cbiAgZW52ZWxvcGUgPSBjb25jYXQoW2VudmVsb3BlLCBwYWRdKTtcblxuICBsZXQgc2lnO1xuICBpZiAoc2lnUHJpdktleSkge1xuICAgIGVudmVsb3BlWzBdIHw9IElzU2lnbmVkTWFzaztcbiAgICBjb25zdCBoYXNoID0ga2VjY2FrMjU2KGVudmVsb3BlKTtcbiAgICBjb25zdCBieXRlc1NpZ25hdHVyZSA9IGF3YWl0IHNpZ24oaGFzaCwgc2lnUHJpdktleSk7XG4gICAgZW52ZWxvcGUgPSBjb25jYXQoW2VudmVsb3BlLCBieXRlc1NpZ25hdHVyZV0pO1xuICAgIHNpZyA9IHtcbiAgICAgIHNpZ25hdHVyZTogYnl0ZXNTaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXk6IHNlY3AuZ2V0UHVibGljS2V5KHNpZ1ByaXZLZXksIGZhbHNlKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgcGF5bG9hZDogZW52ZWxvcGUsIHNpZyB9O1xufVxuXG4vKipcbiAqIERlY29kZSBhIGRlY3J5cHRlZCBwYXlsb2FkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJEZWNvZGUoXG4gIG1lc3NhZ2U6IFVpbnQ4QXJyYXlcbik6IHsgcGF5bG9hZDogVWludDhBcnJheTsgc2lnPzogU2lnbmF0dXJlIH0gfCB1bmRlZmluZWQge1xuICBjb25zdCBzaXplT2ZQYXlsb2FkU2l6ZUZpZWxkID0gZ2V0U2l6ZU9mUGF5bG9hZFNpemVGaWVsZChtZXNzYWdlKTtcbiAgaWYgKHNpemVPZlBheWxvYWRTaXplRmllbGQgPT09IDApIHJldHVybjtcblxuICBjb25zdCBwYXlsb2FkU2l6ZSA9IGdldFBheWxvYWRTaXplKG1lc3NhZ2UsIHNpemVPZlBheWxvYWRTaXplRmllbGQpO1xuICBjb25zdCBwYXlsb2FkU3RhcnQgPSAxICsgc2l6ZU9mUGF5bG9hZFNpemVGaWVsZDtcbiAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2Uuc2xpY2UocGF5bG9hZFN0YXJ0LCBwYXlsb2FkU3RhcnQgKyBwYXlsb2FkU2l6ZSk7XG5cbiAgY29uc3QgaXNTaWduZWQgPSBpc01lc3NhZ2VTaWduZWQobWVzc2FnZSk7XG5cbiAgbGV0IHNpZztcbiAgaWYgKGlzU2lnbmVkKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gZ2V0U2lnbmF0dXJlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRIYXNoKG1lc3NhZ2UsIGlzU2lnbmVkKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBlY1JlY292ZXJQdWJLZXkoaGFzaCwgc2lnbmF0dXJlKTtcbiAgICBzaWcgPSB7IHNpZ25hdHVyZSwgcHVibGljS2V5IH07XG4gIH1cblxuICByZXR1cm4geyBwYXlsb2FkLCBzaWcgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZU9mUGF5bG9hZFNpemVGaWVsZChtZXNzYWdlOiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgY29uc3QgbWVzc2FnZURhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG1lc3NhZ2UuYnVmZmVyKTtcbiAgcmV0dXJuIG1lc3NhZ2VEYXRhVmlldy5nZXRVaW50OCgwKSAmIEZsYWdNYXNrO1xufVxuXG5mdW5jdGlvbiBnZXRQYXlsb2FkU2l6ZShcbiAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgc2l6ZU9mUGF5bG9hZFNpemVGaWVsZDogbnVtYmVyXG4pOiBudW1iZXIge1xuICBsZXQgcGF5bG9hZFNpemVCeXRlcyA9IG1lc3NhZ2Uuc2xpY2UoMSwgMSArIHNpemVPZlBheWxvYWRTaXplRmllbGQpO1xuICAvLyBpbnQgMzIgPT0gNCBieXRlc1xuICBpZiAoc2l6ZU9mUGF5bG9hZFNpemVGaWVsZCA8IDQpIHtcbiAgICAvLyBJZiBsZXNzIHRoYW4gNCBieXRlcyBwYWQgcmlnaHQgKExpdHRsZSBFbmRpYW4pLlxuICAgIHBheWxvYWRTaXplQnl0ZXMgPSBjb25jYXQoXG4gICAgICBbcGF5bG9hZFNpemVCeXRlcywgbmV3IFVpbnQ4QXJyYXkoNCAtIHNpemVPZlBheWxvYWRTaXplRmllbGQpXSxcbiAgICAgIDRcbiAgICApO1xuICB9XG4gIGNvbnN0IHBheWxvYWRTaXplRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcocGF5bG9hZFNpemVCeXRlcy5idWZmZXIpO1xuICByZXR1cm4gcGF5bG9hZFNpemVEYXRhVmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaXNNZXNzYWdlU2lnbmVkKG1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgY29uc3QgbWVzc2FnZURhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG1lc3NhZ2UuYnVmZmVyKTtcbiAgcmV0dXJuIChtZXNzYWdlRGF0YVZpZXcuZ2V0VWludDgoMCkgJiBJc1NpZ25lZE1hc2spID09IElzU2lnbmVkTWFzaztcbn1cblxuLyoqXG4gKiBQcm9jZWVkIHdpdGggQXN5bW1ldHJpYyBlbmNyeXB0aW9uIG9mIHRoZSBkYXRhIGFzIHBlciBbMjYvV0FLVS1QQVlMT0FEXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjYvKS5cbiAqIFRoZSBkYXRhIE1VU1QgYmUgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXS5cbiAqIFRoZSByZXR1cm5lZCByZXN1bHQgIGNhbiBiZSBzZXQgdG8gYFdha3VNZXNzYWdlLnBheWxvYWRgLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFzeW1tZXRyaWMoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIHB1YmxpY0tleTogVWludDhBcnJheSB8IHN0cmluZ1xuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBlY2llcy5lbmNyeXB0KGhleFRvQnl0ZXMocHVibGljS2V5KSwgZGF0YSk7XG59XG5cbi8qKlxuICogUHJvY2VlZCB3aXRoIEFzeW1tZXRyaWMgZGVjcnlwdGlvbiBvZiB0aGUgZGF0YSBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKiBUaGUgcmV0dXJuZWQgZGF0YSBpcyBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0QXN5bW1ldHJpYyhcbiAgcGF5bG9hZDogVWludDhBcnJheSxcbiAgcHJpdktleTogVWludDhBcnJheVxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBlY2llcy5kZWNyeXB0KHByaXZLZXksIHBheWxvYWQpO1xufVxuXG4vKipcbiAqIFByb2NlZWQgd2l0aCBTeW1tZXRyaWMgZW5jcnlwdGlvbiBvZiB0aGUgZGF0YSBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZW5jcnlwdCwgZXhwZWN0ZWQgdG8gYmUgYGZsYWdzIHwgcGF5bG9hZC1sZW5ndGggfCBwYXlsb2FkIHwgW3NpZ25hdHVyZV1gLlxuICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHVzZSBmb3IgZW5jcnlwdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YSwgYGNpcGhlclRleHQgfCB0YWcgfCBpdmAgYW5kIGNhbiBiZSBzZXQgdG8gYFdha3VNZXNzYWdlLnBheWxvYWRgLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFN5bW1ldHJpYyhcbiAgZGF0YTogVWludDhBcnJheSxcbiAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgaXYgPSBzeW1tZXRyaWMuZ2VuZXJhdGVJdigpO1xuXG4gIC8vIFJldHVybnMgYGNpcGhlciB8IHRhZ2BcbiAgY29uc3QgY2lwaGVyID0gYXdhaXQgc3ltbWV0cmljLmVuY3J5cHQoaXYsIGhleFRvQnl0ZXMoa2V5KSwgZGF0YSk7XG4gIHJldHVybiBjb25jYXQoW2NpcGhlciwgaXZdKTtcbn1cblxuLyoqXG4gKiBQcm9jZWVkIHdpdGggU3ltbWV0cmljIGRlY3J5cHRpb24gb2YgdGhlIGRhdGEgYXMgcGVyIFsyNi9XQUtVLVBBWUxPQURdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yNi8pLlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkIFRoZSBjaXBoZXIgZGF0YSwgaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYGNpcGhlclRleHQgfCB0YWcgfCBpdmAuXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBkYXRhLCBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0U3ltbWV0cmljKFxuICBwYXlsb2FkOiBVaW50OEFycmF5LFxuICBrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBpdlN0YXJ0ID0gcGF5bG9hZC5sZW5ndGggLSBzeW1tZXRyaWMuSXZTaXplO1xuICBjb25zdCBjaXBoZXIgPSBwYXlsb2FkLnNsaWNlKDAsIGl2U3RhcnQpO1xuICBjb25zdCBpdiA9IHBheWxvYWQuc2xpY2UoaXZTdGFydCk7XG5cbiAgcmV0dXJuIHN5bW1ldHJpYy5kZWNyeXB0KGl2LCBoZXhUb0J5dGVzKGtleSksIGNpcGhlcik7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGZsYWdzICYgYXV4aWxpYXJ5LWZpZWxkIGFzIHBlciBbMjYvV0FLVS1QQVlMT0FEXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjYvKS5cbiAqL1xuZnVuY3Rpb24gYWRkUGF5bG9hZFNpemVGaWVsZChtc2c6IFVpbnQ4QXJyYXksIHBheWxvYWQ6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZmllbGRTaXplID0gY29tcHV0ZVNpemVPZlBheWxvYWRTaXplRmllbGQocGF5bG9hZCk7XG4gIGxldCBmaWVsZCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBjb25zdCBmaWVsZERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpZWxkLmJ1ZmZlcik7XG4gIGZpZWxkRGF0YVZpZXcuc2V0VWludDMyKDAsIHBheWxvYWQubGVuZ3RoLCB0cnVlKTtcbiAgZmllbGQgPSBmaWVsZC5zbGljZSgwLCBmaWVsZFNpemUpO1xuICBtc2cgPSBjb25jYXQoW21zZywgZmllbGRdKTtcbiAgbXNnWzBdIHw9IGZpZWxkU2l6ZTtcbiAgcmV0dXJuIG1zZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBhdXhpbGlhcnktZmllbGQgd2hpY2ggaW4gdHVybnMgY29udGFpbnMgdGhlIHBheWxvYWQgc2l6ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlU2l6ZU9mUGF5bG9hZFNpemVGaWVsZChwYXlsb2FkOiBVaW50OEFycmF5KTogbnVtYmVyIHtcbiAgbGV0IHMgPSAxO1xuICBmb3IgKGxldCBpID0gcGF5bG9hZC5sZW5ndGg7IGkgPj0gMjU2OyBpIC89IDI1Nikge1xuICAgIHMrKztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRhSW50ZWdyaXR5KFxuICB2YWx1ZTogVWludDhBcnJheSxcbiAgZXhwZWN0ZWRTaXplOiBudW1iZXJcbik6IGJvb2xlYW4ge1xuICBpZiAodmFsdWUubGVuZ3RoICE9PSBleHBlY3RlZFNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWRTaXplIDw9IDMgfHwgdmFsdWUuZmluZEluZGV4KChpKSA9PiBpICE9PSAwKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFNpZ25hdHVyZShtZXNzYWdlOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIHJldHVybiBtZXNzYWdlLnNsaWNlKG1lc3NhZ2UubGVuZ3RoIC0gU2lnbmF0dXJlTGVuZ3RoLCBtZXNzYWdlLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhc2gobWVzc2FnZTogVWludDhBcnJheSwgaXNTaWduZWQ6IGJvb2xlYW4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGlzU2lnbmVkKSB7XG4gICAgcmV0dXJuIGtlY2NhazI1NihtZXNzYWdlLnNsaWNlKDAsIG1lc3NhZ2UubGVuZ3RoIC0gU2lnbmF0dXJlTGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIGtlY2NhazI1NihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gZWNSZWNvdmVyUHViS2V5KFxuICBtZXNzYWdlSGFzaDogVWludDhBcnJheSxcbiAgc2lnbmF0dXJlOiBVaW50OEFycmF5XG4pOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcmVjb3ZlcnlEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzaWduYXR1cmUuc2xpY2UoNjQpLmJ1ZmZlcik7XG4gIGNvbnN0IHJlY292ZXJ5ID0gcmVjb3ZlcnlEYXRhVmlldy5nZXRVaW50OCgwKTtcbiAgY29uc3QgX3NpZ25hdHVyZSA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZS5zbGljZSgwLCA2NCkpO1xuXG4gIHJldHVybiBzZWNwLnJlY292ZXJQdWJsaWNLZXkoXG4gICAgbWVzc2FnZUhhc2gsXG4gICAgX3NpZ25hdHVyZSxcbiAgICByZWNvdmVyeSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZTogY29tcHJlc3NlZDogZmFsc2VcbiAgICBmYWxzZVxuICApO1xufVxuIiwiZXhwb3J0IGNvbnN0IHNlY29uZCA9IDEwMDA7XG5leHBvcnQgY29uc3QgbWludXRlID0gNjAgKiBzZWNvbmQ7XG5cbi8qKlxuICogUmVsYXlDb2RlYyBpcyB0aGUgbGlicDJwIGlkZW50aWZpZXIgZm9yIHRoZSB3YWt1IHJlbGF5IHByb3RvY29sXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUNvZGVjcyA9IFtcbiAgXCIvdmFjL3dha3UvcmVsYXkvMi4wLjAtYmV0YTJcIixcbiAgXCIvdmFjL3dha3UvcmVsYXkvMi4wLjBcIixcbl07XG5cbmV4cG9ydCBjb25zdCBSZWxheVBpbmdDb250ZW50VG9waWMgPSBcIi9yZWxheS1waW5nLzEvcGluZy9udWxsXCI7XG5cbi8qKlxuICogUmVsYXlHb3NzaXBGYWN0b3IgYWZmZWN0cyBob3cgbWFueSBwZWVycyB3ZSB3aWxsIGVtaXQgZ29zc2lwIHRvIGF0IGVhY2ggaGVhcnRiZWF0LlxuICogV2Ugd2lsbCBzZW5kIGdvc3NpcCB0byBSZWxheUdvc3NpcEZhY3RvciAqICh0b3RhbCBudW1iZXIgb2Ygbm9uLW1lc2ggcGVlcnMpLCBvclxuICogUmVsYXlEbGF6eSwgd2hpY2hldmVyIGlzIGdyZWF0ZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUdvc3NpcEZhY3RvciA9IDAuMjU7XG5cbi8qKlxuICogR29zc2lwc3ViSGVhcnRiZWF0SW5pdGlhbERlbGF5IGlzIHRoZSBzaG9ydCBkZWxheSBiZWZvcmUgdGhlIGhlYXJ0YmVhdCB0aW1lciBiZWdpbnNcbiAqIGFmdGVyIHRoZSByb3V0ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUhlYXJ0YmVhdEluaXRpYWxEZWxheSA9IDEwMDtcblxuLyoqXG4gKiBSZWxheUhlYXJ0YmVhdEludGVydmFsIGNvbnRyb2xzIHRoZSB0aW1lIGJldHdlZW4gaGVhcnRiZWF0cy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5SGVhcnRiZWF0SW50ZXJ2YWwgPSBzZWNvbmQ7XG5cbi8qKlxuICogUmVsYXlQcnVuZVBlZXJzIGNvbnRyb2xzIHRoZSBudW1iZXIgb2YgcGVlcnMgdG8gaW5jbHVkZSBpbiBwcnVuZSBQZWVyIGVYY2hhbmdlLlxuICogV2hlbiB3ZSBwcnVuZSBhIHBlZXIgdGhhdCdzIGVsaWdpYmxlIGZvciBQWCAoaGFzIGEgZ29vZCBzY29yZSwgZXRjKSwgd2Ugd2lsbCB0cnkgdG9cbiAqIHNlbmQgdGhlbSBzaWduZWQgcGVlciByZWNvcmRzIGZvciB1cCB0byBSZWxheVBydW5lUGVlcnMgb3RoZXIgcGVlcnMgdGhhdCB3ZVxuICoga25vdyBvZi5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5UHJ1bmVQZWVycyA9IDE2O1xuXG4vKipcbiAqIFJlbGF5UHJ1bmVCYWNrb2ZmIGNvbnRyb2xzIHRoZSBiYWNrb2ZmIHRpbWUgZm9yIHBydW5lZCBwZWVycy4gVGhpcyBpcyBob3cgbG9uZ1xuICogYSBwZWVyIG11c3Qgd2FpdCBiZWZvcmUgYXR0ZW1wdGluZyB0byBncmFmdCBpbnRvIG91ciBtZXNoIGFnYWluIGFmdGVyIGJlaW5nIHBydW5lZC5cbiAqIFdoZW4gcHJ1bmluZyBhIHBlZXIsIHdlIHNlbmQgdGhlbSBvdXIgdmFsdWUgb2YgUmVsYXlQcnVuZUJhY2tvZmYgc28gdGhleSBrbm93XG4gKiB0aGUgbWluaW11bSB0aW1lIHRvIHdhaXQuIFBlZXJzIHJ1bm5pbmcgb2xkZXIgdmVyc2lvbnMgbWF5IG5vdCBzZW5kIGEgYmFja29mZiB0aW1lLFxuICogc28gaWYgd2UgcmVjZWl2ZSBhIHBydW5lIG1lc3NhZ2Ugd2l0aG91dCBvbmUsIHdlIHdpbGwgd2FpdCBhdCBsZWFzdCBSZWxheVBydW5lQmFja29mZlxuICogYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmUtZ3JhZnQuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheVBydW5lQmFja29mZiA9IG1pbnV0ZTtcblxuLyoqXG4gKiBSZWxheUZhbm91dFRUTCBjb250cm9scyBob3cgbG9uZyB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBmYW5vdXQgc3RhdGUuIElmIGl0J3MgYmVlblxuICogUmVsYXlGYW5vdXRUVEwgc2luY2Ugd2UndmUgcHVibGlzaGVkIHRvIGEgdG9waWMgdGhhdCB3ZSdyZSBub3Qgc3Vic2NyaWJlZCB0byxcbiAqIHdlJ2xsIGRlbGV0ZSB0aGUgZmFub3V0IG1hcCBmb3IgdGhhdCB0b3BpYy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5RmFub3V0VFRMID0gbWludXRlO1xuXG4vKipcbiAqIFJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0VGlja3MgaXMgdGhlIG51bWJlciBvZiBoZWFydGJlYXQgdGlja3MgZm9yIGF0dGVtcHRpbmcgdG8gaW1wcm92ZSB0aGUgbWVzaFxuICogd2l0aCBvcHBvcnR1bmlzdGljIGdyYWZ0aW5nLiBFdmVyeSBSZWxheU9wcG9ydHVuaXN0aWNHcmFmdFRpY2tzIHdlIHdpbGwgYXR0ZW1wdCB0byBzZWxlY3Qgc29tZVxuICogaGlnaC1zY29yaW5nIG1lc2ggcGVlcnMgdG8gcmVwbGFjZSBsb3dlci1zY29yaW5nIG9uZXMsIGlmIHRoZSBtZWRpYW4gc2NvcmUgb2Ygb3VyIG1lc2ggcGVlcnMgZmFsbHNcbiAqIGJlbG93IGEgdGhyZXNob2xkXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheU9wcG9ydHVuaXN0aWNHcmFmdFRpY2tzID0gNjA7XG5cbi8qKlxuICogUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRQZWVycyBpcyB0aGUgbnVtYmVyIG9mIHBlZXJzIHRvIG9wcG9ydHVuaXN0aWNhbGx5IGdyYWZ0LlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRQZWVycyA9IDI7XG5cbi8qKlxuICogUmVsYXlNYXhJSGF2ZUxlbmd0aCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gaW5jbHVkZSBpbiBhbiBJSEFWRSBtZXNzYWdlLlxuICogQWxzbyBjb250cm9scyB0aGUgbWF4aW11bSBudW1iZXIgb2YgSUhBVkUgaWRzIHdlIHdpbGwgYWNjZXB0IGFuZCByZXF1ZXN0IHdpdGggSVdBTlQgZnJvbSBhXG4gKiBwZWVyIHdpdGhpbiBhIGhlYXJ0YmVhdCwgdG8gcHJvdGVjdCBmcm9tIElIQVZFIGZsb29kcy4gWW91IHNob3VsZCBhZGp1c3QgdGhpcyB2YWx1ZSBmcm9tIHRoZVxuICogZGVmYXVsdCBpZiB5b3VyIHN5c3RlbSBpcyBwdXNoaW5nIG1vcmUgdGhhbiA1MDAwIG1lc3NhZ2VzIGluIEdvc3NpcHN1Ykhpc3RvcnlHb3NzaXAgaGVhcnRiZWF0cztcbiAqIHdpdGggdGhlIGRlZmF1bHRzIHRoaXMgaXMgMTY2NiBtZXNzYWdlcy9zLlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlNYXhJSGF2ZUxlbmd0aCA9IDUwMDA7XG4iLCJpbXBvcnQgR29zc2lwc3ViIGZyb20gXCJsaWJwMnAtZ29zc2lwc3ViXCI7XG5pbXBvcnQgeyBzaHVmZmxlIH0gZnJvbSBcImxpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzXCI7XG5cbmltcG9ydCB7IFJlbGF5Q29kZWNzIH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuLyoqXG4gKiBHaXZlbiBhIHRvcGljLCByZXR1cm5zIHVwIHRvIGNvdW50IHBlZXJzIHN1YnNjcmliZWQgdG8gdGhhdCB0b3BpY1xuICogdGhhdCBwYXNzIGFuIG9wdGlvbmFsIGZpbHRlciBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7R29zc2lwc3VifSByb3V0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpY1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXSBhIGZ1bmN0aW9uIHRvIGZpbHRlciBhY2NlcHRhYmxlIHBlZXJzXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXlQZWVycyhcbiAgcm91dGVyOiBHb3NzaXBzdWIsXG4gIHRvcGljOiBzdHJpbmcsXG4gIGNvdW50OiBudW1iZXIsXG4gIGZpbHRlcjogKGlkOiBzdHJpbmcpID0+IGJvb2xlYW4gPSAoKTogYm9vbGVhbiA9PiB0cnVlXG4pOiBTZXQ8c3RyaW5nPiB7XG4gIGNvbnN0IHBlZXJzSW5Ub3BpYyA9IHJvdXRlci50b3BpY3MuZ2V0KHRvcGljKTtcbiAgaWYgKCFwZWVyc0luVG9waWMpIHtcbiAgICByZXR1cm4gbmV3IFNldCgpO1xuICB9XG5cbiAgLy8gQWRkcyBhbGwgcGVlcnMgdXNpbmcgb3VyIHByb3RvY29sXG4gIC8vIHRoYXQgYWxzbyBwYXNzIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgbGV0IHBlZXJzOiBzdHJpbmdbXSA9IFtdO1xuICBwZWVyc0luVG9waWMuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBlZXJTdHJlYW1zID0gcm91dGVyLnBlZXJzLmdldChpZCk7XG4gICAgaWYgKCFwZWVyU3RyZWFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoUmVsYXlDb2RlY3MuaW5jbHVkZXMocGVlclN0cmVhbXMucHJvdG9jb2wpICYmIGZpbHRlcihpZCkpIHtcbiAgICAgIHBlZXJzLnB1c2goaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gUHNldWRvLXJhbmRvbWx5IHNodWZmbGVzIHBlZXJzXG4gIHBlZXJzID0gc2h1ZmZsZShwZWVycyk7XG4gIGlmIChjb3VudCA+IDAgJiYgcGVlcnMubGVuZ3RoID4gY291bnQpIHtcbiAgICBwZWVycyA9IHBlZXJzLnNsaWNlKDAsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2V0KHBlZXJzKTtcbn1cbiIsImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBMaWJwMnAgZnJvbSBcImxpYnAycFwiO1xuaW1wb3J0IEdvc3NpcHN1YiBmcm9tIFwibGlicDJwLWdvc3NpcHN1YlwiO1xuaW1wb3J0IHsgQWRkckluZm8sIE1lc3NhZ2VJZEZ1bmN0aW9uIH0gZnJvbSBcImxpYnAycC1nb3NzaXBzdWIvc3JjL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IE1lc3NhZ2VDYWNoZSB9IGZyb20gXCJsaWJwMnAtZ29zc2lwc3ViL3NyYy9tZXNzYWdlLWNhY2hlXCI7XG5pbXBvcnQgeyBSUEMgfSBmcm9tIFwibGlicDJwLWdvc3NpcHN1Yi9zcmMvbWVzc2FnZS9ycGNcIjtcbmltcG9ydCB7XG4gIFBlZXJTY29yZVBhcmFtcyxcbiAgUGVlclNjb3JlVGhyZXNob2xkcyxcbn0gZnJvbSBcImxpYnAycC1nb3NzaXBzdWIvc3JjL3Njb3JlXCI7XG5pbXBvcnQgeyBjcmVhdGVHb3NzaXBScGMsIHNodWZmbGUgfSBmcm9tIFwibGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHNcIjtcbmltcG9ydCB7IEluTWVzc2FnZSB9IGZyb20gXCJsaWJwMnAtaW50ZXJmYWNlcy9zcmMvcHVic3ViXCI7XG5pbXBvcnQgeyBTaWduYXR1cmVQb2xpY3kgfSBmcm9tIFwibGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1Yi9zaWduYXR1cmUtcG9saWN5XCI7XG5pbXBvcnQgUGVlcklkIGZyb20gXCJwZWVyLWlkXCI7XG5cbmltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IENyZWF0ZU9wdGlvbnMsIERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gXCIuLi93YWt1XCI7XG5pbXBvcnQgeyBEZWNyeXB0aW9uTWV0aG9kLCBXYWt1TWVzc2FnZSB9IGZyb20gXCIuLi93YWt1X21lc3NhZ2VcIjtcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgUmVsYXlDb2RlY3MgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJlbGF5UGVlcnMgfSBmcm9tIFwiLi9nZXRfcmVsYXlfcGVlcnNcIjtcbmltcG9ydCB7IFJlbGF5SGVhcnRiZWF0IH0gZnJvbSBcIi4vcmVsYXlfaGVhcnRiZWF0XCI7XG5cbmNvbnN0IGRiZyA9IGRlYnVnKFwid2FrdTpyZWxheVwiKTtcblxuZXhwb3J0IHsgUmVsYXlDb2RlY3MgfTtcblxuLyoqXG4gKiBTZWUgY29uc3RydWN0b3IgbGlicDJwLWdvc3NpcHN1YiBbQVBJXShodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5TYWZlL2pzLWxpYnAycC1nb3NzaXBzdWIjYXBpKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb3NzaXBPcHRpb25zIHtcbiAgZW1pdFNlbGY6IGJvb2xlYW47XG4gIGdvc3NpcEluY29taW5nOiBib29sZWFuO1xuICBmYWxsYmFja1RvRmxvb2RzdWI6IGJvb2xlYW47XG4gIGZsb29kUHVibGlzaDogYm9vbGVhbjtcbiAgZG9QWDogYm9vbGVhbjtcbiAgbXNnSWRGbjogTWVzc2FnZUlkRnVuY3Rpb247XG4gIG1lc3NhZ2VDYWNoZTogTWVzc2FnZUNhY2hlO1xuICAvLyBUaGlzIG9wdGlvbiBpcyBhbHdheXMgb3ZlcnJpZGRlblxuICAvLyBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IHN0cmluZztcbiAgc2NvcmVQYXJhbXM6IFBhcnRpYWw8UGVlclNjb3JlUGFyYW1zPjtcbiAgc2NvcmVUaHJlc2hvbGRzOiBQYXJ0aWFsPFBlZXJTY29yZVRocmVzaG9sZHM+O1xuICBkaXJlY3RQZWVyczogQWRkckluZm9bXTtcbiAgRDogbnVtYmVyO1xuICBEbG86IG51bWJlcjtcbiAgRGhpOiBudW1iZXI7XG4gIERzY29yZTogbnVtYmVyO1xuICBEb3V0OiBudW1iZXI7XG4gIERsYXp5OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgW1dha3UgdjIgUmVsYXkgcHJvdG9jb2xde0BsaW5rIGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8xMS99LlxuICogTXVzdCBiZSBwYXNzZWQgYXMgYSBgcHVic3ViYCBtb2R1bGUgdG8gYSB7TGlicDJwfSBpbnN0YW5jZS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7cmVxdWlyZSgnbGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1YicpfVxuICogQG5vSW5oZXJpdERvY1xuICovXG5leHBvcnQgY2xhc3MgV2FrdVJlbGF5IGV4dGVuZHMgR29zc2lwc3ViIHtcbiAgaGVhcnRiZWF0OiBSZWxheUhlYXJ0YmVhdDtcbiAgcHViU3ViVG9waWM6IHN0cmluZztcblxuICBwdWJsaWMgZGVjcnlwdGlvbktleXM6IE1hcDxcbiAgICBVaW50OEFycmF5LFxuICAgIHsgbWV0aG9kPzogRGVjcnlwdGlvbk1ldGhvZDsgY29udGVudFRvcGljcz86IHN0cmluZ1tdIH1cbiAgPjtcblxuICAvKipcbiAgICogb2JzZXJ2ZXJzIGNhbGxlZCB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZS5cbiAgICogT2JzZXJ2ZXJzIHVuZGVyIGtleSBgXCJcImAgYXJlIGFsd2F5cyBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2ZXJzOiB7XG4gICAgW2NvbnRlbnRUb3BpYzogc3RyaW5nXTogU2V0PChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZD47XG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbGlicDJwOiBMaWJwMnAsXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8Q3JlYXRlT3B0aW9ucyAmIEdvc3NpcE9wdGlvbnM+XG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgbGlicDJwLFxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIHNpZ25hdHVyZSBpcyBpbmNsdWRlZCBub3IgZXhwZWN0ZWQgaW4gdGhlIG1lc3NhZ2VzLlxuICAgICAgICBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IFNpZ25hdHVyZVBvbGljeS5TdHJpY3ROb1NpZ24sXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLmhlYXJ0YmVhdCA9IG5ldyBSZWxheUhlYXJ0YmVhdCh0aGlzKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMgPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdCBtdWx0aWNvZGVjcyA9IGNvbnN0YW50cy5SZWxheUNvZGVjcztcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBtdWx0aWNvZGVjcyB9KTtcblxuICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zPy5wdWJTdWJUb3BpYyB8fCBEZWZhdWx0UHViU3ViVG9waWM7XG5cbiAgICBvcHRpb25zPy5kZWNyeXB0aW9uS2V5cz8uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLmFkZERlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudHMgdGhlIGdvc3NpcHN1YiBwcm90b2NvbCBvbnRvIHRoZSBsaWJwMnAgbm9kZVxuICAgKiBhbmQgc3Vic2NyaWJlcyB0byB0aGUgZGVmYXVsdCB0b3BpYy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHN1cGVyLnN0YXJ0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmUodGhpcy5wdWJTdWJUb3BpYyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBXYWt1IG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V2FrdU1lc3NhZ2V9IG1lc3NhZ2VcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VuZChtZXNzYWdlOiBXYWt1TWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1zZyA9IG1lc3NhZ2UuZW5jb2RlKCk7XG4gICAgYXdhaXQgc3VwZXIucHVibGlzaCh0aGlzLnB1YlN1YlRvcGljLCBtc2cpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIHJlY2VpdmVkIG1lc3NhZ2VzLlxuICAgKiBUaGlzIGNhbiBlaXRoZXIgYmUgYSBwcml2YXRlIGtleSBmb3IgYXN5bW1ldHJpYyBlbmNyeXB0aW9uIG9yIGEgc3ltbWV0cmljXG4gICAqIGtleS4gYFdha3VSZWxheWAgd2lsbCBhdHRlbXB0IHRvIGRlY3J5cHQgbWVzc2FnZXMgdXNpbmcgYm90aCBtZXRob2RzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoXG4gICAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuc2V0KGhleFRvQnl0ZXMoa2V5KSwgb3B0aW9ucyA/PyB7fSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZGVjcnlwdGlvbiBrZXkgdGhhdCB3YXMgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgcmVjZWl2ZWRcbiAgICogbWVzc2FnZXMuXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgZGVsZXRlRGVjcnlwdGlvbktleShrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmRlY3J5cHRpb25LZXlzLmRlbGV0ZShoZXhUb0J5dGVzKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIG9mIG5ldyBtZXNzYWdlcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBuZXcgbWVzc2FnZSBpcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKiBAcGFyYW0gY29udGVudFRvcGljcyBDb250ZW50IFRvcGljcyBmb3Igd2hpY2ggdGhlIGNhbGxiYWNrIHdpdGggYmUgY2FsbGVkLFxuICAgKiBhbGwgb2YgdGhlbSBpZiB1bmRlZmluZWQsIFtdIG9yIFtcIlwiLC4uXSBpcyBwYXNzZWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIoXG4gICAgY2FsbGJhY2s6IChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZCxcbiAgICBjb250ZW50VG9waWNzOiBzdHJpbmdbXSA9IFtdXG4gICk6IHZvaWQge1xuICAgIGlmIChjb250ZW50VG9waWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVyc1tcIlwiXSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyc1tcIlwiXSA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXJzW1wiXCJdLmFkZChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRUb3BpY3MuZm9yRWFjaCgoY29udGVudFRvcGljKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXS5hZGQoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBvZiBuZXcgbWVzc2FnZXMgcmVjZWl2ZWQgdmlhIHdha3UgcmVsYXkuXG4gICAqIFVzZWZ1bCB0byBlbnN1cmUgdGhlIHNhbWUgb2JzZXJ2ZXIgaXMgbm90IHJlZ2lzdGVyZWQgc2V2ZXJhbCB0aW1lXG4gICAqIChlLmcgd2hlbiBsb2FkaW5nIFJlYWN0IGNvbXBvbmVudHMpXG4gICAqL1xuICBkZWxldGVPYnNlcnZlcihcbiAgICBjYWxsYmFjazogKG1lc3NhZ2U6IFdha3VNZXNzYWdlKSA9PiB2b2lkLFxuICAgIGNvbnRlbnRUb3BpY3M6IHN0cmluZ1tdID0gW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKGNvbnRlbnRUb3BpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcnNbXCJcIl0pIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbXCJcIl0uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFRvcGljcy5mb3JFYWNoKChjb250ZW50VG9waWMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10pIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyc1tjb250ZW50VG9waWNdLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJlbGF5IHBlZXJzIHdlIGFyZSBjb25uZWN0ZWQgdG8sIGFuZCB3ZSB3b3VsZCBwdWJsaXNoIGEgbWVzc2FnZSB0b1xuICAgKi9cbiAgZ2V0UGVlcnMoKTogU2V0PHN0cmluZz4ge1xuICAgIHJldHVybiBnZXRSZWxheVBlZXJzKHRoaXMsIHRoaXMucHViU3ViVG9waWMsIHRoaXMuX29wdGlvbnMuRCwgKGlkKSA9PiB7XG4gICAgICAvLyBGaWx0ZXIgcGVlcnMgd2Ugd291bGQgbm90IHB1Ymxpc2ggdG9cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuc2NvcmUuc2NvcmUoaWQpID49IHRoaXMuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLnB1Ymxpc2hUaHJlc2hvbGRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgcHVic3ViIHRvcGljIGFuZCBzdGFydCBlbWl0dGluZyBXYWt1IG1lc3NhZ2VzIHRvIG9ic2VydmVycy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdWJzY3JpYmUocHViU3ViVG9waWM6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMub24ocHViU3ViVG9waWMsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgZGVjcnlwdGlvbktleXMgPSBBcnJheS5mcm9tKHRoaXMuZGVjcnlwdGlvbktleXMpLm1hcChcbiAgICAgICAgKFtrZXksIHsgbWV0aG9kLCBjb250ZW50VG9waWNzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGNvbnRlbnRUb3BpY3MsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZGJnKGBNZXNzYWdlIHJlY2VpdmVkIG9uICR7cHViU3ViVG9waWN9YCk7XG4gICAgICBXYWt1TWVzc2FnZS5kZWNvZGUoZXZlbnQuZGF0YSwgZGVjcnlwdGlvbktleXMpXG4gICAgICAgIC50aGVuKCh3YWt1TXNnKSA9PiB7XG4gICAgICAgICAgaWYgKCF3YWt1TXNnKSB7XG4gICAgICAgICAgICBkYmcoXCJGYWlsZWQgdG8gZGVjb2RlIFdha3UgTWVzc2FnZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnNbXCJcIl0pIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW1wiXCJdLmZvckVhY2goKGNhbGxiYWNrRm4pID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tGbih3YWt1TXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2FrdU1zZy5jb250ZW50VG9waWMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVyc1t3YWt1TXNnLmNvbnRlbnRUb3BpY10pIHtcbiAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNbd2FrdU1zZy5jb250ZW50VG9waWNdLmZvckVhY2goKGNhbGxiYWNrRm4pID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZuKHdha3VNc2cpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGRiZyhcIkZhaWxlZCB0byBkZWNvZGUgV2FrdSBNZXNzYWdlXCIsIGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHN1cGVyLnN1YnNjcmliZShwdWJTdWJUb3BpYyk7XG4gIH1cblxuICAvKipcbiAgICogSm9pbiBwdWJzdWIgdG9waWMuXG4gICAqIFRoaXMgaXMgcHJlc2VudCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgR29zc2lwc3ViIGFuZCBzaG91bGQgbm90XG4gICAqIGJlIHVzZWQgYnkgQVBJIENvbnN1bWVyc1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGpvaW4odG9waWM6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWt1UmVsYXlQdWJTdWIgaGFzIG5vdCBzdGFydGVkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhbm91dFBlZXJzID0gdGhpcy5mYW5vdXQuZ2V0KHRvcGljKTtcbiAgICBpZiAoZmFub3V0UGVlcnMpIHtcbiAgICAgIC8vIHRoZXNlIHBlZXJzIGhhdmUgYSBzY29yZSBhYm92ZSB0aGUgcHVibGlzaCB0aHJlc2hvbGQsIHdoaWNoIG1heSBiZSBuZWdhdGl2ZVxuICAgICAgLy8gc28gZHJvcCB0aGUgb25lcyB3aXRoIGEgbmVnYXRpdmUgc2NvcmVcbiAgICAgIGZhbm91dFBlZXJzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNjb3JlLnNjb3JlKGlkKSA8IDApIHtcbiAgICAgICAgICBmYW5vdXRQZWVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChmYW5vdXRQZWVycy5zaXplIDwgdGhpcy5fb3B0aW9ucy5EKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgbW9yZSBwZWVyczsgZWFnZXIsIGFzIHRoaXMgd291bGQgZ2V0IGZpeGVkIGluIHRoZSBuZXh0IGhlYXJ0YmVhdFxuICAgICAgICBnZXRSZWxheVBlZXJzKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdG9waWMsXG4gICAgICAgICAgdGhpcy5fb3B0aW9ucy5EIC0gZmFub3V0UGVlcnMuc2l6ZSxcbiAgICAgICAgICAoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91ciBjdXJyZW50IHBlZXJzLCBkaXJlY3QgcGVlcnMsIGFuZCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3Jlc1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIWZhbm91dFBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5zY29yZS5zY29yZShpZCkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICkuZm9yRWFjaCgoaWQpID0+IGZhbm91dFBlZXJzLmFkZChpZCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXNoLnNldCh0b3BpYywgZmFub3V0UGVlcnMpO1xuICAgICAgdGhpcy5mYW5vdXQuZGVsZXRlKHRvcGljKTtcbiAgICAgIHRoaXMubGFzdHB1Yi5kZWxldGUodG9waWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwZWVycyA9IGdldFJlbGF5UGVlcnMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvcGljLFxuICAgICAgICB0aGlzLl9vcHRpb25zLkQsXG4gICAgICAgIChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgLy8gZmlsdGVyIGRpcmVjdCBwZWVycyBhbmQgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZVxuICAgICAgICAgIHJldHVybiAhdGhpcy5kaXJlY3QuaGFzKGlkKSAmJiB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSAwO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5tZXNoLnNldCh0b3BpYywgcGVlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1lc2guZ2V0KHRvcGljKT8uZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIHRoaXMubG9nKFwiSk9JTjogQWRkIG1lc2ggbGluayB0byAlcyBpbiAlc1wiLCBpZCwgdG9waWMpO1xuICAgICAgdGhpcy5fc2VuZEdyYWZ0KGlkLCB0b3BpYyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBtZXNzYWdlcy5cbiAgICogVGhpcyBpcyBwcmVzZW50IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvciBvZiBHb3NzaXBzdWIgYW5kIHNob3VsZCBub3RcbiAgICogYmUgdXNlZCBieSBBUEkgQ29uc3VtZXJzXG4gICAqXG4gICAqIEBpZ25vcmVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7SW5NZXNzYWdlfSBtc2dcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhc3luYyBfcHVibGlzaChtc2c6IEluTWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1zZ0lkU3RyID0gYXdhaXQgdGhpcy5nZXRDYW5vbmljYWxNc2dJZFN0cihtc2cpO1xuICAgIGlmIChtc2cucmVjZWl2ZWRGcm9tICE9PSB0aGlzLnBlZXJJZC50b0I1OFN0cmluZygpKSB7XG4gICAgICB0aGlzLnNjb3JlLmRlbGl2ZXJNZXNzYWdlKG1zZywgbXNnSWRTdHIpO1xuICAgICAgdGhpcy5nb3NzaXBUcmFjZXIuZGVsaXZlck1lc3NhZ2UobXNnSWRTdHIpO1xuICAgIH1cblxuICAgIC8vIHB1dCBpbiBzZWVuIGNhY2hlXG4gICAgdGhpcy5zZWVuQ2FjaGUucHV0KG1zZ0lkU3RyKTtcblxuICAgIHRoaXMubWVzc2FnZUNhY2hlLnB1dChtc2csIG1zZ0lkU3RyKTtcblxuICAgIGNvbnN0IHRvU2VuZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIG1zZy50b3BpY0lEcy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgY29uc3QgcGVlcnNJblRvcGljID0gdGhpcy50b3BpY3MuZ2V0KHRvcGljKTtcbiAgICAgIGlmICghcGVlcnNJblRvcGljKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0IHBlZXJzXG4gICAgICB0aGlzLmRpcmVjdC5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICB0b1NlbmQuYWRkKGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgbWVzaFBlZXJzID0gdGhpcy5tZXNoLmdldCh0b3BpYyk7XG4gICAgICBpZiAoIW1lc2hQZWVycyB8fCAhbWVzaFBlZXJzLnNpemUpIHtcbiAgICAgICAgLy8gV2UgYXJlIG5vdCBpbiB0aGUgbWVzaCBmb3IgdG9waWMsIHVzZSBmYW5vdXQgcGVlcnNcbiAgICAgICAgbWVzaFBlZXJzID0gdGhpcy5mYW5vdXQuZ2V0KHRvcGljKTtcbiAgICAgICAgaWYgKCFtZXNoUGVlcnMpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluIHRoZSBmYW5vdXQsIHRoZW4gcGljayBwZWVycyBpbiB0b3BpYyBhYm92ZSB0aGUgcHVibGlzaFRocmVzaG9sZFxuICAgICAgICAgIGNvbnN0IHBlZXJzID0gZ2V0UmVsYXlQZWVycyh0aGlzLCB0b3BpYywgdGhpcy5fb3B0aW9ucy5ELCAoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMuc2NvcmUuc2NvcmUoaWQpID49XG4gICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLnB1Ymxpc2hUaHJlc2hvbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAocGVlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIG1lc2hQZWVycyA9IHBlZXJzO1xuICAgICAgICAgICAgdGhpcy5mYW5vdXQuc2V0KHRvcGljLCBwZWVycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc2hQZWVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIGxhdGVzdCBwdWJsaXNoaW5nIHRpbWVcbiAgICAgICAgdGhpcy5sYXN0cHViLnNldCh0b3BpYywgdGhpcy5fbm93KCkpO1xuICAgICAgfVxuXG4gICAgICBtZXNoUGVlcnM/LmZvckVhY2goKHBlZXIpID0+IHtcbiAgICAgICAgdG9TZW5kLmFkZChwZWVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFB1Ymxpc2ggbWVzc2FnZXMgdG8gcGVlcnNcbiAgICBjb25zdCBycGMgPSBjcmVhdGVHb3NzaXBScGMoW0dvc3NpcHN1Yi51dGlscy5ub3JtYWxpemVPdXRScGNNZXNzYWdlKG1zZyldKTtcbiAgICBkYmcoYFJlbGF5IG1lc3NhZ2UgdG8gJHt0b1NlbmQuc2l6ZX0gcGVlcnNgKTtcbiAgICB0b1NlbmQuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGlmIChpZCA9PT0gbXNnLmZyb20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGJnKFwiUmVsYXkgbWVzc2FnZSB0b1wiLCBpZCk7XG4gICAgICB0aGlzLl9zZW5kUnBjKGlkLCBycGMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGdvc3NpcCB0byBwZWVycyBpbiBhIHBhcnRpY3VsYXIgdG9waWMuXG4gICAqXG4gICAqIFRoaXMgaXMgcHJlc2VudCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgR29zc2lwc3ViIGFuZCBzaG91bGQgbm90XG4gICAqIGJlIHVzZWQgYnkgQVBJIENvbnN1bWVyc1xuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gZXhjbHVkZSBwZWVycyB0byBleGNsdWRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2VtaXRHb3NzaXAodG9waWM6IHN0cmluZywgZXhjbHVkZTogU2V0PHN0cmluZz4pOiB2b2lkIHtcbiAgICBjb25zdCBtZXNzYWdlSURzID0gdGhpcy5tZXNzYWdlQ2FjaGUuZ2V0R29zc2lwSURzKHRvcGljKTtcbiAgICBpZiAoIW1lc3NhZ2VJRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2h1ZmZsZSB0byBlbWl0IGluIHJhbmRvbSBvcmRlclxuICAgIHNodWZmbGUobWVzc2FnZUlEcyk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgZW1pdHRpbmcgbW9yZSB0aGFuIEdvc3NpcHN1Yk1heElIYXZlTGVuZ3RoIGlkcywgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAobWVzc2FnZUlEcy5sZW5ndGggPiBjb25zdGFudHMuUmVsYXlNYXhJSGF2ZUxlbmd0aCkge1xuICAgICAgLy8gd2UgZG8gdGhlIHRydW5jYXRpb24gKHdpdGggc2h1ZmZsaW5nKSBwZXIgcGVlciBiZWxvd1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIFwidG9vIG1hbnkgbWVzc2FnZXMgZm9yIGdvc3NpcDsgd2lsbCB0cnVuY2F0ZSBJSEFWRSBsaXN0ICglZCBtZXNzYWdlcylcIixcbiAgICAgICAgbWVzc2FnZUlEcy5sZW5ndGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU2VuZCBnb3NzaXAgdG8gR29zc2lwRmFjdG9yIHBlZXJzIGFib3ZlIHRocmVzaG9sZCB3aXRoIGEgbWluaW11bSBvZiBEX2xhenlcbiAgICAvLyBGaXJzdCB3ZSBjb2xsZWN0IHRoZSBwZWVycyBhYm92ZSBnb3NzaXBUaHJlc2hvbGQgdGhhdCBhcmUgbm90IGluIHRoZSBleGNsdWRlIHNldFxuICAgIC8vIGFuZCB0aGVuIHJhbmRvbWx5IHNlbGVjdCBmcm9tIHRoYXQgc2V0XG4gICAgLy8gV2UgYWxzbyBleGNsdWRlIGRpcmVjdCBwZWVycywgYXMgdGhlcmUgaXMgbm8gcmVhc29uIHRvIGVtaXQgZ29zc2lwIHRvIHRoZW1cbiAgICBjb25zdCBwZWVyc1RvR29zc2lwOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHRvcGljUGVlcnMgPSB0aGlzLnRvcGljcy5nZXQodG9waWMpO1xuICAgIGlmICghdG9waWNQZWVycykge1xuICAgICAgLy8gbm8gdG9waWMgcGVlcnMsIG5vIGdvc3NpcFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0b3BpY1BlZXJzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBjb25zdCBwZWVyU3RyZWFtcyA9IHRoaXMucGVlcnMuZ2V0KGlkKTtcbiAgICAgIGlmICghcGVlclN0cmVhbXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAhZXhjbHVkZS5oYXMoaWQpICYmXG4gICAgICAgICF0aGlzLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgIGNvbnN0YW50cy5SZWxheUNvZGVjcy5pbmNsdWRlcyhwZWVyU3RyZWFtcy5wcm90b2NvbCkgJiZcbiAgICAgICAgdGhpcy5zY29yZS5zY29yZShpZCkgPj0gdGhpcy5fb3B0aW9ucy5zY29yZVRocmVzaG9sZHMuZ29zc2lwVGhyZXNob2xkXG4gICAgICApIHtcbiAgICAgICAgcGVlcnNUb0dvc3NpcC5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCB0YXJnZXQgPSB0aGlzLl9vcHRpb25zLkRsYXp5O1xuICAgIGNvbnN0IGZhY3RvciA9IGNvbnN0YW50cy5SZWxheUdvc3NpcEZhY3RvciAqIHBlZXJzVG9Hb3NzaXAubGVuZ3RoO1xuICAgIGlmIChmYWN0b3IgPiB0YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IGZhY3RvcjtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA+IHBlZXJzVG9Hb3NzaXAubGVuZ3RoKSB7XG4gICAgICB0YXJnZXQgPSBwZWVyc1RvR29zc2lwLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2h1ZmZsZShwZWVyc1RvR29zc2lwKTtcbiAgICB9XG4gICAgLy8gRW1pdCB0aGUgSUhBVkUgZ29zc2lwIHRvIHRoZSBzZWxlY3RlZCBwZWVycyB1cCB0byB0aGUgdGFyZ2V0XG4gICAgcGVlcnNUb0dvc3NpcC5zbGljZSgwLCB0YXJnZXQpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBsZXQgcGVlck1lc3NhZ2VJRHMgPSBtZXNzYWdlSURzO1xuICAgICAgaWYgKG1lc3NhZ2VJRHMubGVuZ3RoID4gY29uc3RhbnRzLlJlbGF5TWF4SUhhdmVMZW5ndGgpIHtcbiAgICAgICAgLy8gc2h1ZmZsZSBhbmQgc2xpY2UgbWVzc2FnZSBJRHMgcGVyIHBlZXIgc28gdGhhdCB3ZSBlbWl0IGEgZGlmZmVyZW50IHNldCBmb3IgZWFjaCBwZWVyXG4gICAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHJlZHVuZGFuY3kgaW4gdGhlIHN5c3RlbSB0aGF0IHRoaXMgd2lsbCBzaWduaWZpY2FudGx5IGluY3JlYXNlIHRoZSBtZXNzYWdlXG4gICAgICAgIC8vIGNvdmVyYWdlIHdoZW4gd2UgZG8gdHJ1bmNhdGVcbiAgICAgICAgcGVlck1lc3NhZ2VJRHMgPSBzaHVmZmxlKHBlZXJNZXNzYWdlSURzLnNsaWNlKCkpLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgY29uc3RhbnRzLlJlbGF5TWF4SUhhdmVMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3B1c2hHb3NzaXAoaWQsIHtcbiAgICAgICAgdG9waWNJRDogdG9waWMsXG4gICAgICAgIG1lc3NhZ2VJRHM6IHBlZXJNZXNzYWdlSURzLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIFBSVU5FIGNvbnRyb2wgbWVzc2FnZSBmb3IgYSBwZWVyIGluIGEgdG9waWMuXG4gICAqIFRoaXMgaXMgcHJlc2VudCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgR29zc2lwc3ViIGFuZCBzaG91bGQgbm90XG4gICAqIGJlIHVzZWQgYnkgQVBJIENvbnN1bWVyc1xuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9QWFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSUEMuSUNvbnRyb2xQcnVuZT59XG4gICAqL1xuICBhc3luYyBfbWFrZVBydW5lKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgdG9waWM6IHN0cmluZyxcbiAgICBkb1BYOiBib29sZWFuXG4gICk6IFByb21pc2U8UlBDLklDb250cm9sUHJ1bmU+IHtcbiAgICAvLyBiYWNrb2ZmIGlzIG1lYXN1cmVkIGluIHNlY29uZHNcbiAgICAvLyBSZWxheVBydW5lQmFja29mZiBpcyBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHNcbiAgICBjb25zdCBiYWNrb2ZmID0gY29uc3RhbnRzLlJlbGF5UHJ1bmVCYWNrb2ZmIC8gMTAwMDtcbiAgICBpZiAoIWRvUFgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcGljSUQ6IHRvcGljLFxuICAgICAgICBwZWVyczogW10sXG4gICAgICAgIGJhY2tvZmY6IGJhY2tvZmYsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNlbGVjdCBwZWVycyBmb3IgUGVlciBlWGNoYW5nZVxuICAgIGNvbnN0IHBlZXJzID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgIHRoaXMsXG4gICAgICB0b3BpYyxcbiAgICAgIGNvbnN0YW50cy5SZWxheVBydW5lUGVlcnMsXG4gICAgICAoeGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgcmV0dXJuIHhpZCAhPT0gaWQgJiYgdGhpcy5zY29yZS5zY29yZSh4aWQpID49IDA7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBweCA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgQXJyYXkuZnJvbShwZWVycykubWFwKGFzeW5jIChwKSA9PiB7XG4gICAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgc2lnbmVkIHJlY29yZCB0byBzZW5kIGJhY2s7IGlmIHdlIGRvbid0LCBqdXN0IHNlbmRcbiAgICAgICAgLy8gdGhlIHBlZXIgSUQgYW5kIGxldCB0aGUgcHJ1bmVkIHBlZXIgZmluZCB0aGVtIGluIHRoZSBESFQgLS0gd2UgY2FuJ3QgdHJ1c3RcbiAgICAgICAgLy8gdW5zaWduZWQgYWRkcmVzcyByZWNvcmRzIHRocm91Z2ggUFggYW55d2F5c1xuICAgICAgICAvLyBGaW5kaW5nIHNpZ25lZCByZWNvcmRzIGluIHRoZSBESFQgaXMgbm90IHN1cHBvcnRlZCBhdCB0aGUgdGltZSBvZiB3cml0aW5nIGluIGpzLWxpYnAycFxuICAgICAgICBjb25zdCBwZWVySWQgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwZWVySUQ6IHBlZXJJZC50b0J5dGVzKCksXG4gICAgICAgICAgc2lnbmVkUGVlclJlY29yZDpcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2xpYnAycC5wZWVyU3RvcmUuYWRkcmVzc0Jvb2suZ2V0UmF3RW52ZWxvcGUocGVlcklkKSxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9waWNJRDogdG9waWMsXG4gICAgICBwZWVyczogcHgsXG4gICAgICBiYWNrb2ZmOiBiYWNrb2ZmLFxuICAgIH07XG4gIH1cbn1cbiIsIi8qKlxuICogQGhpZGRlblxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCBHb3NzaXBzdWIgZnJvbSBcImxpYnAycC1nb3NzaXBzdWJcIjtcbmltcG9ydCB7IEhlYXJ0YmVhdCB9IGZyb20gXCJsaWJwMnAtZ29zc2lwc3ViL3NyYy9oZWFydGJlYXRcIjtcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tIFwibGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHNcIjtcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0UmVsYXlQZWVycyB9IGZyb20gXCIuL2dldF9yZWxheV9wZWVyc1wiO1xuXG5leHBvcnQgY2xhc3MgUmVsYXlIZWFydGJlYXQgZXh0ZW5kcyBIZWFydGJlYXQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGdvc3NpcHN1YlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdvc3NpcHN1YjogR29zc2lwc3ViKSB7XG4gICAgc3VwZXIoZ29zc2lwc3ViKTtcbiAgfVxuXG4gIHN0YXJ0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYXJ0YmVhdCA9IHRoaXMuX2hlYXJ0YmVhdC5iaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaGVhcnRiZWF0KCk7XG4gICAgICB0aGlzLl9oZWFydGJlYXRUaW1lcj8ucnVuUGVyaW9kaWNhbGx5KFxuICAgICAgICBoZWFydGJlYXQsXG4gICAgICAgIGNvbnN0YW50cy5SZWxheUhlYXJ0YmVhdEludGVydmFsXG4gICAgICApO1xuICAgIH0sIGNvbnN0YW50cy5SZWxheUhlYXJ0YmVhdEluaXRpYWxEZWxheSk7XG5cbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lciA9IHtcbiAgICAgIF9pbnRlcnZhbElkOiB1bmRlZmluZWQsXG4gICAgICBydW5QZXJpb2RpY2FsbHk6IChmbiwgcGVyaW9kKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIHRoaXMuX2hlYXJ0YmVhdFRpbWVyIGNhbm5vdCBiZSBudWxsLCBpdCBpcyBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdGhpcy5faGVhcnRiZWF0VGltZXIhLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZm4sIHBlcmlvZCk7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9oZWFydGJlYXRUaW1lcj8uX2ludGVydmFsSWQgYXMgTm9kZUpTLlRpbWVvdXQpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVubW91bnRzIHRoZSBnb3NzaXBzdWIgcHJvdG9jb2wgYW5kIHNodXRzIGRvd24gZXZlcnkgY29ubmVjdGlvblxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdG9wKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5faGVhcnRiZWF0VGltZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lci5jYW5jZWwoKTtcbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTWFpbnRhaW5zIHRoZSBtZXNoIGFuZCBmYW5vdXQgbWFwcyBpbiBnb3NzaXBzdWIuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2hlYXJ0YmVhdCgpOiB2b2lkIHtcbiAgICBjb25zdCB7IEQsIERsbywgRGhpLCBEc2NvcmUsIERvdXQgfSA9IHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zO1xuICAgIHRoaXMuZ29zc2lwc3ViLmhlYXJ0YmVhdFRpY2tzKys7XG5cbiAgICAvLyBjYWNoZSBzY29yZXMgdGhyb3VnaCB0aGUgaGVhcnRiZWF0XG4gICAgY29uc3Qgc2NvcmVzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICBjb25zdCBnZXRTY29yZSA9IChpZDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICAgIGxldCBzID0gc2NvcmVzLmdldChpZCk7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHMgPSB0aGlzLmdvc3NpcHN1Yi5zY29yZS5zY29yZShpZCk7XG4gICAgICAgIHNjb3Jlcy5zZXQoaWQsIHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcblxuICAgIC8vIHBlZXIgaWQgPT4gdG9waWNbXVxuICAgIGNvbnN0IHRvR3JhZnQgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gICAgLy8gcGVlciBpZCA9PiB0b3BpY1tdXG4gICAgY29uc3QgdG9QcnVuZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmdbXT4oKTtcbiAgICAvLyBwZWVyIGlkID0+IGRvbid0IHB4XG4gICAgY29uc3Qgbm9QWCA9IG5ldyBNYXA8c3RyaW5nLCBib29sZWFuPigpO1xuXG4gICAgLy8gY2xlYW4gdXAgZXhwaXJlZCBiYWNrb2Zmc1xuICAgIHRoaXMuZ29zc2lwc3ViLl9jbGVhckJhY2tvZmYoKTtcblxuICAgIC8vIGNsZWFuIHVwIHBlZXJoYXZlL2lhc2tlZCBjb3VudGVyc1xuICAgIHRoaXMuZ29zc2lwc3ViLnBlZXJoYXZlLmNsZWFyKCk7XG4gICAgdGhpcy5nb3NzaXBzdWIuaWFza2VkLmNsZWFyKCk7XG5cbiAgICAvLyBhcHBseSBJV0FOVCByZXF1ZXN0IHBlbmFsdGllc1xuICAgIHRoaXMuZ29zc2lwc3ViLl9hcHBseUl3YW50UGVuYWx0aWVzKCk7XG5cbiAgICAvLyBlbnN1cmUgZGlyZWN0IHBlZXJzIGFyZSBjb25uZWN0ZWRcbiAgICB0aGlzLmdvc3NpcHN1Yi5fZGlyZWN0Q29ubmVjdCgpO1xuXG4gICAgLy8gbWFpbnRhaW4gdGhlIG1lc2ggZm9yIHRvcGljcyB3ZSBoYXZlIGpvaW5lZFxuICAgIHRoaXMuZ29zc2lwc3ViLm1lc2guZm9yRWFjaCgocGVlcnMsIHRvcGljKSA9PiB7XG4gICAgICAvLyBwcnVuZS9ncmFmdCBoZWxwZXIgZnVuY3Rpb25zIChkZWZpbmVkIHBlciB0b3BpYylcbiAgICAgIGNvbnN0IHBydW5lUGVlciA9IChpZDogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLmxvZyhcbiAgICAgICAgICBcIkhFQVJUQkVBVDogUmVtb3ZlIG1lc2ggbGluayB0byAlcyBpbiAlc1wiLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRvcGljXG4gICAgICAgICk7XG4gICAgICAgIC8vIHVwZGF0ZSBwZWVyIHNjb3JlXG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLnNjb3JlLnBydW5lKGlkLCB0b3BpYyk7XG4gICAgICAgIC8vIGFkZCBwcnVuZSBiYWNrb2ZmIHJlY29yZFxuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5fYWRkQmFja29mZihpZCwgdG9waWMpO1xuICAgICAgICAvLyByZW1vdmUgcGVlciBmcm9tIG1lc2hcbiAgICAgICAgcGVlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgLy8gYWRkIHRvIHRvUHJ1bmVcbiAgICAgICAgY29uc3QgdG9waWNzID0gdG9QcnVuZS5nZXQoaWQpO1xuICAgICAgICBpZiAoIXRvcGljcykge1xuICAgICAgICAgIHRvUHJ1bmUuc2V0KGlkLCBbdG9waWNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3BpY3MucHVzaCh0b3BpYyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBncmFmdFBlZXIgPSAoaWQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXCJIRUFSVEJFQVQ6IEFkZCBtZXNoIGxpbmsgdG8gJXMgaW4gJXNcIiwgaWQsIHRvcGljKTtcbiAgICAgICAgLy8gdXBkYXRlIHBlZXIgc2NvcmVcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuc2NvcmUuZ3JhZnQoaWQsIHRvcGljKTtcbiAgICAgICAgLy8gYWRkIHBlZXIgdG8gbWVzaFxuICAgICAgICBwZWVycy5hZGQoaWQpO1xuICAgICAgICAvLyBhZGQgdG8gdG9HcmFmdFxuICAgICAgICBjb25zdCB0b3BpY3MgPSB0b0dyYWZ0LmdldChpZCk7XG4gICAgICAgIGlmICghdG9waWNzKSB7XG4gICAgICAgICAgdG9HcmFmdC5zZXQoaWQsIFt0b3BpY10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcGljcy5wdXNoKHRvcGljKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZHJvcCBhbGwgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZSwgd2l0aG91dCBQWFxuICAgICAgcGVlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRTY29yZShpZCk7XG4gICAgICAgIGlmIChzY29yZSA8IDApIHtcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXG4gICAgICAgICAgICBcIkhFQVJUQkVBVDogUHJ1bmUgcGVlciAlcyB3aXRoIG5lZ2F0aXZlIHNjb3JlOiBzY29yZT0lZCwgdG9waWM9JXNcIixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICB0b3BpY1xuICAgICAgICAgICk7XG4gICAgICAgICAgcHJ1bmVQZWVyKGlkKTtcbiAgICAgICAgICBub1BYLnNldChpZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBkbyB3ZSBoYXZlIGVub3VnaCBwZWVycz9cbiAgICAgIGlmIChwZWVycy5zaXplIDwgRGxvKSB7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLmdvc3NpcHN1Yi5iYWNrb2ZmLmdldCh0b3BpYyk7XG4gICAgICAgIGNvbnN0IGluZWVkID0gRCAtIHBlZXJzLnNpemU7XG4gICAgICAgIGNvbnN0IHBlZXJzU2V0ID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1YixcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICBpbmVlZCxcbiAgICAgICAgICAoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBtZXNoIHBlZXJzLCBkaXJlY3QgcGVlcnMsIHBlZXJzIHdlIGFyZSBiYWNraW5nIG9mZiwgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIXBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICghYmFja29mZiB8fCAhYmFja29mZi5oYXMoaWQpKSAmJlxuICAgICAgICAgICAgICBnZXRTY29yZShpZCkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcGVlcnNTZXQuZm9yRWFjaChncmFmdFBlZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyB3ZSBoYXZlIHRvIG1hbnkgcGVlcnM/XG4gICAgICBpZiAocGVlcnMuc2l6ZSA+IERoaSkge1xuICAgICAgICBsZXQgcGVlcnNBcnJheSA9IEFycmF5LmZyb20ocGVlcnMpO1xuICAgICAgICAvLyBzb3J0IGJ5IHNjb3JlXG4gICAgICAgIHBlZXJzQXJyYXkuc29ydCgoYSwgYikgPT4gZ2V0U2NvcmUoYikgLSBnZXRTY29yZShhKSk7XG4gICAgICAgIC8vIFdlIGtlZXAgdGhlIGZpcnN0IERfc2NvcmUgcGVlcnMgYnkgc2NvcmUgYW5kIHRoZSByZW1haW5pbmcgdXAgdG8gRCByYW5kb21seVxuICAgICAgICAvLyB1bmRlciB0aGUgY29uc3RyYWludCB0aGF0IHdlIGtlZXAgRF9vdXQgcGVlcnMgaW4gdGhlIG1lc2ggKGlmIHdlIGhhdmUgdGhhdCBtYW55KVxuICAgICAgICBwZWVyc0FycmF5ID0gcGVlcnNBcnJheVxuICAgICAgICAgIC5zbGljZSgwLCBEc2NvcmUpXG4gICAgICAgICAgLmNvbmNhdChzaHVmZmxlKHBlZXJzQXJyYXkuc2xpY2UoRHNjb3JlKSkpO1xuXG4gICAgICAgIC8vIGNvdW50IHRoZSBvdXRib3VuZCBwZWVycyB3ZSBhcmUga2VlcGluZ1xuICAgICAgICBsZXQgb3V0Ym91bmQgPSAwO1xuICAgICAgICBwZWVyc0FycmF5LnNsaWNlKDAsIEQpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHApKSB7XG4gICAgICAgICAgICBvdXRib3VuZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBsZXNzIHRoYW4gRF9vdXQsIGJ1YmJsZSB1cCBzb21lIG91dGJvdW5kIHBlZXJzIGZyb20gdGhlIHJhbmRvbSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKG91dGJvdW5kIDwgRG91dCkge1xuICAgICAgICAgIGNvbnN0IHJvdGF0ZSA9IChpOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIC8vIHJvdGF0ZSB0aGUgcGVlcnNBcnJheSB0byB0aGUgcmlnaHQgYW5kIHB1dCB0aGUgaXRoIHBlZXIgaW4gdGhlIGZyb250XG4gICAgICAgICAgICBjb25zdCBwID0gcGVlcnNBcnJheVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgIHBlZXJzQXJyYXlbal0gPSBwZWVyc0FycmF5W2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZXJzQXJyYXlbMF0gPSBwO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBmaXJzdCBidWJibGUgdXAgYWxsIG91dGJvdW5kIHBlZXJzIGFscmVhZHkgaW4gdGhlIHNlbGVjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgICBpZiAob3V0Ym91bmQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaWhhdmUgPSBvdXRib3VuZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgRCAmJiBpaGF2ZSA+IDA7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHBlZXJzQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgcm90YXRlKGkpO1xuICAgICAgICAgICAgICAgIGloYXZlLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBub3cgYnViYmxlIHVwIGVub3VnaCBvdXRib3VuZCBwZWVycyBvdXRzaWRlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZyb250XG4gICAgICAgICAgbGV0IGluZWVkID0gRCAtIG91dGJvdW5kO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBEOyBpIDwgcGVlcnNBcnJheS5sZW5ndGggJiYgaW5lZWQgPiAwOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdvc3NpcHN1Yi5vdXRib3VuZC5nZXQocGVlcnNBcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGkpO1xuICAgICAgICAgICAgICBpbmVlZC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBydW5lIHRoZSBleGNlc3MgcGVlcnNcbiAgICAgICAgcGVlcnNBcnJheS5zbGljZShEKS5mb3JFYWNoKHBydW5lUGVlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIHdlIGhhdmUgZW5vdWdoIG91dGJvdW5kIHBlZXJzP1xuICAgICAgaWYgKHBlZXJzLnNpemUgPj0gRGxvKSB7XG4gICAgICAgIC8vIGNvdW50IHRoZSBvdXRib3VuZCBwZWVycyB3ZSBoYXZlXG4gICAgICAgIGxldCBvdXRib3VuZCA9IDA7XG4gICAgICAgIHBlZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHApKSB7XG4gICAgICAgICAgICBvdXRib3VuZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBsZXNzIHRoYW4gRF9vdXQsIHNlbGVjdCBzb21lIHBlZXJzIHdpdGggb3V0Ym91bmQgY29ubmVjdGlvbnMgYW5kIGdyYWZ0IHRoZW1cbiAgICAgICAgaWYgKG91dGJvdW5kIDwgRG91dCkge1xuICAgICAgICAgIGNvbnN0IGluZWVkID0gRG91dCAtIG91dGJvdW5kO1xuICAgICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLmdvc3NpcHN1Yi5iYWNrb2ZmLmdldCh0b3BpYyk7XG4gICAgICAgICAgZ2V0UmVsYXlQZWVycyh0aGlzLmdvc3NpcHN1YiwgdG9waWMsIGluZWVkLCAoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91ciBjdXJyZW50IG1lc2ggcGVlcnMsIGRpcmVjdCBwZWVycywgcGVlcnMgd2UgYXJlIGJhY2tpbmcgb2ZmLCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3JlXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAhcGVlcnMuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAhdGhpcy5nb3NzaXBzdWIuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgKCFiYWNrb2ZmIHx8ICFiYWNrb2ZmLmhhcyhpZCkpICYmXG4gICAgICAgICAgICAgIGdldFNjb3JlKGlkKSA+PSAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLmZvckVhY2goZ3JhZnRQZWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzaG91bGQgd2UgdHJ5IHRvIGltcHJvdmUgdGhlIG1lc2ggd2l0aCBvcHBvcnR1bmlzdGljIGdyYWZ0aW5nP1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5oZWFydGJlYXRUaWNrcyAlXG4gICAgICAgICAgY29uc3RhbnRzLlJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0VGlja3MgPT09XG4gICAgICAgICAgMCAmJlxuICAgICAgICBwZWVycy5zaXplID4gMVxuICAgICAgKSB7XG4gICAgICAgIC8vIE9wcG9ydHVuaXN0aWMgZ3JhZnRpbmcgd29ya3MgYXMgZm9sbG93czogd2UgY2hlY2sgdGhlIG1lZGlhbiBzY29yZSBvZiBwZWVycyBpbiB0aGVcbiAgICAgICAgLy8gbWVzaDsgaWYgdGhpcyBzY29yZSBpcyBiZWxvdyB0aGUgb3Bwb3J0dW5pc3RpY0dyYWZ0VGhyZXNob2xkLCB3ZSBzZWxlY3QgYSBmZXcgcGVlcnMgYXRcbiAgICAgICAgLy8gcmFuZG9tIHdpdGggc2NvcmUgb3ZlciB0aGUgbWVkaWFuLlxuICAgICAgICAvLyBUaGUgaW50ZW50aW9uIGlzIHRvIChzbG93bHkpIGltcHJvdmUgYW4gdW5kZXIgcGVyZm9ybWluZyBtZXNoIGJ5IGludHJvZHVjaW5nIGdvb2RcbiAgICAgICAgLy8gc2NvcmluZyBwZWVycyB0aGF0IG1heSBoYXZlIGJlZW4gZ29zc2lwaW5nIGF0IHVzLiBUaGlzIGFsbG93cyB1cyB0byBnZXQgb3V0IG9mIHN0aWNreVxuICAgICAgICAvLyBzaXR1YXRpb25zIHdoZXJlIHdlIGFyZSBzdHVjayB3aXRoIHBvb3IgcGVlcnMgYW5kIGFsc28gcmVjb3ZlciBmcm9tIGNodXJuIG9mIGdvb2QgcGVlcnMuXG5cbiAgICAgICAgLy8gbm93IGNvbXB1dGUgdGhlIG1lZGlhbiBwZWVyIHNjb3JlIGluIHRoZSBtZXNoXG4gICAgICAgIGNvbnN0IHBlZXJzTGlzdCA9IEFycmF5LmZyb20ocGVlcnMpLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGdldFNjb3JlKGEpIC0gZ2V0U2NvcmUoYilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbWVkaWFuSW5kZXggPSBNYXRoLmZsb29yKHBlZXJzLnNpemUgLyAyKTtcbiAgICAgICAgY29uc3QgbWVkaWFuU2NvcmUgPSBnZXRTY29yZShwZWVyc0xpc3RbbWVkaWFuSW5kZXhdKTtcblxuICAgICAgICAvLyBpZiB0aGUgbWVkaWFuIHNjb3JlIGlzIGJlbG93IHRoZSB0aHJlc2hvbGQsIHNlbGVjdCBhIGJldHRlciBwZWVyIChpZiBhbnkpIGFuZCBHUkFGVFxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWVkaWFuU2NvcmUgPFxuICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5vcHBvcnR1bmlzdGljR3JhZnRUaHJlc2hvbGRcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYmFja29mZiA9IHRoaXMuZ29zc2lwc3ViLmJhY2tvZmYuZ2V0KHRvcGljKTtcbiAgICAgICAgICBjb25zdCBwZWVyc1RvR3JhZnQgPSBnZXRSZWxheVBlZXJzKFxuICAgICAgICAgICAgdGhpcy5nb3NzaXBzdWIsXG4gICAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICAgIGNvbnN0YW50cy5SZWxheU9wcG9ydHVuaXN0aWNHcmFmdFBlZXJzLFxuICAgICAgICAgICAgKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBjdXJyZW50IG1lc2ggcGVlcnMsIGRpcmVjdCBwZWVycywgcGVlcnMgd2UgYXJlIGJhY2tpbmcgb2ZmLCBwZWVycyBiZWxvdyBvciBhdCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBwZWVycy5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICAgKCFiYWNrb2ZmIHx8ICFiYWNrb2ZmLmhhcyhpZCkpICYmXG4gICAgICAgICAgICAgICAgZ2V0U2NvcmUoaWQpID4gbWVkaWFuU2NvcmVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHBlZXJzVG9HcmFmdC5mb3JFYWNoKChpZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXG4gICAgICAgICAgICAgIFwiSEVBUlRCRUFUOiBPcHBvcnR1bmlzdGljYWxseSBncmFmdCBwZWVyICVzIG9uIHRvcGljICVzXCIsXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICB0b3BpY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGdyYWZ0UGVlcihpZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMm5kIGFyZyBhcmUgbWVzaCBwZWVycyBleGNsdWRlZCBmcm9tIGdvc3NpcC4gV2UgaGF2ZSBhbHJlYWR5IHB1c2hlZFxuICAgICAgLy8gbWVzc2FnZXMgdG8gdGhlbSwgc28gaXRzIHJlZHVuZGFudCB0byBnb3NzaXAgSUhBVkVzLlxuICAgICAgdGhpcy5nb3NzaXBzdWIuX2VtaXRHb3NzaXAodG9waWMsIHBlZXJzKTtcbiAgICB9KTtcblxuICAgIC8vIGV4cGlyZSBmYW5vdXQgZm9yIHRvcGljcyB3ZSBoYXZlbid0IHB1Ymxpc2hlZCB0byBpbiBhIHdoaWxlXG4gICAgY29uc3Qgbm93ID0gdGhpcy5nb3NzaXBzdWIuX25vdygpO1xuICAgIHRoaXMuZ29zc2lwc3ViLmxhc3RwdWIuZm9yRWFjaCgobGFzdHB1YiwgdG9waWMpID0+IHtcbiAgICAgIGlmIChsYXN0cHViICsgY29uc3RhbnRzLlJlbGF5RmFub3V0VFRMIDwgbm93KSB7XG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLmZhbm91dC5kZWxldGUodG9waWMpO1xuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sYXN0cHViLmRlbGV0ZSh0b3BpYyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBtYWludGFpbiBvdXIgZmFub3V0IGZvciB0b3BpY3Mgd2UgYXJlIHB1Ymxpc2hpbmcgYnV0IHdlIGhhdmUgbm90IGpvaW5lZFxuICAgIHRoaXMuZ29zc2lwc3ViLmZhbm91dC5mb3JFYWNoKChmYW5vdXRQZWVycywgdG9waWMpID0+IHtcbiAgICAgIC8vIGNoZWNrcyB3aGV0aGVyIG91ciBwZWVycyBhcmUgc3RpbGwgaW4gdGhlIHRvcGljIGFuZCBoYXZlIGEgc2NvcmUgYWJvdmUgdGhlIHB1Ymxpc2ggdGhyZXNob2xkXG4gICAgICBjb25zdCB0b3BpY1BlZXJzID0gdGhpcy5nb3NzaXBzdWIudG9waWNzLmdldCh0b3BpYyk7XG4gICAgICBmYW5vdXRQZWVycy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRvcGljUGVlcnM/LmhhcyhpZCkgfHxcbiAgICAgICAgICBnZXRTY29yZShpZCkgPFxuICAgICAgICAgICAgdGhpcy5nb3NzaXBzdWIuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLnB1Ymxpc2hUaHJlc2hvbGRcbiAgICAgICAgKSB7XG4gICAgICAgICAgZmFub3V0UGVlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGRvIHdlIG5lZWQgbW9yZSBwZWVycz9cbiAgICAgIGlmIChmYW5vdXRQZWVycy5zaXplIDwgRCkge1xuICAgICAgICBjb25zdCBpbmVlZCA9IEQgLSBmYW5vdXRQZWVycy5zaXplO1xuICAgICAgICBjb25zdCBwZWVyc1NldCA9IGdldFJlbGF5UGVlcnMoXG4gICAgICAgICAgdGhpcy5nb3NzaXBzdWIsXG4gICAgICAgICAgdG9waWMsXG4gICAgICAgICAgaW5lZWQsXG4gICAgICAgICAgKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZXhpc3RpbmcgZmFub3V0IHBlZXJzLCBkaXJlY3QgcGVlcnMsIGFuZCBwZWVycyB3aXRoIHNjb3JlIGFib3ZlIHRoZSBwdWJsaXNoIHRocmVzaG9sZFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIWZhbm91dFBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgIGdldFNjb3JlKGlkKSA+PVxuICAgICAgICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5wdWJsaXNoVGhyZXNob2xkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcGVlcnNTZXQuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGZhbm91dFBlZXJzLmFkZChpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyAybmQgYXJnIGFyZSBmYW5vdXQgcGVlcnMgZXhjbHVkZWQgZnJvbSBnb3NzaXAuXG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcHVzaGVkIG1lc3NhZ2VzIHRvIHRoZW0sIHNvIGl0cyByZWR1bmRhbnQgdG8gZ29zc2lwIElIQVZFc1xuICAgICAgdGhpcy5nb3NzaXBzdWIuX2VtaXRHb3NzaXAodG9waWMsIGZhbm91dFBlZXJzKTtcbiAgICB9KTtcblxuICAgIC8vIHNlbmQgY29hbGVzY2VkIEdSQUZUL1BSVU5FIG1lc3NhZ2VzICh3aWxsIHBpZ2d5YmFjayBnb3NzaXApXG4gICAgdGhpcy5nb3NzaXBzdWIuX3NlbmRHcmFmdFBydW5lKHRvR3JhZnQsIHRvUHJ1bmUsIG5vUFgpO1xuXG4gICAgLy8gZmx1c2ggcGVuZGluZyBnb3NzaXAgdGhhdCB3YXNuJ3QgcGlnZ3liYWNrZWQgYWJvdmVcbiAgICB0aGlzLmdvc3NpcHN1Yi5fZmx1c2goKTtcblxuICAgIC8vIGFkdmFuY2UgdGhlIG1lc3NhZ2UgaGlzdG9yeSB3aW5kb3dcbiAgICB0aGlzLmdvc3NpcHN1Yi5tZXNzYWdlQ2FjaGUuc2hpZnQoKTtcblxuICAgIHRoaXMuZ29zc2lwc3ViLmVtaXQoXCJnb3NzaXBzdWI6aGVhcnRiZWF0XCIpO1xuICB9XG59XG4iLCJpbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IHsgUmVhZGVyIH0gZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5cbmltcG9ydCAqIGFzIHByb3RvVjJCZXRhMyBmcm9tIFwiLi4vLi4vcHJvdG8vd2FrdS92Mi9zdG9yZS92MmJldGEzL3N0b3JlXCI7XG5pbXBvcnQgKiBhcyBwcm90b1YyQmV0YTQgZnJvbSBcIi4uLy4uL3Byb3RvL3dha3UvdjIvc3RvcmUvdjJiZXRhNC9zdG9yZVwiO1xuXG5pbXBvcnQgeyBTdG9yZUNvZGVjcyB9IGZyb20gXCIuL2luZGV4XCI7XG5cbmV4cG9ydCBlbnVtIFBhZ2VEaXJlY3Rpb24ge1xuICBCQUNLV0FSRCA9IFwiYmFja3dhcmRcIixcbiAgRk9SV0FSRCA9IFwiZm9yd2FyZFwiLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFtcyB7XG4gIGNvbnRlbnRUb3BpY3M6IHN0cmluZ1tdO1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuICBwYWdlRGlyZWN0aW9uOiBQYWdlRGlyZWN0aW9uO1xuICBwYWdlU2l6ZTogbnVtYmVyO1xuICBzdGFydFRpbWU/OiBEYXRlO1xuICBlbmRUaW1lPzogRGF0ZTtcbiAgY3Vyc29yPzogcHJvdG9WMkJldGEzLkluZGV4IHwgcHJvdG9WMkJldGE0LkluZGV4O1xuICBzdG9yZUNvZGVjPzogU3RvcmVDb2RlY3M7XG59XG5cbmV4cG9ydCBjbGFzcyBIaXN0b3J5UlBDIHtcbiAgcHJpdmF0ZSByZWFkb25seSBwcm90b0NvZGVjOiBhbnk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJvdG86IHByb3RvVjJCZXRhMy5IaXN0b3J5UlBDIHwgcHJvdG9WMkJldGE0Lkhpc3RvcnlSUEMsXG4gICAgcHVibGljIHJlYWRvbmx5IHN0b3JlQ29kZWM6IFN0b3JlQ29kZWNzXG4gICkge1xuICAgIHN3aXRjaCAoc3RvcmVDb2RlYykge1xuICAgICAgY2FzZSBTdG9yZUNvZGVjcy5WMkJldGEzOlxuICAgICAgICB0aGlzLnByb3RvQ29kZWMgPSBwcm90b1YyQmV0YTM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdG9yZUNvZGVjcy5WMkJldGE0OlxuICAgICAgICB0aGlzLnByb3RvQ29kZWMgPSBwcm90b1YyQmV0YTQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgYEludGVybmFsIEVycm9yOiBVbmV4cGVjdGVkIHN0b3JlIGNvZGVjIHZhbHVlIHJlY2VpdmVkIGluIGNvbnN0cnVjdG9yOiAke3N0b3JlQ29kZWN9YDtcbiAgICB9XG4gIH1cblxuICBnZXQgcXVlcnkoKTpcbiAgICB8IHByb3RvVjJCZXRhMy5IaXN0b3J5UXVlcnlcbiAgICB8IHByb3RvVjJCZXRhNC5IaXN0b3J5UXVlcnlcbiAgICB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucXVlcnk7XG4gIH1cblxuICBnZXQgcmVzcG9uc2UoKTpcbiAgICB8IHByb3RvVjJCZXRhMy5IaXN0b3J5UmVzcG9uc2VcbiAgICB8IHByb3RvVjJCZXRhNC5IaXN0b3J5UmVzcG9uc2VcbiAgICB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIEhpc3RvcnkgUXVlcnkuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlUXVlcnkocGFyYW1zOiBQYXJhbXMpOiBIaXN0b3J5UlBDIHtcbiAgICBjb25zdCBzdG9yZUNvZGVjID0gcGFyYW1zLnN0b3JlQ29kZWMgPz8gU3RvcmVDb2RlY3MuVjJCZXRhNDtcblxuICAgIGNvbnN0IGNvbnRlbnRGaWx0ZXJzID0gcGFyYW1zLmNvbnRlbnRUb3BpY3MubWFwKChjb250ZW50VG9waWMpID0+IHtcbiAgICAgIHJldHVybiB7IGNvbnRlbnRUb3BpYyB9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uVG9Qcm90byhwYXJhbXMucGFnZURpcmVjdGlvbik7XG5cbiAgICBzd2l0Y2ggKHN0b3JlQ29kZWMpIHtcbiAgICAgIGNhc2UgU3RvcmVDb2RlY3MuVjJCZXRhMzpcbiAgICAgICAgLy8gVXNpbmcgZnVuY3Rpb24gdG8gc2NvcGUgdmFyaWFibGVzXG4gICAgICAgIHJldHVybiAoKCk6IEhpc3RvcnlSUEMgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2luZ0luZm8gPSB7XG4gICAgICAgICAgICBwYWdlU2l6ZTogTG9uZy5mcm9tTnVtYmVyKHBhcmFtcy5wYWdlU2l6ZSksXG4gICAgICAgICAgICBjdXJzb3I6IHBhcmFtcy5jdXJzb3IsXG4gICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgfSBhcyBwcm90b1YyQmV0YTMuUGFnaW5nSW5mbztcblxuICAgICAgICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgICAgICAgaWYgKHBhcmFtcy5zdGFydFRpbWUpIHN0YXJ0VGltZSA9IHBhcmFtcy5zdGFydFRpbWUudmFsdWVPZigpIC8gMTAwMDtcblxuICAgICAgICAgIGlmIChwYXJhbXMuZW5kVGltZSkgZW5kVGltZSA9IHBhcmFtcy5lbmRUaW1lLnZhbHVlT2YoKSAvIDEwMDA7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlSUEMoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogdXVpZCgpLFxuICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIHB1YlN1YlRvcGljOiBwYXJhbXMucHViU3ViVG9waWMsXG4gICAgICAgICAgICAgICAgY29udGVudEZpbHRlcnMsXG4gICAgICAgICAgICAgICAgcGFnaW5nSW5mbyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9yZUNvZGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIGNhc2UgU3RvcmVDb2RlY3MuVjJCZXRhNDpcbiAgICAgICAgcmV0dXJuICgoKTogSGlzdG9yeVJQQyA9PiB7XG4gICAgICAgICAgY29uc3QgcGFnaW5nSW5mbyA9IHtcbiAgICAgICAgICAgIHBhZ2VTaXplOiBMb25nLmZyb21OdW1iZXIocGFyYW1zLnBhZ2VTaXplKSxcbiAgICAgICAgICAgIGN1cnNvcjogcGFyYW1zLmN1cnNvcixcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICB9IGFzIHByb3RvVjJCZXRhNC5QYWdpbmdJbmZvO1xuXG4gICAgICAgICAgbGV0IHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICAgICAgICBpZiAocGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmRzIDEwXi0zIHRvIG5hbm9zZWNvbmRzIDEwXi05XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBMb25nLmZyb21OdW1iZXIocGFyYW1zLnN0YXJ0VGltZS52YWx1ZU9mKCkpLm11bChcbiAgICAgICAgICAgICAgMV8wMDBfMDAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhbXMuZW5kVGltZSkge1xuICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmRzIDEwXi0zIHRvIG5hbm9zZWNvbmRzIDEwXi05XG4gICAgICAgICAgICBlbmRUaW1lID0gTG9uZy5mcm9tTnVtYmVyKHBhcmFtcy5lbmRUaW1lLnZhbHVlT2YoKSkubXVsKDFfMDAwXzAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVJQQyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiB1dWlkKCksXG4gICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgcHViU3ViVG9waWM6IHBhcmFtcy5wdWJTdWJUb3BpYyxcbiAgICAgICAgICAgICAgICBjb250ZW50RmlsdGVycyxcbiAgICAgICAgICAgICAgICBwYWdpbmdJbmZvLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXNwb25zZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3JlQ29kZWNcbiAgICAgICAgICApO1xuICAgICAgICB9KSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBgSW50ZXJuYWwgRXJyb3I6IFVuZXhwZWN0ZWQgc3RvcmUgY29kZWMgdmFsdWUgcmVjZWl2ZWQgaW4gY3JlYXRlUXVlcnk6ICR7c3RvcmVDb2RlY31gO1xuICAgIH1cbiAgfVxuXG4gIGRlY29kZShieXRlczogVWludDhBcnJheSk6IEhpc3RvcnlSUEMge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMucHJvdG9Db2RlYy5IaXN0b3J5UlBDLmRlY29kZShSZWFkZXIuY3JlYXRlKGJ5dGVzKSk7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5UlBDKHJlcywgdGhpcy5zdG9yZUNvZGVjKTtcbiAgfVxuXG4gIGVuY29kZSgpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm90b0NvZGVjLkhpc3RvcnlSUEMuZW5jb2RlKHRoaXMucHJvdG8pLmZpbmlzaCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpcmVjdGlvblRvUHJvdG8oXG4gIHBhZ2VEaXJlY3Rpb246IFBhZ2VEaXJlY3Rpb25cbik6IHByb3RvVjJCZXRhNC5QYWdpbmdJbmZvX0RpcmVjdGlvbiB7XG4gIHN3aXRjaCAocGFnZURpcmVjdGlvbikge1xuICAgIGNhc2UgUGFnZURpcmVjdGlvbi5CQUNLV0FSRDpcbiAgICAgIHJldHVybiBwcm90b1YyQmV0YTQuUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEO1xuICAgIGNhc2UgUGFnZURpcmVjdGlvbi5GT1JXQVJEOlxuICAgICAgcmV0dXJuIHByb3RvVjJCZXRhNC5QYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fRk9SV0FSRDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHByb3RvVjJCZXRhNC5QYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQ7XG4gIH1cbn1cbiIsImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBjb25jYXQgZnJvbSBcIml0LWNvbmNhdFwiO1xuaW1wb3J0IGxwIGZyb20gXCJpdC1sZW5ndGgtcHJlZml4ZWRcIjtcbmltcG9ydCB7IHBpcGUgfSBmcm9tIFwiaXQtcGlwZVwiO1xuaW1wb3J0IExpYnAycCBmcm9tIFwibGlicDJwXCI7XG5pbXBvcnQgeyBQZWVyIH0gZnJvbSBcImxpYnAycC9zcmMvcGVlci1zdG9yZVwiO1xuaW1wb3J0IFBlZXJJZCBmcm9tIFwicGVlci1pZFwiO1xuXG5pbXBvcnQgeyBnZXRQZWVyc0ZvclByb3RvY29sLCBzZWxlY3RSYW5kb21QZWVyIH0gZnJvbSBcIi4uL3NlbGVjdF9wZWVyXCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgeyBEZWZhdWx0UHViU3ViVG9waWMgfSBmcm9tIFwiLi4vd2FrdVwiO1xuaW1wb3J0IHsgRGVjcnlwdGlvbk1ldGhvZCwgV2FrdU1lc3NhZ2UgfSBmcm9tIFwiLi4vd2FrdV9tZXNzYWdlXCI7XG5cbmltcG9ydCB7IEhpc3RvcnlSUEMsIFBhZ2VEaXJlY3Rpb24gfSBmcm9tIFwiLi9oaXN0b3J5X3JwY1wiO1xuXG5jb25zdCBkYmcgPSBkZWJ1ZyhcIndha3U6c3RvcmVcIik7XG5cbmV4cG9ydCBlbnVtIFN0b3JlQ29kZWNzIHtcbiAgVjJCZXRhMyA9IFwiL3ZhYy93YWt1L3N0b3JlLzIuMC4wLWJldGEzXCIsXG4gIFYyQmV0YTQgPSBcIi92YWMvd2FrdS9zdG9yZS8yLjAuMC1iZXRhNFwiLFxufVxuXG5leHBvcnQgY29uc3QgRGVmYXVsdFBhZ2VTaXplID0gMTA7XG5cbmV4cG9ydCB7IFBhZ2VEaXJlY3Rpb24gfTtcblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBQdWJTdWIgVG9waWMgdG8gdXNlLiBEZWZhdWx0cyB0byB7QGxpbmsgRGVmYXVsdFB1YlN1YlRvcGljfS5cbiAgICpcbiAgICogVGhlIHVzYWdlIG9mIHRoZSBkZWZhdWx0IHB1YnN1YiB0b3BpYyBpcyByZWNvbW1lbmRlZC5cbiAgICogU2VlIFtXYWt1IHYyIFRvcGljIFVzYWdlIFJlY29tbWVuZGF0aW9uc10oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzIzLykgZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9XG4gICAqL1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lRmlsdGVyIHtcbiAgc3RhcnRUaW1lOiBEYXRlO1xuICBlbmRUaW1lOiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGVlciB0byBxdWVyeS4gSWYgdW5kZWZpbmVkLCBhIHBzZXVkby1yYW5kb20gcGVlciBpcyBzZWxlY3RlZCBmcm9tIHRoZSBjb25uZWN0ZWQgV2FrdSBTdG9yZSBwZWVycy5cbiAgICovXG4gIHBlZXJJZD86IFBlZXJJZDtcbiAgLyoqXG4gICAqIFRoZSBwdWJzdWIgdG9waWMgdG8gcGFzcyB0byB0aGUgcXVlcnkuXG4gICAqIFNlZSBbV2FrdSB2MiBUb3BpYyBVc2FnZSBSZWNvbW1lbmRhdGlvbnNdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yMy8pLlxuICAgKi9cbiAgcHViU3ViVG9waWM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHBhZ2VzIGFyZSByZXRyaWV2ZWQ6XG4gICAqIC0gW1tQYWdlRGlyZWN0aW9uLkJBQ0tXQVJEXV06IE1vc3QgcmVjZW50IHBhZ2UgZmlyc3QuXG4gICAqIC0gW1tQYWdlRGlyZWN0aW9uLkZPUldBUkRdXTogT2xkZXN0IHBhZ2UgZmlyc3QuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBvcmRlcmluZyBvZiBtZXNzYWdlcyB3aXRoIHRoZSBwYWdlXG4gICAqIChvbGRlc3QgbWVzc2FnZSBpcyBhbHdheXMgZmlyc3QpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbW1BhZ2VEaXJlY3Rpb24uQkFDS1dBUkRdXVxuICAgKi9cbiAgcGFnZURpcmVjdGlvbj86IFBhZ2VEaXJlY3Rpb247XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1lc3NhZ2UgcGVyIHBhZ2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IFtbRGVmYXVsdFBhZ2VTaXplXV1cbiAgICovXG4gIHBhZ2VTaXplPzogbnVtYmVyO1xuICAvKipcbiAgICogUmV0cmlldmUgbWVzc2FnZXMgd2l0aCBhIHRpbWVzdGFtcCB3aXRoaW4gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAgICovXG4gIHRpbWVGaWx0ZXI/OiBUaW1lRmlsdGVyO1xuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIG9uIHBhZ2VzIG9mIHN0b3JlZCBtZXNzYWdlcyBhcyB0aGV5IGFyZSByZXRyaWV2ZWQuXG4gICAqXG4gICAqIEFsbG93cyBmb3IgYSBmYXN0ZXIgYWNjZXNzIHRvIHRoZSByZXN1bHRzIGFzIGl0IGlzIGNhbGxlZCBhcyBzb29uIGFzIGEgcGFnZVxuICAgKiBpcyByZWNlaXZlZC4gVHJhdmVyc2FsIG9mIHRoZSBwYWdlcyBpcyBkb25lIGF1dG9tYXRpY2FsbHkgc28gdGhpcyBmdW5jdGlvblxuICAgKiB3aWxsIGludm9rZWQgZm9yIGVhY2ggcmV0cmlldmVkIHBhZ2UuXG4gICAqXG4gICAqIElmIHRoZSBjYWxsIG9uIGEgcGFnZSByZXR1cm5zIGB0cnVlYCwgdGhlbiB0cmF2ZXJzYWwgb2YgdGhlIHBhZ2VzIGlzIGFib3J0ZWQuXG4gICAqIEZvciBleGFtcGxlLCB0aGlzIGNhbiBiZSB1c2VkIGZvciB0aGUgY2FsbGVyIHRvIHN0b3AgdGhlIHF1ZXJ5IGFmdGVyIGFcbiAgICogc3BlY2lmaWMgbWVzc2FnZSBpcyBmb3VuZC5cbiAgICovXG4gIGNhbGxiYWNrPzogKG1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdKSA9PiB2b2lkIHwgYm9vbGVhbjtcbiAgLyoqXG4gICAqIEtleXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjcnlwdCBtZXNzYWdlcy5cbiAgICpcbiAgICogSXQgY2FuIGJlIEFzeW1tZXRyaWMgUHJpdmF0ZSBLZXlzIGFuZCBTeW1tZXRyaWMgS2V5cyBpbiB0aGUgc2FtZSBhcnJheSxcbiAgICogYWxsIGtleXMgd2lsbCBiZSB0cmllZCB3aXRoIGJvdGggbWV0aG9kcy5cbiAgICovXG4gIGRlY3J5cHRpb25LZXlzPzogQXJyYXk8VWludDhBcnJheSB8IHN0cmluZz47XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgW1dha3UgdjIgU3RvcmUgcHJvdG9jb2xdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8xMy8pLlxuICpcbiAqIFRoZSBXYWt1IFN0b3JlIHByb3RvY29sIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlZCBoaXN0b3JpY2FsIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgY2xhc3MgV2FrdVN0b3JlIHtcbiAgcHViU3ViVG9waWM6IHN0cmluZztcbiAgcHVibGljIGRlY3J5cHRpb25LZXlzOiBNYXA8XG4gICAgVWludDhBcnJheSxcbiAgICB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gID47XG5cbiAgY29uc3RydWN0b3IocHVibGljIGxpYnAycDogTGlicDJwLCBvcHRpb25zPzogQ3JlYXRlT3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5wdWJTdWJUb3BpYykge1xuICAgICAgdGhpcy5wdWJTdWJUb3BpYyA9IG9wdGlvbnMucHViU3ViVG9waWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHViU3ViVG9waWMgPSBEZWZhdWx0UHViU3ViVG9waWM7XG4gICAgfVxuXG4gICAgdGhpcy5kZWNyeXB0aW9uS2V5cyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEbyBhIHF1ZXJ5IHRvIGEgV2FrdSBTdG9yZSB0byByZXRyaWV2ZSBoaXN0b3JpY2FsL21pc3NlZCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRlbnRUb3BpY3MgVGhlIGNvbnRlbnQgdG9waWNzIHRvIHBhc3MgdG8gdGhlIHF1ZXJ5LCBsZWF2ZSBlbXB0eSB0b1xuICAgKiByZXRyaWV2ZSBhbGwgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEB0aHJvd3MgSWYgbm90IGFibGUgdG8gcmVhY2ggYSBXYWt1IFN0b3JlIHBlZXIgdG8gcXVlcnlcbiAgICogb3IgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hlbiBwcm9jZXNzaW5nIHRoZSByZXBseS5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5SGlzdG9yeShcbiAgICBjb250ZW50VG9waWNzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zPzogUXVlcnlPcHRpb25zXG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2VbXT4ge1xuICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XG5cbiAgICBpZiAob3B0aW9ucz8udGltZUZpbHRlcikge1xuICAgICAgc3RhcnRUaW1lID0gb3B0aW9ucy50aW1lRmlsdGVyLnN0YXJ0VGltZTtcbiAgICAgIGVuZFRpbWUgPSBvcHRpb25zLnRpbWVGaWx0ZXIuZW5kVGltZTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgcHViU3ViVG9waWM6IHRoaXMucHViU3ViVG9waWMsXG4gICAgICAgIHBhZ2VEaXJlY3Rpb246IFBhZ2VEaXJlY3Rpb24uQkFDS1dBUkQsXG4gICAgICAgIHBhZ2VTaXplOiBEZWZhdWx0UGFnZVNpemUsXG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHsgY29udGVudFRvcGljcywgc3RhcnRUaW1lLCBlbmRUaW1lIH1cbiAgICApO1xuXG4gICAgZGJnKFwiUXVlcnlpbmcgaGlzdG9yeSB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uc1wiLCB7XG4gICAgICBwZWVySWQ6IG9wdGlvbnM/LnBlZXJJZD8udG9CNThTdHJpbmcoKSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBsZXQgcGVlcjtcbiAgICBpZiAob3B0cy5wZWVySWQpIHtcbiAgICAgIHBlZXIgPSBhd2FpdCB0aGlzLmxpYnAycC5wZWVyU3RvcmUuZ2V0KG9wdHMucGVlcklkKTtcbiAgICAgIGlmICghcGVlcilcbiAgICAgICAgdGhyb3cgYEZhaWxlZCB0byByZXRyaWV2ZSBjb25uZWN0aW9uIGRldGFpbHMgZm9yIHByb3ZpZGVkIHBlZXIgaW4gcGVlciBzdG9yZTogJHtvcHRzLnBlZXJJZC50b0I1OFN0cmluZygpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZXIgPSBhd2FpdCB0aGlzLnJhbmRvbVBlZXI7XG4gICAgICBpZiAoIXBlZXIpXG4gICAgICAgIHRocm93IFwiRmFpbGVkIHRvIGZpbmQga25vd24gcGVlciB0aGF0IHJlZ2lzdGVycyB3YWt1IHN0b3JlIHByb3RvY29sXCI7XG4gICAgfVxuXG4gICAgbGV0IHN0b3JlQ29kZWMgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgT2JqZWN0LnZhbHVlcyhTdG9yZUNvZGVjcykpIHtcbiAgICAgIGlmIChwZWVyLnByb3RvY29scy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICAgICAgc3RvcmVDb2RlYyA9IGNvZGVjO1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgYXMgd2Ugd2FudCB0byBrZWVwIHRoZSBsYXN0IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGRiZyhgVXNlIHN0b3JlIGNvZGVjICR7c3RvcmVDb2RlY31gKTtcbiAgICBpZiAoIXN0b3JlQ29kZWMpXG4gICAgICB0aHJvdyBgUGVlciBkb2VzIG5vdCByZWdpc3RlciB3YWt1IHN0b3JlIHByb3RvY29sOiAke3BlZXIuaWQudG9CNThTdHJpbmcoKX1gO1xuXG4gICAgT2JqZWN0LmFzc2lnbihvcHRzLCB7IHN0b3JlQ29kZWMgfSk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMubGlicDJwLmNvbm5lY3Rpb25NYW5hZ2VyLmdldChwZWVyLmlkKTtcbiAgICBpZiAoIWNvbm5lY3Rpb24pIHRocm93IFwiRmFpbGVkIHRvIGdldCBhIGNvbm5lY3Rpb24gdG8gdGhlIHBlZXJcIjtcblxuICAgIGNvbnN0IGRlY3J5cHRpb25LZXlzID0gQXJyYXkuZnJvbSh0aGlzLmRlY3J5cHRpb25LZXlzKS5tYXAoXG4gICAgICAoW2tleSwgeyBtZXRob2QsIGNvbnRlbnRUb3BpY3MgfV0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGNvbnRlbnRUb3BpY3MsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIEFkZCB0aGUgZGVjcnlwdGlvbiBrZXlzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFnYWluc3QgdGhlXG4gICAgLy8gY29udGVudCB0b3BpY3MgYWxzbyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICBpZiAob3B0cy5kZWNyeXB0aW9uS2V5cykge1xuICAgICAgb3B0cy5kZWNyeXB0aW9uS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgZGVjcnlwdGlvbktleXMucHVzaCh7XG4gICAgICAgICAga2V5OiBoZXhUb0J5dGVzKGtleSksXG4gICAgICAgICAgY29udGVudFRvcGljczogY29udGVudFRvcGljcy5sZW5ndGggPyBjb250ZW50VG9waWNzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdID0gW107XG4gICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBzdHJlYW0gfSA9IGF3YWl0IGNvbm5lY3Rpb24ubmV3U3RyZWFtKHN0b3JlQ29kZWMpO1xuICAgICAgY29uc3QgcXVlcnlPcHRzID0gT2JqZWN0LmFzc2lnbihvcHRzLCB7IGN1cnNvciB9KTtcbiAgICAgIGNvbnN0IGhpc3RvcnlScGNRdWVyeSA9IEhpc3RvcnlSUEMuY3JlYXRlUXVlcnkocXVlcnlPcHRzKTtcbiAgICAgIGRiZyhcIlF1ZXJ5aW5nIHN0b3JlIHBlZXJcIiwgY29ubmVjdGlvbi5yZW1vdGVBZGRyLnRvU3RyaW5nKCkpO1xuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwaXBlKFxuICAgICAgICBbaGlzdG9yeVJwY1F1ZXJ5LmVuY29kZSgpXSxcbiAgICAgICAgbHAuZW5jb2RlKCksXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbHAuZGVjb2RlKCksXG4gICAgICAgIGNvbmNhdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlcGx5ID0gaGlzdG9yeVJwY1F1ZXJ5LmRlY29kZShyZXMuc2xpY2UoKSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVwbHkucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IFwiSGlzdG9yeSByZXNwb25zZSBtaXNzZXMgcmVzcG9uc2UgZmllbGRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIHRocm93IFwiSGlzdG9yeSByZXNwb25zZSBjb250YWlucyBhbiBFcnJvclwiICsgcmVzcG9uc2UuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2UubWVzc2FnZXMgfHwgIXJlc3BvbnNlLm1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAvLyBObyBtZXNzYWdlcyBsZWZ0IChvciBzdG9yZWQpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gbWVzc2FnZXMgcHJlc2VudCBpbiBIaXN0b3J5UlBDIHJlc3BvbnNlXCIpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9XG5cbiAgICAgIGRiZyhcbiAgICAgICAgYCR7cmVzcG9uc2UubWVzc2FnZXMubGVuZ3RofSBtZXNzYWdlcyByZXRyaWV2ZWQgZm9yIHB1YnN1YiB0b3BpYyAke29wdHMucHViU3ViVG9waWN9YFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcGFnZU1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdID0gW107XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVzcG9uc2UubWVzc2FnZXMubWFwKGFzeW5jIChwcm90b01zZykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IFdha3VNZXNzYWdlLmRlY29kZVByb3RvKHByb3RvTXNnLCBkZWNyeXB0aW9uS2V5cyk7XG5cbiAgICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgICAgICAgICBwYWdlTWVzc2FnZXMucHVzaChtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGxldCBhYm9ydCA9IGZhbHNlO1xuICAgICAgaWYgKG9wdHMuY2FsbGJhY2spIHtcbiAgICAgICAgYWJvcnQgPSBCb29sZWFuKG9wdHMuY2FsbGJhY2socGFnZU1lc3NhZ2VzKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlUGFnZVNpemUgPSByZXNwb25zZS5wYWdpbmdJbmZvPy5wYWdlU2l6ZTtcbiAgICAgIGNvbnN0IHF1ZXJ5UGFnZVNpemUgPSBoaXN0b3J5UnBjUXVlcnkucXVlcnk/LnBhZ2luZ0luZm8/LnBhZ2VTaXplO1xuICAgICAgaWYgKFxuICAgICAgICBhYm9ydCB8fFxuICAgICAgICAvLyBSZXNwb25zZSBwYWdlIHNpemUgc21hbGxlciB0aGFuIHF1ZXJ5LCBtZWFuaW5nIHRoaXMgaXMgdGhlIGxhc3QgcGFnZVxuICAgICAgICAocmVzcG9uc2VQYWdlU2l6ZSAmJiBxdWVyeVBhZ2VTaXplICYmIHJlc3BvbnNlUGFnZVNpemUgPCBxdWVyeVBhZ2VTaXplKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgIH1cblxuICAgICAgY3Vyc29yID0gcmVzcG9uc2UucGFnaW5nSW5mbz8uY3Vyc29yO1xuICAgICAgaWYgKGN1cnNvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgZG9lcyBub3QgcmV0dXJuIGN1cnNvciB0aGVuIHRoZXJlIGlzIGFuIGlzc3VlLFxuICAgICAgICAvLyBOZWVkIHRvIGFib3J0IG9yIHdlIGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gY3Vyc29yIHJldHVybmVkIGJ5IHBlZXIuXCIpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzIHJlY2VpdmVkIGluIGFueVxuICAgKiBzdWJzZXF1ZW50IFtbcXVlcnlIaXN0b3J5XV0gY2FsbC4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpYyBrZXkuIFtbV2FrdVN0b3JlXV0gd2lsbCBhdHRlbXB0IHRvXG4gICAqIGRlY3J5cHQgbWVzc2FnZXMgdXNpbmcgYm90aCBtZXRob2RzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoXG4gICAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuc2V0KGhleFRvQnl0ZXMoa2V5KSwgb3B0aW9ucyA/PyB7fSk7XG4gIH1cblxuICAvKipjdXJzb3JWMkJldGE0XG4gICAqIERlbGV0ZSBhIGRlY3J5cHRpb24ga2V5IHRoYXQgd2FzIHVzZWQgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzXG4gICAqIHJlY2VpdmVkIGluIHN1YnNlcXVlbnQgW1txdWVyeUhpc3RvcnldXSBjYWxscy5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBkZWxldGVEZWNyeXB0aW9uS2V5KGtleTogVWludDhBcnJheSB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuZGVsZXRlKGhleFRvQnl0ZXMoa2V5KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBrbm93biBwZWVycyBmcm9tIHRoZSBhZGRyZXNzIGJvb2sgKGBsaWJwMnAucGVlclN0b3JlYCkgdGhhdCBzdXBwb3J0XG4gICAqIHN0b3JlIHByb3RvY29sLiBXYWt1IG1heSBvciAgbWF5IG5vdCBiZSBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHRoZXNlIHBlZXJzLlxuICAgKi9cbiAgZ2V0IHBlZXJzKCk6IEFzeW5jSXRlcmFibGU8UGVlcj4ge1xuICAgIGNvbnN0IGNvZGVjcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgT2JqZWN0LnZhbHVlcyhTdG9yZUNvZGVjcykpIHtcbiAgICAgIGNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UGVlcnNGb3JQcm90b2NvbCh0aGlzLmxpYnAycCwgY29kZWNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyBzdG9yZSBwcm90b2NvbCBmcm9tIHRoZSBhZGRyZXNzXG4gICAqIGJvb2sgKGBsaWJwMnAucGVlclN0b3JlYCkuIFdha3UgbWF5IG9yICBtYXkgbm90IGJlIGN1cnJlbnRseSBjb25uZWN0ZWQgdG9cbiAgICogdGhpcyBwZWVyLlxuICAgKi9cbiAgZ2V0IHJhbmRvbVBlZXIoKTogUHJvbWlzZTxQZWVyIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHNlbGVjdFJhbmRvbVBlZXIodGhpcy5wZWVycyk7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gXCIuLi8uLi93YWt1L3YyL21lc3NhZ2VcIjtcblxuZXhwb3J0IGNvbnN0IHByb3RvYnVmUGFja2FnZSA9IFwid2FrdS52MlwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlclJlcXVlc3Qge1xuICBzdWJzY3JpYmU6IGJvb2xlYW47XG4gIHRvcGljOiBzdHJpbmc7XG4gIGNvbnRlbnRGaWx0ZXJzOiBGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXIge1xuICBjb250ZW50VG9waWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlUHVzaCB7XG4gIG1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlclJQQyB7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICByZXF1ZXN0OiBGaWx0ZXJSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICBwdXNoOiBNZXNzYWdlUHVzaCB8IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmFzZUZpbHRlclJlcXVlc3QoKTogRmlsdGVyUmVxdWVzdCB7XG4gIHJldHVybiB7IHN1YnNjcmliZTogZmFsc2UsIHRvcGljOiBcIlwiLCBjb250ZW50RmlsdGVyczogW10gfTtcbn1cblxuZXhwb3J0IGNvbnN0IEZpbHRlclJlcXVlc3QgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBGaWx0ZXJSZXF1ZXN0LFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlID09PSB0cnVlKSB7XG4gICAgICB3cml0ZXIudWludDMyKDgpLmJvb2wobWVzc2FnZS5zdWJzY3JpYmUpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS50b3BpYyAhPT0gXCJcIikge1xuICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudG9waWMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb250ZW50RmlsdGVycykge1xuICAgICAgRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyLmVuY29kZSh2ISwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBGaWx0ZXJSZXF1ZXN0IHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZpbHRlclJlcXVlc3QoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UudG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzLnB1c2goXG4gICAgICAgICAgICBGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IEZpbHRlclJlcXVlc3Qge1xuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpYmU6IGlzU2V0KG9iamVjdC5zdWJzY3JpYmUpID8gQm9vbGVhbihvYmplY3Quc3Vic2NyaWJlKSA6IGZhbHNlLFxuICAgICAgdG9waWM6IGlzU2V0KG9iamVjdC50b3BpYykgPyBTdHJpbmcob2JqZWN0LnRvcGljKSA6IFwiXCIsXG4gICAgICBjb250ZW50RmlsdGVyczogQXJyYXkuaXNBcnJheShvYmplY3Q/LmNvbnRlbnRGaWx0ZXJzKVxuICAgICAgICA/IG9iamVjdC5jb250ZW50RmlsdGVycy5tYXAoKGU6IGFueSkgPT5cbiAgICAgICAgICAgIEZpbHRlclJlcXVlc3RfQ29udGVudEZpbHRlci5mcm9tSlNPTihlKVxuICAgICAgICAgIClcbiAgICAgICAgOiBbXSxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBGaWx0ZXJSZXF1ZXN0KTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLnN1YnNjcmliZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc3Vic2NyaWJlID0gbWVzc2FnZS5zdWJzY3JpYmUpO1xuICAgIG1lc3NhZ2UudG9waWMgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvcGljID0gbWVzc2FnZS50b3BpYyk7XG4gICAgaWYgKG1lc3NhZ2UuY29udGVudEZpbHRlcnMpIHtcbiAgICAgIG9iai5jb250ZW50RmlsdGVycyA9IG1lc3NhZ2UuY29udGVudEZpbHRlcnMubWFwKChlKSA9PlxuICAgICAgICBlID8gRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyLnRvSlNPTihlKSA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmNvbnRlbnRGaWx0ZXJzID0gW107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPEZpbHRlclJlcXVlc3Q+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEZpbHRlclJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRmlsdGVyUmVxdWVzdCgpO1xuICAgIG1lc3NhZ2Uuc3Vic2NyaWJlID0gb2JqZWN0LnN1YnNjcmliZSA/PyBmYWxzZTtcbiAgICBtZXNzYWdlLnRvcGljID0gb2JqZWN0LnRvcGljID8/IFwiXCI7XG4gICAgbWVzc2FnZS5jb250ZW50RmlsdGVycyA9XG4gICAgICBvYmplY3QuY29udGVudEZpbHRlcnM/Lm1hcCgoZSkgPT5cbiAgICAgICAgRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyLmZyb21QYXJ0aWFsKGUpXG4gICAgICApIHx8IFtdO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZUZpbHRlclJlcXVlc3RfQ29udGVudEZpbHRlcigpOiBGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXIge1xuICByZXR1cm4geyBjb250ZW50VG9waWM6IFwiXCIgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEZpbHRlclJlcXVlc3RfQ29udGVudEZpbHRlciA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEZpbHRlclJlcXVlc3RfQ29udGVudEZpbHRlcixcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gXCJcIikge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoXG4gICAgaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LFxuICAgIGxlbmd0aD86IG51bWJlclxuICApOiBGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXIge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA6IFwiXCIsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogRmlsdGVyUmVxdWVzdF9Db250ZW50RmlsdGVyKTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXI+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEZpbHRlclJlcXVlc3RfQ29udGVudEZpbHRlciB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGaWx0ZXJSZXF1ZXN0X0NvbnRlbnRGaWx0ZXIoKTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IG9iamVjdC5jb250ZW50VG9waWMgPz8gXCJcIjtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXNzYWdlUHVzaCgpOiBNZXNzYWdlUHVzaCB7XG4gIHJldHVybiB7IG1lc3NhZ2VzOiBbXSB9O1xufVxuXG5leHBvcnQgY29uc3QgTWVzc2FnZVB1c2ggPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBNZXNzYWdlUHVzaCxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICBXYWt1TWVzc2FnZS5lbmNvZGUodiEsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogTWVzc2FnZVB1c2gge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWVzc2FnZVB1c2goKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZXMucHVzaChXYWt1TWVzc2FnZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogTWVzc2FnZVB1c2gge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlczogQXJyYXkuaXNBcnJheShvYmplY3Q/Lm1lc3NhZ2VzKVxuICAgICAgICA/IG9iamVjdC5tZXNzYWdlcy5tYXAoKGU6IGFueSkgPT4gV2FrdU1lc3NhZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgIDogW10sXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogTWVzc2FnZVB1c2gpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICBvYmoubWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLm1hcCgoZSkgPT5cbiAgICAgICAgZSA/IFdha3VNZXNzYWdlLnRvSlNPTihlKSA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLm1lc3NhZ2VzID0gW107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPE1lc3NhZ2VQdXNoPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBNZXNzYWdlUHVzaCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNZXNzYWdlUHVzaCgpO1xuICAgIG1lc3NhZ2UubWVzc2FnZXMgPVxuICAgICAgb2JqZWN0Lm1lc3NhZ2VzPy5tYXAoKGUpID0+IFdha3VNZXNzYWdlLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGaWx0ZXJSUEMoKTogRmlsdGVyUlBDIHtcbiAgcmV0dXJuIHsgcmVxdWVzdElkOiBcIlwiLCByZXF1ZXN0OiB1bmRlZmluZWQsIHB1c2g6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgY29uc3QgRmlsdGVyUlBDID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogRmlsdGVyUlBDLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdElkICE9PSBcIlwiKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5yZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIEZpbHRlclJlcXVlc3QuZW5jb2RlKG1lc3NhZ2UucmVxdWVzdCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBNZXNzYWdlUHVzaC5lbmNvZGUobWVzc2FnZS5wdXNoLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IEZpbHRlclJQQyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGaWx0ZXJSUEMoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0ID0gRmlsdGVyUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5wdXNoID0gTWVzc2FnZVB1c2guZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogRmlsdGVyUlBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdElkOiBpc1NldChvYmplY3QucmVxdWVzdElkKSA/IFN0cmluZyhvYmplY3QucmVxdWVzdElkKSA6IFwiXCIsXG4gICAgICByZXF1ZXN0OiBpc1NldChvYmplY3QucmVxdWVzdClcbiAgICAgICAgPyBGaWx0ZXJSZXF1ZXN0LmZyb21KU09OKG9iamVjdC5yZXF1ZXN0KVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIHB1c2g6IGlzU2V0KG9iamVjdC5wdXNoKSA/IE1lc3NhZ2VQdXNoLmZyb21KU09OKG9iamVjdC5wdXNoKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBGaWx0ZXJSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVxdWVzdCA9IG1lc3NhZ2UucmVxdWVzdFxuICAgICAgICA/IEZpbHRlclJlcXVlc3QudG9KU09OKG1lc3NhZ2UucmVxdWVzdClcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UucHVzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnB1c2ggPSBtZXNzYWdlLnB1c2ggPyBNZXNzYWdlUHVzaC50b0pTT04obWVzc2FnZS5wdXNoKSA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8RmlsdGVyUlBDPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBGaWx0ZXJSUEMge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRmlsdGVyUlBDKCk7XG4gICAgbWVzc2FnZS5yZXF1ZXN0SWQgPSBvYmplY3QucmVxdWVzdElkID8/IFwiXCI7XG4gICAgbWVzc2FnZS5yZXF1ZXN0ID1cbiAgICAgIG9iamVjdC5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlcXVlc3QgIT09IG51bGxcbiAgICAgICAgPyBGaWx0ZXJSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC5yZXF1ZXN0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLnB1c2ggPVxuICAgICAgb2JqZWN0LnB1c2ggIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHVzaCAhPT0gbnVsbFxuICAgICAgICA/IE1lc3NhZ2VQdXNoLmZyb21QYXJ0aWFsKG9iamVjdC5wdXNoKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIExvbmdcbiAgPyBzdHJpbmcgfCBudW1iZXIgfCBMb25nXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxudHlwZSBLZXlzT2ZVbmlvbjxUPiA9IFQgZXh0ZW5kcyBUID8ga2V5b2YgVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRXhhY3Q8UCwgSSBleHRlbmRzIFA+ID0gUCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBQXG4gIDogUCAmIHsgW0sgaW4ga2V5b2YgUF06IEV4YWN0PFBbS10sIElbS10+IH0gJiBSZWNvcmQ8XG4gICAgICAgIEV4Y2x1ZGU8a2V5b2YgSSwgS2V5c09mVW5pb248UD4+LFxuICAgICAgICBuZXZlclxuICAgICAgPjtcblxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgX20wLnV0aWwuTG9uZyA9IExvbmcgYXMgYW55O1xuICBfbTAuY29uZmlndXJlKCk7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vd2FrdS92Mi9tZXNzYWdlXCI7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcIndha3UudjJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQdXNoUmVxdWVzdCB7XG4gIHB1YlN1YlRvcGljOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IFdha3VNZXNzYWdlIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hSZXNwb25zZSB7XG4gIGlzU3VjY2VzczogYm9vbGVhbjtcbiAgaW5mbzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hSUEMge1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgcmVxdWVzdDogUHVzaFJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIHJlc3BvbnNlOiBQdXNoUmVzcG9uc2UgfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdXNoUmVxdWVzdCgpOiBQdXNoUmVxdWVzdCB7XG4gIHJldHVybiB7IHB1YlN1YlRvcGljOiBcIlwiLCBtZXNzYWdlOiB1bmRlZmluZWQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFB1c2hSZXF1ZXN0ID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUHVzaFJlcXVlc3QsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5wdWJTdWJUb3BpYyAhPT0gXCJcIikge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFdha3VNZXNzYWdlLmVuY29kZShtZXNzYWdlLm1lc3NhZ2UsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogUHVzaFJlcXVlc3Qge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVzaFJlcXVlc3QoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSBXYWt1TWVzc2FnZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQdXNoUmVxdWVzdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YlN1YlRvcGljOiBpc1NldChvYmplY3QucHViU3ViVG9waWMpID8gU3RyaW5nKG9iamVjdC5wdWJTdWJUb3BpYykgOiBcIlwiLFxuICAgICAgbWVzc2FnZTogaXNTZXQob2JqZWN0Lm1lc3NhZ2UpXG4gICAgICAgID8gV2FrdU1lc3NhZ2UuZnJvbUpTT04ob2JqZWN0Lm1lc3NhZ2UpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IFB1c2hSZXF1ZXN0KTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucHViU3ViVG9waWMgPSBtZXNzYWdlLnB1YlN1YlRvcGljKTtcbiAgICBtZXNzYWdlLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5tZXNzYWdlID0gbWVzc2FnZS5tZXNzYWdlXG4gICAgICAgID8gV2FrdU1lc3NhZ2UudG9KU09OKG1lc3NhZ2UubWVzc2FnZSlcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPFB1c2hSZXF1ZXN0PiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBQdXNoUmVxdWVzdCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdXNoUmVxdWVzdCgpO1xuICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSBvYmplY3QucHViU3ViVG9waWMgPz8gXCJcIjtcbiAgICBtZXNzYWdlLm1lc3NhZ2UgPVxuICAgICAgb2JqZWN0Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWVzc2FnZSAhPT0gbnVsbFxuICAgICAgICA/IFdha3VNZXNzYWdlLmZyb21QYXJ0aWFsKG9iamVjdC5tZXNzYWdlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdXNoUmVzcG9uc2UoKTogUHVzaFJlc3BvbnNlIHtcbiAgcmV0dXJuIHsgaXNTdWNjZXNzOiBmYWxzZSwgaW5mbzogXCJcIiB9O1xufVxuXG5leHBvcnQgY29uc3QgUHVzaFJlc3BvbnNlID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUHVzaFJlc3BvbnNlLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UuaXNTdWNjZXNzID09PSB0cnVlKSB7XG4gICAgICB3cml0ZXIudWludDMyKDgpLmJvb2wobWVzc2FnZS5pc1N1Y2Nlc3MpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5pbmZvICE9PSBcIlwiKSB7XG4gICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5pbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBQdXNoUmVzcG9uc2Uge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVzaFJlc3BvbnNlKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLmlzU3VjY2VzcyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLmluZm8gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IFB1c2hSZXNwb25zZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU3VjY2VzczogaXNTZXQob2JqZWN0LmlzU3VjY2VzcykgPyBCb29sZWFuKG9iamVjdC5pc1N1Y2Nlc3MpIDogZmFsc2UsXG4gICAgICBpbmZvOiBpc1NldChvYmplY3QuaW5mbykgPyBTdHJpbmcob2JqZWN0LmluZm8pIDogXCJcIixcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBQdXNoUmVzcG9uc2UpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UuaXNTdWNjZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai5pc1N1Y2Nlc3MgPSBtZXNzYWdlLmlzU3VjY2Vzcyk7XG4gICAgbWVzc2FnZS5pbmZvICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbmZvID0gbWVzc2FnZS5pbmZvKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxQdXNoUmVzcG9uc2U+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IFB1c2hSZXNwb25zZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdXNoUmVzcG9uc2UoKTtcbiAgICBtZXNzYWdlLmlzU3VjY2VzcyA9IG9iamVjdC5pc1N1Y2Nlc3MgPz8gZmFsc2U7XG4gICAgbWVzc2FnZS5pbmZvID0gb2JqZWN0LmluZm8gPz8gXCJcIjtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdXNoUlBDKCk6IFB1c2hSUEMge1xuICByZXR1cm4geyByZXF1ZXN0SWQ6IFwiXCIsIHJlcXVlc3Q6IHVuZGVmaW5lZCwgcmVzcG9uc2U6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgY29uc3QgUHVzaFJQQyA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IFB1c2hSUEMsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5yZXF1ZXN0SWQgIT09IFwiXCIpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUHVzaFJlcXVlc3QuZW5jb2RlKG1lc3NhZ2UucmVxdWVzdCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUHVzaFJlc3BvbnNlLmVuY29kZShtZXNzYWdlLnJlc3BvbnNlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IFB1c2hSUEMge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVzaFJQQygpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnJlcXVlc3QgPSBQdXNoUmVxdWVzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5yZXNwb25zZSA9IFB1c2hSZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQdXNoUlBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdElkOiBpc1NldChvYmplY3QucmVxdWVzdElkKSA/IFN0cmluZyhvYmplY3QucmVxdWVzdElkKSA6IFwiXCIsXG4gICAgICByZXF1ZXN0OiBpc1NldChvYmplY3QucmVxdWVzdClcbiAgICAgICAgPyBQdXNoUmVxdWVzdC5mcm9tSlNPTihvYmplY3QucmVxdWVzdClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZTogaXNTZXQob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA/IFB1c2hSZXNwb25zZS5mcm9tSlNPTihvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IFB1c2hSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVxdWVzdCA9IG1lc3NhZ2UucmVxdWVzdFxuICAgICAgICA/IFB1c2hSZXF1ZXN0LnRvSlNPTihtZXNzYWdlLnJlcXVlc3QpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBtZXNzYWdlLnJlc3BvbnNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlXG4gICAgICAgID8gUHVzaFJlc3BvbnNlLnRvSlNPTihtZXNzYWdlLnJlc3BvbnNlKVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8UHVzaFJQQz4sIEk+PihvYmplY3Q6IEkpOiBQdXNoUlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1c2hSUEMoKTtcbiAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQgPz8gXCJcIjtcbiAgICBtZXNzYWdlLnJlcXVlc3QgPVxuICAgICAgb2JqZWN0LnJlcXVlc3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVxdWVzdCAhPT0gbnVsbFxuICAgICAgICA/IFB1c2hSZXF1ZXN0LmZyb21QYXJ0aWFsKG9iamVjdC5yZXF1ZXN0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLnJlc3BvbnNlID1cbiAgICAgIG9iamVjdC5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXNwb25zZSAhPT0gbnVsbFxuICAgICAgICA/IFB1c2hSZXNwb25zZS5mcm9tUGFydGlhbChvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxudHlwZSBCdWlsdGluID1cbiAgfCBEYXRlXG4gIHwgRnVuY3Rpb25cbiAgfCBVaW50OEFycmF5XG4gIHwgc3RyaW5nXG4gIHwgbnVtYmVyXG4gIHwgYm9vbGVhblxuICB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IHR5cGUgRGVlcFBhcnRpYWw8VD4gPSBUIGV4dGVuZHMgQnVpbHRpblxuICA/IFRcbiAgOiBUIGV4dGVuZHMgTG9uZ1xuICA/IHN0cmluZyB8IG51bWJlciB8IExvbmdcbiAgOiBUIGV4dGVuZHMgQXJyYXk8aW5mZXIgVT5cbiAgPyBBcnJheTxEZWVwUGFydGlhbDxVPj5cbiAgOiBUIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxpbmZlciBVPlxuICA/IFJlYWRvbmx5QXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIHt9XG4gID8geyBbSyBpbiBrZXlvZiBUXT86IERlZXBQYXJ0aWFsPFRbS10+IH1cbiAgOiBQYXJ0aWFsPFQ+O1xuXG50eXBlIEtleXNPZlVuaW9uPFQ+ID0gVCBleHRlbmRzIFQgPyBrZXlvZiBUIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBFeGFjdDxQLCBJIGV4dGVuZHMgUD4gPSBQIGV4dGVuZHMgQnVpbHRpblxuICA/IFBcbiAgOiBQICYgeyBbSyBpbiBrZXlvZiBQXTogRXhhY3Q8UFtLXSwgSVtLXT4gfSAmIFJlY29yZDxcbiAgICAgICAgRXhjbHVkZTxrZXlvZiBJLCBLZXlzT2ZVbmlvbjxQPj4sXG4gICAgICAgIG5ldmVyXG4gICAgICA+O1xuXG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICBfbTAudXRpbC5Mb25nID0gTG9uZyBhcyBhbnk7XG4gIF9tMC5jb25maWd1cmUoKTtcbn1cblxuZnVuY3Rpb24gaXNTZXQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgTG9uZyBmcm9tIFwibG9uZ1wiO1xuaW1wb3J0IF9tMCBmcm9tIFwicHJvdG9idWZqcy9taW5pbWFsXCI7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcIndha3UudjJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXYWt1TWVzc2FnZSB7XG4gIHBheWxvYWQ/OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkO1xuICBjb250ZW50VG9waWM/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHZlcnNpb24/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHRpbWVzdGFtcERlcHJlY2F0ZWQ/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHRpbWVzdGFtcD86IExvbmcgfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VXYWt1TWVzc2FnZSgpOiBXYWt1TWVzc2FnZSB7XG4gIHJldHVybiB7XG4gICAgcGF5bG9hZDogdW5kZWZpbmVkLFxuICAgIGNvbnRlbnRUb3BpYzogdW5kZWZpbmVkLFxuICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICB0aW1lc3RhbXBEZXByZWNhdGVkOiB1bmRlZmluZWQsXG4gICAgdGltZXN0YW1wOiB1bmRlZmluZWQsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBXYWt1TWVzc2FnZSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IFdha3VNZXNzYWdlLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDI0KS51aW50MzIobWVzc2FnZS52ZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wRGVwcmVjYXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDMzKS5kb3VibGUobWVzc2FnZS50aW1lc3RhbXBEZXByZWNhdGVkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoODApLnNpbnQ2NChtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogV2FrdU1lc3NhZ2Uge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV2FrdU1lc3NhZ2UoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcERlcHJlY2F0ZWQgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSByZWFkZXIuc2ludDY0KCkgYXMgTG9uZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogV2FrdU1lc3NhZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIHZlcnNpb246IGlzU2V0KG9iamVjdC52ZXJzaW9uKSA/IE51bWJlcihvYmplY3QudmVyc2lvbikgOiB1bmRlZmluZWQsXG4gICAgICB0aW1lc3RhbXBEZXByZWNhdGVkOiBpc1NldChvYmplY3QudGltZXN0YW1wRGVwcmVjYXRlZClcbiAgICAgICAgPyBOdW1iZXIob2JqZWN0LnRpbWVzdGFtcERlcHJlY2F0ZWQpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgdGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICA/IExvbmcuZnJvbVN0cmluZyhvYmplY3QudGltZXN0YW1wKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBXYWt1TWVzc2FnZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGF5bG9hZCA9XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkKVxuICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICBtZXNzYWdlLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai52ZXJzaW9uID0gTWF0aC5yb3VuZChtZXNzYWdlLnZlcnNpb24pKTtcbiAgICBtZXNzYWdlLnRpbWVzdGFtcERlcHJlY2F0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai50aW1lc3RhbXBEZXByZWNhdGVkID0gbWVzc2FnZS50aW1lc3RhbXBEZXByZWNhdGVkKTtcbiAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnRpbWVzdGFtcCA9IChtZXNzYWdlLnRpbWVzdGFtcCB8fCB1bmRlZmluZWQpLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPFdha3VNZXNzYWdlPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBXYWt1TWVzc2FnZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXYWt1TWVzc2FnZSgpO1xuICAgIG1lc3NhZ2UucGF5bG9hZCA9IG9iamVjdC5wYXlsb2FkID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IG9iamVjdC5jb250ZW50VG9waWMgPz8gdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2UudmVyc2lvbiA9IG9iamVjdC52ZXJzaW9uID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLnRpbWVzdGFtcERlcHJlY2F0ZWQgPSBvYmplY3QudGltZXN0YW1wRGVwcmVjYXRlZCA/PyB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS50aW1lc3RhbXAgPVxuICAgICAgb2JqZWN0LnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50aW1lc3RhbXAgIT09IG51bGxcbiAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmRlY2xhcmUgdmFyIHNlbGY6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIHdpbmRvdzogYW55IHwgdW5kZWZpbmVkO1xuZGVjbGFyZSB2YXIgZ2xvYmFsOiBhbnkgfCB1bmRlZmluZWQ7XG52YXIgZ2xvYmFsVGhpczogYW55ID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsO1xuICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcblxuY29uc3QgYXRvYjogKGI2NDogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYmluID0gYXRvYihiNjQpO1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5jb25zdCBidG9hOiAoYmluOiBzdHJpbmcpID0+IHN0cmluZyA9XG4gIGdsb2JhbFRoaXMuYnRvYSB8fFxuICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBjb25zdCBiaW46IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBhcnIpIHtcbiAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIExvbmdcbiAgPyBzdHJpbmcgfCBudW1iZXIgfCBMb25nXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxudHlwZSBLZXlzT2ZVbmlvbjxUPiA9IFQgZXh0ZW5kcyBUID8ga2V5b2YgVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRXhhY3Q8UCwgSSBleHRlbmRzIFA+ID0gUCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBQXG4gIDogUCAmIHsgW0sgaW4ga2V5b2YgUF06IEV4YWN0PFBbS10sIElbS10+IH0gJiBSZWNvcmQ8XG4gICAgICAgIEV4Y2x1ZGU8a2V5b2YgSSwgS2V5c09mVW5pb248UD4+LFxuICAgICAgICBuZXZlclxuICAgICAgPjtcblxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgX20wLnV0aWwuTG9uZyA9IExvbmcgYXMgYW55O1xuICBfbTAuY29uZmlndXJlKCk7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbmltcG9ydCBfbTAgZnJvbSBcInByb3RvYnVmanMvbWluaW1hbFwiO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vd2FrdS92Mi9tZXNzYWdlXCI7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSBcIndha3UudjIuc3RvcmUudjJiZXRhM1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4IHtcbiAgZGlnZXN0OiBVaW50OEFycmF5O1xuICByZWNlaXZlZFRpbWU6IG51bWJlcjtcbiAgc2VuZGVyVGltZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luZ0luZm8ge1xuICBwYWdlU2l6ZTogTG9uZztcbiAgY3Vyc29yOiBJbmRleCB8IHVuZGVmaW5lZDtcbiAgZGlyZWN0aW9uOiBQYWdpbmdJbmZvX0RpcmVjdGlvbjtcbn1cblxuZXhwb3J0IGVudW0gUGFnaW5nSW5mb19EaXJlY3Rpb24ge1xuICBESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQgPSAwLFxuICBESVJFQ1RJT05fRk9SV0FSRCA9IDEsXG4gIFVOUkVDT0dOSVpFRCA9IC0xLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFnaW5nSW5mb19EaXJlY3Rpb25Gcm9tSlNPTihcbiAgb2JqZWN0OiBhbnlcbik6IFBhZ2luZ0luZm9fRGlyZWN0aW9uIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSBcIkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRFwiOlxuICAgICAgcmV0dXJuIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRDtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSBcIkRJUkVDVElPTl9GT1JXQVJEXCI6XG4gICAgICByZXR1cm4gUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgY2FzZSAtMTpcbiAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQYWdpbmdJbmZvX0RpcmVjdGlvbi5VTlJFQ09HTklaRUQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2luZ0luZm9fRGlyZWN0aW9uVG9KU09OKFxuICBvYmplY3Q6IFBhZ2luZ0luZm9fRGlyZWN0aW9uXG4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKG9iamVjdCkge1xuICAgIGNhc2UgUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEOlxuICAgICAgcmV0dXJuIFwiRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEXCI7XG4gICAgY2FzZSBQYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fRk9SV0FSRDpcbiAgICAgIHJldHVybiBcIkRJUkVDVElPTl9GT1JXQVJEXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRGaWx0ZXIge1xuICBjb250ZW50VG9waWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UXVlcnkge1xuICBwdWJTdWJUb3BpYz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY29udGVudEZpbHRlcnM6IENvbnRlbnRGaWx0ZXJbXTtcbiAgcGFnaW5nSW5mbz86IFBhZ2luZ0luZm8gfCB1bmRlZmluZWQ7XG4gIHN0YXJ0VGltZT86IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgZW5kVGltZT86IG51bWJlciB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UmVzcG9uc2Uge1xuICBtZXNzYWdlczogV2FrdU1lc3NhZ2VbXTtcbiAgcGFnaW5nSW5mbzogUGFnaW5nSW5mbyB8IHVuZGVmaW5lZDtcbiAgZXJyb3I6IEhpc3RvcnlSZXNwb25zZV9FcnJvcjtcbn1cblxuZXhwb3J0IGVudW0gSGlzdG9yeVJlc3BvbnNlX0Vycm9yIHtcbiAgRVJST1JfTk9ORV9VTlNQRUNJRklFRCA9IDAsXG4gIEVSUk9SX0lOVkFMSURfQ1VSU09SID0gMSxcbiAgVU5SRUNPR05JWkVEID0gLTEsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaXN0b3J5UmVzcG9uc2VfRXJyb3JGcm9tSlNPTihcbiAgb2JqZWN0OiBhbnlcbik6IEhpc3RvcnlSZXNwb25zZV9FcnJvciB7XG4gIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgXCJFUlJPUl9OT05FX1VOU1BFQ0lGSUVEXCI6XG4gICAgICByZXR1cm4gSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX05PTkVfVU5TUEVDSUZJRUQ7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgXCJFUlJPUl9JTlZBTElEX0NVUlNPUlwiOlxuICAgICAgcmV0dXJuIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9JTlZBTElEX0NVUlNPUjtcbiAgICBjYXNlIC0xOlxuICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhpc3RvcnlSZXNwb25zZV9FcnJvci5VTlJFQ09HTklaRUQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpc3RvcnlSZXNwb25zZV9FcnJvclRvSlNPTihcbiAgb2JqZWN0OiBIaXN0b3J5UmVzcG9uc2VfRXJyb3Jcbik6IHN0cmluZyB7XG4gIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgY2FzZSBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfTk9ORV9VTlNQRUNJRklFRDpcbiAgICAgIHJldHVybiBcIkVSUk9SX05PTkVfVU5TUEVDSUZJRURcIjtcbiAgICBjYXNlIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9JTlZBTElEX0NVUlNPUjpcbiAgICAgIHJldHVybiBcIkVSUk9SX0lOVkFMSURfQ1VSU09SXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSUEMge1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgcXVlcnk6IEhpc3RvcnlRdWVyeSB8IHVuZGVmaW5lZDtcbiAgcmVzcG9uc2U6IEhpc3RvcnlSZXNwb25zZSB8IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmFzZUluZGV4KCk6IEluZGV4IHtcbiAgcmV0dXJuIHsgZGlnZXN0OiBuZXcgVWludDhBcnJheSgpLCByZWNlaXZlZFRpbWU6IDAsIHNlbmRlclRpbWU6IDAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEluZGV4ID0ge1xuICBlbmNvZGUobWVzc2FnZTogSW5kZXgsIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5kaWdlc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmRpZ2VzdCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnJlY2VpdmVkVGltZSAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxNykuZG91YmxlKG1lc3NhZ2UucmVjZWl2ZWRUaW1lKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc2VuZGVyVGltZSAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigyNSkuZG91YmxlKG1lc3NhZ2Uuc2VuZGVyVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSW5kZXgge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5kZXgoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSW5kZXgge1xuICAgIHJldHVybiB7XG4gICAgICBkaWdlc3Q6IGlzU2V0KG9iamVjdC5kaWdlc3QpXG4gICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kaWdlc3QpXG4gICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgIHJlY2VpdmVkVGltZTogaXNTZXQob2JqZWN0LnJlY2VpdmVkVGltZSlcbiAgICAgICAgPyBOdW1iZXIob2JqZWN0LnJlY2VpdmVkVGltZSlcbiAgICAgICAgOiAwLFxuICAgICAgc2VuZGVyVGltZTogaXNTZXQob2JqZWN0LnNlbmRlclRpbWUpID8gTnVtYmVyKG9iamVjdC5zZW5kZXJUaW1lKSA6IDAsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogSW5kZXgpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZGlnZXN0ID0gYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBtZXNzYWdlLmRpZ2VzdCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kaWdlc3QgOiBuZXcgVWludDhBcnJheSgpXG4gICAgICApKTtcbiAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnJlY2VpdmVkVGltZSA9IG1lc3NhZ2UucmVjZWl2ZWRUaW1lKTtcbiAgICBtZXNzYWdlLnNlbmRlclRpbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlbmRlclRpbWUgPSBtZXNzYWdlLnNlbmRlclRpbWUpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPEluZGV4PiwgST4+KG9iamVjdDogSSk6IEluZGV4IHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUluZGV4KCk7XG4gICAgbWVzc2FnZS5kaWdlc3QgPSBvYmplY3QuZGlnZXN0ID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgbWVzc2FnZS5yZWNlaXZlZFRpbWUgPSBvYmplY3QucmVjZWl2ZWRUaW1lID8/IDA7XG4gICAgbWVzc2FnZS5zZW5kZXJUaW1lID0gb2JqZWN0LnNlbmRlclRpbWUgPz8gMDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQYWdpbmdJbmZvKCk6IFBhZ2luZ0luZm8ge1xuICByZXR1cm4geyBwYWdlU2l6ZTogTG9uZy5VWkVSTywgY3Vyc29yOiB1bmRlZmluZWQsIGRpcmVjdGlvbjogMCB9O1xufVxuXG5leHBvcnQgY29uc3QgUGFnaW5nSW5mbyA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IFBhZ2luZ0luZm8sXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAoIW1lc3NhZ2UucGFnZVNpemUuaXNaZXJvKCkpIHtcbiAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UucGFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5jdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSW5kZXguZW5jb2RlKG1lc3NhZ2UuY3Vyc29yLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5kaXJlY3Rpb24gIT09IDApIHtcbiAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDMyKG1lc3NhZ2UuZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhZ2luZ0luZm8oKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucGFnZVNpemUgPSByZWFkZXIudWludDY0KCkgYXMgTG9uZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UuY3Vyc29yID0gSW5kZXguZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UuZGlyZWN0aW9uID0gcmVhZGVyLmludDMyKCkgYXMgYW55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQYWdpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVNpemU6IGlzU2V0KG9iamVjdC5wYWdlU2l6ZSlcbiAgICAgICAgPyBMb25nLmZyb21TdHJpbmcob2JqZWN0LnBhZ2VTaXplKVxuICAgICAgICA6IExvbmcuVVpFUk8sXG4gICAgICBjdXJzb3I6IGlzU2V0KG9iamVjdC5jdXJzb3IpID8gSW5kZXguZnJvbUpTT04ob2JqZWN0LmN1cnNvcikgOiB1bmRlZmluZWQsXG4gICAgICBkaXJlY3Rpb246IGlzU2V0KG9iamVjdC5kaXJlY3Rpb24pXG4gICAgICAgID8gcGFnaW5nSW5mb19EaXJlY3Rpb25Gcm9tSlNPTihvYmplY3QuZGlyZWN0aW9uKVxuICAgICAgICA6IDAsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogUGFnaW5nSW5mbyk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnBhZ2VTaXplID0gKG1lc3NhZ2UucGFnZVNpemUgfHwgTG9uZy5VWkVSTykudG9TdHJpbmcoKSk7XG4gICAgbWVzc2FnZS5jdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5jdXJzb3IgPSBtZXNzYWdlLmN1cnNvciA/IEluZGV4LnRvSlNPTihtZXNzYWdlLmN1cnNvcikgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZGlyZWN0aW9uID0gcGFnaW5nSW5mb19EaXJlY3Rpb25Ub0pTT04obWVzc2FnZS5kaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxQYWdpbmdJbmZvPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhZ2luZ0luZm8oKTtcbiAgICBtZXNzYWdlLnBhZ2VTaXplID1cbiAgICAgIG9iamVjdC5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdlU2l6ZSAhPT0gbnVsbFxuICAgICAgICA/IExvbmcuZnJvbVZhbHVlKG9iamVjdC5wYWdlU2l6ZSlcbiAgICAgICAgOiBMb25nLlVaRVJPO1xuICAgIG1lc3NhZ2UuY3Vyc29yID1cbiAgICAgIG9iamVjdC5jdXJzb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3Vyc29yICE9PSBudWxsXG4gICAgICAgID8gSW5kZXguZnJvbVBhcnRpYWwob2JqZWN0LmN1cnNvcilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5kaXJlY3Rpb24gPSBvYmplY3QuZGlyZWN0aW9uID8/IDA7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29udGVudEZpbHRlcigpOiBDb250ZW50RmlsdGVyIHtcbiAgcmV0dXJuIHsgY29udGVudFRvcGljOiBcIlwiIH07XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZW50RmlsdGVyID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogQ29udGVudEZpbHRlcixcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gXCJcIikge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBDb250ZW50RmlsdGVyIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRlbnRGaWx0ZXIoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBDb250ZW50RmlsdGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudFRvcGljOiBpc1NldChvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA/IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKVxuICAgICAgICA6IFwiXCIsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogQ29udGVudEZpbHRlcik6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8Q29udGVudEZpbHRlcj4sIEk+PihcbiAgICBvYmplY3Q6IElcbiAgKTogQ29udGVudEZpbHRlciB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250ZW50RmlsdGVyKCk7XG4gICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSBvYmplY3QuY29udGVudFRvcGljID8/IFwiXCI7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSGlzdG9yeVF1ZXJ5KCk6IEhpc3RvcnlRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgcHViU3ViVG9waWM6IHVuZGVmaW5lZCxcbiAgICBjb250ZW50RmlsdGVyczogW10sXG4gICAgcGFnaW5nSW5mbzogdW5kZWZpbmVkLFxuICAgIHN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgIGVuZFRpbWU6IHVuZGVmaW5lZCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlRdWVyeSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlRdWVyeSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnB1YlN1YlRvcGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnB1YlN1YlRvcGljKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuY29udGVudEZpbHRlcnMpIHtcbiAgICAgIENvbnRlbnRGaWx0ZXIuZW5jb2RlKHYhLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFBhZ2luZ0luZm8uZW5jb2RlKG1lc3NhZ2UucGFnaW5nSW5mbywgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoNDEpLmRvdWJsZShtZXNzYWdlLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMig0OSkuZG91YmxlKG1lc3NhZ2UuZW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVF1ZXJ5IHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlRdWVyeSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5wdWJTdWJUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UuY29udGVudEZpbHRlcnMucHVzaChcbiAgICAgICAgICAgIENvbnRlbnRGaWx0ZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0VGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG1lc3NhZ2UuZW5kVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcHViU3ViVG9waWM6IGlzU2V0KG9iamVjdC5wdWJTdWJUb3BpYylcbiAgICAgICAgPyBTdHJpbmcob2JqZWN0LnB1YlN1YlRvcGljKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbnRlbnRGaWx0ZXJzOiBBcnJheS5pc0FycmF5KG9iamVjdD8uY29udGVudEZpbHRlcnMpXG4gICAgICAgID8gb2JqZWN0LmNvbnRlbnRGaWx0ZXJzLm1hcCgoZTogYW55KSA9PiBDb250ZW50RmlsdGVyLmZyb21KU09OKGUpKVxuICAgICAgICA6IFtdLFxuICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBzdGFydFRpbWU6IGlzU2V0KG9iamVjdC5zdGFydFRpbWUpID8gTnVtYmVyKG9iamVjdC5zdGFydFRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgZW5kVGltZTogaXNTZXQob2JqZWN0LmVuZFRpbWUpID8gTnVtYmVyKG9iamVjdC5lbmRUaW1lKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBIaXN0b3J5UXVlcnkpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5wdWJTdWJUb3BpYyA9IG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzKSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzLm1hcCgoZSkgPT5cbiAgICAgICAgZSA/IENvbnRlbnRGaWx0ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5zdGFydFRpbWUgPSBtZXNzYWdlLnN0YXJ0VGltZSk7XG4gICAgbWVzc2FnZS5lbmRUaW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5lbmRUaW1lID0gbWVzc2FnZS5lbmRUaW1lKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UXVlcnk+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEhpc3RvcnlRdWVyeSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UXVlcnkoKTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gb2JqZWN0LnB1YlN1YlRvcGljID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzID1cbiAgICAgIG9iamVjdC5jb250ZW50RmlsdGVycz8ubWFwKChlKSA9PiBDb250ZW50RmlsdGVyLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPVxuICAgICAgb2JqZWN0LnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFnaW5nSW5mbyAhPT0gbnVsbFxuICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID0gb2JqZWN0LnN0YXJ0VGltZSA/PyB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5lbmRUaW1lID0gb2JqZWN0LmVuZFRpbWUgPz8gdW5kZWZpbmVkO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZUhpc3RvcnlSZXNwb25zZSgpOiBIaXN0b3J5UmVzcG9uc2Uge1xuICByZXR1cm4geyBtZXNzYWdlczogW10sIHBhZ2luZ0luZm86IHVuZGVmaW5lZCwgZXJyb3I6IDAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlSZXNwb25zZSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlSZXNwb25zZSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICBXYWt1TWVzc2FnZS5lbmNvZGUodiEsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgUGFnaW5nSW5mby5lbmNvZGUobWVzc2FnZS5wYWdpbmdJbmZvLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigzMikuaW50MzIobWVzc2FnZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVJlc3BvbnNlIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlSZXNwb25zZSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKFdha3VNZXNzYWdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID0gUGFnaW5nSW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IHJlYWRlci5pbnQzMigpIGFzIGFueTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVJlc3BvbnNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0Py5tZXNzYWdlcylcbiAgICAgICAgPyBvYmplY3QubWVzc2FnZXMubWFwKChlOiBhbnkpID0+IFdha3VNZXNzYWdlLmZyb21KU09OKGUpKVxuICAgICAgICA6IFtdLFxuICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICA/IGhpc3RvcnlSZXNwb25zZV9FcnJvckZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgOiAwLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSZXNwb25zZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PlxuICAgICAgICBlID8gV2FrdU1lc3NhZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmoubWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5lcnJvciA9IGhpc3RvcnlSZXNwb25zZV9FcnJvclRvSlNPTihtZXNzYWdlLmVycm9yKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8SGlzdG9yeVJlc3BvbnNlPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVJlc3BvbnNlKCk7XG4gICAgbWVzc2FnZS5tZXNzYWdlcyA9XG4gICAgICBvYmplY3QubWVzc2FnZXM/Lm1hcCgoZSkgPT4gV2FrdU1lc3NhZ2UuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9XG4gICAgICBvYmplY3QucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdpbmdJbmZvICE9PSBudWxsXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tUGFydGlhbChvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5lcnJvciA9IG9iamVjdC5lcnJvciA/PyAwO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZUhpc3RvcnlSUEMoKTogSGlzdG9yeVJQQyB7XG4gIHJldHVybiB7IHJlcXVlc3RJZDogXCJcIiwgcXVlcnk6IHVuZGVmaW5lZCwgcmVzcG9uc2U6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgY29uc3QgSGlzdG9yeVJQQyA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlSUEMsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5yZXF1ZXN0SWQgIT09IFwiXCIpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIEhpc3RvcnlRdWVyeS5lbmNvZGUobWVzc2FnZS5xdWVyeSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSGlzdG9yeVJlc3BvbnNlLmVuY29kZShcbiAgICAgICAgbWVzc2FnZS5yZXNwb25zZSxcbiAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpXG4gICAgICApLmxkZWxpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IEhpc3RvcnlSUEMge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVJQQygpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnF1ZXJ5ID0gSGlzdG9yeVF1ZXJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlID0gSGlzdG9yeVJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IEhpc3RvcnlSUEMge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1ZXN0SWQ6IGlzU2V0KG9iamVjdC5yZXF1ZXN0SWQpID8gU3RyaW5nKG9iamVjdC5yZXF1ZXN0SWQpIDogXCJcIixcbiAgICAgIHF1ZXJ5OiBpc1NldChvYmplY3QucXVlcnkpXG4gICAgICAgID8gSGlzdG9yeVF1ZXJ5LmZyb21KU09OKG9iamVjdC5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZTogaXNTZXQob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA/IEhpc3RvcnlSZXNwb25zZS5mcm9tSlNPTihvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5xdWVyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnF1ZXJ5ID0gbWVzc2FnZS5xdWVyeVxuICAgICAgICA/IEhpc3RvcnlRdWVyeS50b0pTT04obWVzc2FnZS5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5yZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2VcbiAgICAgICAgPyBIaXN0b3J5UmVzcG9uc2UudG9KU09OKG1lc3NhZ2UucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UlBDPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBIaXN0b3J5UlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlSUEMoKTtcbiAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQgPz8gXCJcIjtcbiAgICBtZXNzYWdlLnF1ZXJ5ID1cbiAgICAgIG9iamVjdC5xdWVyeSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5xdWVyeSAhPT0gbnVsbFxuICAgICAgICA/IEhpc3RvcnlRdWVyeS5mcm9tUGFydGlhbChvYmplY3QucXVlcnkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2UucmVzcG9uc2UgPVxuICAgICAgb2JqZWN0LnJlc3BvbnNlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlc3BvbnNlICE9PSBudWxsXG4gICAgICAgID8gSGlzdG9yeVJlc3BvbnNlLmZyb21QYXJ0aWFsKG9iamVjdC5yZXNwb25zZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5kZWNsYXJlIHZhciBzZWxmOiBhbnkgfCB1bmRlZmluZWQ7XG5kZWNsYXJlIHZhciB3aW5kb3c6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIGdsb2JhbDogYW55IHwgdW5kZWZpbmVkO1xudmFyIGdsb2JhbFRoaXM6IGFueSA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHNlbGY7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93O1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGdsb2JhbDtcbiAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5cbmNvbnN0IGF0b2I6IChiNjQ6IHN0cmluZykgPT4gc3RyaW5nID1cbiAgZ2xvYmFsVGhpcy5hdG9iIHx8XG4gICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuY29uc3QgYnRvYTogKGJpbjogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgYmluOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuXG50eXBlIEJ1aWx0aW4gPVxuICB8IERhdGVcbiAgfCBGdW5jdGlvblxuICB8IFVpbnQ4QXJyYXlcbiAgfCBzdHJpbmdcbiAgfCBudW1iZXJcbiAgfCBib29sZWFuXG4gIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgdHlwZSBEZWVwUGFydGlhbDxUPiA9IFQgZXh0ZW5kcyBCdWlsdGluXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBMb25nXG4gID8gc3RyaW5nIHwgbnVtYmVyIHwgTG9uZ1xuICA6IFQgZXh0ZW5kcyBBcnJheTxpbmZlciBVPlxuICA/IEFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyBSZWFkb25seUFycmF5PGluZmVyIFU+XG4gID8gUmVhZG9ubHlBcnJheTxEZWVwUGFydGlhbDxVPj5cbiAgOiBUIGV4dGVuZHMge31cbiAgPyB7IFtLIGluIGtleW9mIFRdPzogRGVlcFBhcnRpYWw8VFtLXT4gfVxuICA6IFBhcnRpYWw8VD47XG5cbnR5cGUgS2V5c09mVW5pb248VD4gPSBUIGV4dGVuZHMgVCA/IGtleW9mIFQgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIEV4YWN0PFAsIEkgZXh0ZW5kcyBQPiA9IFAgZXh0ZW5kcyBCdWlsdGluXG4gID8gUFxuICA6IFAgJiB7IFtLIGluIGtleW9mIFBdOiBFeGFjdDxQW0tdLCBJW0tdPiB9ICYgUmVjb3JkPFxuICAgICAgICBFeGNsdWRlPGtleW9mIEksIEtleXNPZlVuaW9uPFA+PixcbiAgICAgICAgbmV2ZXJcbiAgICAgID47XG5cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gIF9tMC51dGlsLkxvbmcgPSBMb25nIGFzIGFueTtcbiAgX20wLmNvbmZpZ3VyZSgpO1xufVxuXG5mdW5jdGlvbiBpc1NldCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gXCJsb25nXCI7XG5pbXBvcnQgX20wIGZyb20gXCJwcm90b2J1ZmpzL21pbmltYWxcIjtcbmltcG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3dha3UvdjIvbWVzc2FnZVwiO1xuXG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gXCJ3YWt1LnYyLnN0b3JlLnYyYmV0YTRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJbmRleCB7XG4gIGRpZ2VzdDogVWludDhBcnJheTtcbiAgcmVjZWl2ZWRUaW1lOiBMb25nO1xuICBzZW5kZXJUaW1lOiBMb25nO1xuICBwdWJzdWJUb3BpYzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luZ0luZm8ge1xuICBwYWdlU2l6ZTogTG9uZztcbiAgY3Vyc29yOiBJbmRleCB8IHVuZGVmaW5lZDtcbiAgZGlyZWN0aW9uOiBQYWdpbmdJbmZvX0RpcmVjdGlvbjtcbn1cblxuZXhwb3J0IGVudW0gUGFnaW5nSW5mb19EaXJlY3Rpb24ge1xuICBESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQgPSAwLFxuICBESVJFQ1RJT05fRk9SV0FSRCA9IDEsXG4gIFVOUkVDT0dOSVpFRCA9IC0xLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFnaW5nSW5mb19EaXJlY3Rpb25Gcm9tSlNPTihcbiAgb2JqZWN0OiBhbnlcbik6IFBhZ2luZ0luZm9fRGlyZWN0aW9uIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSBcIkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRFwiOlxuICAgICAgcmV0dXJuIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRDtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSBcIkRJUkVDVElPTl9GT1JXQVJEXCI6XG4gICAgICByZXR1cm4gUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgY2FzZSAtMTpcbiAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQYWdpbmdJbmZvX0RpcmVjdGlvbi5VTlJFQ09HTklaRUQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2luZ0luZm9fRGlyZWN0aW9uVG9KU09OKFxuICBvYmplY3Q6IFBhZ2luZ0luZm9fRGlyZWN0aW9uXG4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKG9iamVjdCkge1xuICAgIGNhc2UgUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEOlxuICAgICAgcmV0dXJuIFwiRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEXCI7XG4gICAgY2FzZSBQYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fRk9SV0FSRDpcbiAgICAgIHJldHVybiBcIkRJUkVDVElPTl9GT1JXQVJEXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRGaWx0ZXIge1xuICBjb250ZW50VG9waWM6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UXVlcnkge1xuICBwdWJTdWJUb3BpYz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY29udGVudEZpbHRlcnM6IENvbnRlbnRGaWx0ZXJbXTtcbiAgcGFnaW5nSW5mbz86IFBhZ2luZ0luZm8gfCB1bmRlZmluZWQ7XG4gIHN0YXJ0VGltZT86IExvbmcgfCB1bmRlZmluZWQ7XG4gIGVuZFRpbWU/OiBMb25nIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSZXNwb25zZSB7XG4gIG1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdO1xuICBwYWdpbmdJbmZvOiBQYWdpbmdJbmZvIHwgdW5kZWZpbmVkO1xuICBlcnJvcjogSGlzdG9yeVJlc3BvbnNlX0Vycm9yO1xufVxuXG5leHBvcnQgZW51bSBIaXN0b3J5UmVzcG9uc2VfRXJyb3Ige1xuICBFUlJPUl9OT05FX1VOU1BFQ0lGSUVEID0gMCxcbiAgRVJST1JfSU5WQUxJRF9DVVJTT1IgPSAxLFxuICBVTlJFQ09HTklaRUQgPSAtMSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpc3RvcnlSZXNwb25zZV9FcnJvckZyb21KU09OKFxuICBvYmplY3Q6IGFueVxuKTogSGlzdG9yeVJlc3BvbnNlX0Vycm9yIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSBcIkVSUk9SX05PTkVfVU5TUEVDSUZJRURcIjpcbiAgICAgIHJldHVybiBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfTk9ORV9VTlNQRUNJRklFRDtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSBcIkVSUk9SX0lOVkFMSURfQ1VSU09SXCI6XG4gICAgICByZXR1cm4gSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX0lOVkFMSURfQ1VSU09SO1xuICAgIGNhc2UgLTE6XG4gICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSGlzdG9yeVJlc3BvbnNlX0Vycm9yLlVOUkVDT0dOSVpFRDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlzdG9yeVJlc3BvbnNlX0Vycm9yVG9KU09OKFxuICBvYmplY3Q6IEhpc3RvcnlSZXNwb25zZV9FcnJvclxuKTogc3RyaW5nIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9OT05FX1VOU1BFQ0lGSUVEOlxuICAgICAgcmV0dXJuIFwiRVJST1JfTk9ORV9VTlNQRUNJRklFRFwiO1xuICAgIGNhc2UgSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX0lOVkFMSURfQ1VSU09SOlxuICAgICAgcmV0dXJuIFwiRVJST1JfSU5WQUxJRF9DVVJTT1JcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJQQyB7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICBxdWVyeTogSGlzdG9yeVF1ZXJ5IHwgdW5kZWZpbmVkO1xuICByZXNwb25zZTogSGlzdG9yeVJlc3BvbnNlIHwgdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSW5kZXgoKTogSW5kZXgge1xuICByZXR1cm4ge1xuICAgIGRpZ2VzdDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICByZWNlaXZlZFRpbWU6IExvbmcuWkVSTyxcbiAgICBzZW5kZXJUaW1lOiBMb25nLlpFUk8sXG4gICAgcHVic3ViVG9waWM6IFwiXCIsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBJbmRleCA9IHtcbiAgZW5jb2RlKG1lc3NhZ2U6IEluZGV4LCB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UuZGlnZXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5kaWdlc3QpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UucmVjZWl2ZWRUaW1lLmlzWmVybygpKSB7XG4gICAgICB3cml0ZXIudWludDMyKDE2KS5zaW50NjQobWVzc2FnZS5yZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2Uuc2VuZGVyVGltZS5pc1plcm8oKSkge1xuICAgICAgd3JpdGVyLnVpbnQzMigyNCkuc2ludDY0KG1lc3NhZ2Uuc2VuZGVyVGltZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnB1YnN1YlRvcGljICE9PSBcIlwiKSB7XG4gICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5wdWJzdWJUb3BpYyk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSW5kZXgge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5kZXgoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IHJlYWRlci5zaW50NjQoKSBhcyBMb25nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5zZW5kZXJUaW1lID0gcmVhZGVyLnNpbnQ2NCgpIGFzIExvbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLnB1YnN1YlRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBJbmRleCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZ2VzdDogaXNTZXQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgcmVjZWl2ZWRUaW1lOiBpc1NldChvYmplY3QucmVjZWl2ZWRUaW1lKVxuICAgICAgICA/IExvbmcuZnJvbVN0cmluZyhvYmplY3QucmVjZWl2ZWRUaW1lKVxuICAgICAgICA6IExvbmcuWkVSTyxcbiAgICAgIHNlbmRlclRpbWU6IGlzU2V0KG9iamVjdC5zZW5kZXJUaW1lKVxuICAgICAgICA/IExvbmcuZnJvbVN0cmluZyhvYmplY3Quc2VuZGVyVGltZSlcbiAgICAgICAgOiBMb25nLlpFUk8sXG4gICAgICBwdWJzdWJUb3BpYzogaXNTZXQob2JqZWN0LnB1YnN1YlRvcGljKSA/IFN0cmluZyhvYmplY3QucHVic3ViVG9waWMpIDogXCJcIixcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBJbmRleCk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5kaWdlc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5kaWdlc3QgPSBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRpZ2VzdCA6IG5ldyBVaW50OEFycmF5KClcbiAgICAgICkpO1xuICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVjZWl2ZWRUaW1lID0gKG1lc3NhZ2UucmVjZWl2ZWRUaW1lIHx8IExvbmcuWkVSTykudG9TdHJpbmcoKSk7XG4gICAgbWVzc2FnZS5zZW5kZXJUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouc2VuZGVyVGltZSA9IChtZXNzYWdlLnNlbmRlclRpbWUgfHwgTG9uZy5aRVJPKS50b1N0cmluZygpKTtcbiAgICBtZXNzYWdlLnB1YnN1YlRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucHVic3ViVG9waWMgPSBtZXNzYWdlLnB1YnN1YlRvcGljKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxJbmRleD4sIEk+PihvYmplY3Q6IEkpOiBJbmRleCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbmRleCgpO1xuICAgIG1lc3NhZ2UuZGlnZXN0ID0gb2JqZWN0LmRpZ2VzdCA/PyBuZXcgVWludDhBcnJheSgpO1xuICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lID1cbiAgICAgIG9iamVjdC5yZWNlaXZlZFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjZWl2ZWRUaW1lICE9PSBudWxsXG4gICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnJlY2VpdmVkVGltZSlcbiAgICAgICAgOiBMb25nLlpFUk87XG4gICAgbWVzc2FnZS5zZW5kZXJUaW1lID1cbiAgICAgIG9iamVjdC5zZW5kZXJUaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRlclRpbWUgIT09IG51bGxcbiAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3Quc2VuZGVyVGltZSlcbiAgICAgICAgOiBMb25nLlpFUk87XG4gICAgbWVzc2FnZS5wdWJzdWJUb3BpYyA9IG9iamVjdC5wdWJzdWJUb3BpYyA/PyBcIlwiO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZVBhZ2luZ0luZm8oKTogUGFnaW5nSW5mbyB7XG4gIHJldHVybiB7IHBhZ2VTaXplOiBMb25nLlVaRVJPLCBjdXJzb3I6IHVuZGVmaW5lZCwgZGlyZWN0aW9uOiAwIH07XG59XG5cbmV4cG9ydCBjb25zdCBQYWdpbmdJbmZvID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUGFnaW5nSW5mbyxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmICghbWVzc2FnZS5wYWdlU2l6ZS5pc1plcm8oKSkge1xuICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBJbmRleC5lbmNvZGUobWVzc2FnZS5jdXJzb3IsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmRpcmVjdGlvbiAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5kaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IFBhZ2luZ0luZm8ge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFnaW5nSW5mbygpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5wYWdlU2l6ZSA9IHJlYWRlci51aW50NjQoKSBhcyBMb25nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5jdXJzb3IgPSBJbmRleC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5kaXJlY3Rpb24gPSByZWFkZXIuaW50MzIoKSBhcyBhbnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IFBhZ2luZ0luZm8ge1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlU2l6ZTogaXNTZXQob2JqZWN0LnBhZ2VTaXplKVxuICAgICAgICA/IExvbmcuZnJvbVN0cmluZyhvYmplY3QucGFnZVNpemUpXG4gICAgICAgIDogTG9uZy5VWkVSTyxcbiAgICAgIGN1cnNvcjogaXNTZXQob2JqZWN0LmN1cnNvcikgPyBJbmRleC5mcm9tSlNPTihvYmplY3QuY3Vyc29yKSA6IHVuZGVmaW5lZCxcbiAgICAgIGRpcmVjdGlvbjogaXNTZXQob2JqZWN0LmRpcmVjdGlvbilcbiAgICAgICAgPyBwYWdpbmdJbmZvX0RpcmVjdGlvbkZyb21KU09OKG9iamVjdC5kaXJlY3Rpb24pXG4gICAgICAgIDogMCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBQYWdpbmdJbmZvKTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLnBhZ2VTaXplICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnZVNpemUgPSAobWVzc2FnZS5wYWdlU2l6ZSB8fCBMb25nLlVaRVJPKS50b1N0cmluZygpKTtcbiAgICBtZXNzYWdlLmN1cnNvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmN1cnNvciA9IG1lc3NhZ2UuY3Vyc29yID8gSW5kZXgudG9KU09OKG1lc3NhZ2UuY3Vyc29yKSA6IHVuZGVmaW5lZCk7XG4gICAgbWVzc2FnZS5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5kaXJlY3Rpb24gPSBwYWdpbmdJbmZvX0RpcmVjdGlvblRvSlNPTihtZXNzYWdlLmRpcmVjdGlvbikpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPFBhZ2luZ0luZm8+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IFBhZ2luZ0luZm8ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFnaW5nSW5mbygpO1xuICAgIG1lc3NhZ2UucGFnZVNpemUgPVxuICAgICAgb2JqZWN0LnBhZ2VTaXplICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2VTaXplICE9PSBudWxsXG4gICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnBhZ2VTaXplKVxuICAgICAgICA6IExvbmcuVVpFUk87XG4gICAgbWVzc2FnZS5jdXJzb3IgPVxuICAgICAgb2JqZWN0LmN1cnNvciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jdXJzb3IgIT09IG51bGxcbiAgICAgICAgPyBJbmRleC5mcm9tUGFydGlhbChvYmplY3QuY3Vyc29yKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmRpcmVjdGlvbiA9IG9iamVjdC5kaXJlY3Rpb24gPz8gMDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250ZW50RmlsdGVyKCk6IENvbnRlbnRGaWx0ZXIge1xuICByZXR1cm4geyBjb250ZW50VG9waWM6IFwiXCIgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENvbnRlbnRGaWx0ZXIgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBDb250ZW50RmlsdGVyLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UuY29udGVudFRvcGljICE9PSBcIlwiKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IENvbnRlbnRGaWx0ZXIge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29udGVudEZpbHRlcigpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IENvbnRlbnRGaWx0ZXIge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50VG9waWM6IGlzU2V0KG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgID8gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgIDogXCJcIixcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBDb250ZW50RmlsdGVyKTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxDb250ZW50RmlsdGVyPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBDb250ZW50RmlsdGVyIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRlbnRGaWx0ZXIoKTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IG9iamVjdC5jb250ZW50VG9waWMgPz8gXCJcIjtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VIaXN0b3J5UXVlcnkoKTogSGlzdG9yeVF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICBwdWJTdWJUb3BpYzogdW5kZWZpbmVkLFxuICAgIGNvbnRlbnRGaWx0ZXJzOiBbXSxcbiAgICBwYWdpbmdJbmZvOiB1bmRlZmluZWQsXG4gICAgc3RhcnRUaW1lOiB1bmRlZmluZWQsXG4gICAgZW5kVGltZTogdW5kZWZpbmVkLFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSGlzdG9yeVF1ZXJ5ID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogSGlzdG9yeVF1ZXJ5LFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb250ZW50RmlsdGVycykge1xuICAgICAgQ29udGVudEZpbHRlci5lbmNvZGUodiEsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgUGFnaW5nSW5mby5lbmNvZGUobWVzc2FnZS5wYWdpbmdJbmZvLCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMig0MCkuc2ludDY0KG1lc3NhZ2Uuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuZW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDQ4KS5zaW50NjQobWVzc2FnZS5lbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBIaXN0b3J5UXVlcnkge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVF1ZXJ5KCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50RmlsdGVycy5wdXNoKFxuICAgICAgICAgICAgQ29udGVudEZpbHRlci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID0gcmVhZGVyLnNpbnQ2NCgpIGFzIExvbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBtZXNzYWdlLmVuZFRpbWUgPSByZWFkZXIuc2ludDY0KCkgYXMgTG9uZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcHViU3ViVG9waWM6IGlzU2V0KG9iamVjdC5wdWJTdWJUb3BpYylcbiAgICAgICAgPyBTdHJpbmcob2JqZWN0LnB1YlN1YlRvcGljKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbnRlbnRGaWx0ZXJzOiBBcnJheS5pc0FycmF5KG9iamVjdD8uY29udGVudEZpbHRlcnMpXG4gICAgICAgID8gb2JqZWN0LmNvbnRlbnRGaWx0ZXJzLm1hcCgoZTogYW55KSA9PiBDb250ZW50RmlsdGVyLmZyb21KU09OKGUpKVxuICAgICAgICA6IFtdLFxuICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBzdGFydFRpbWU6IGlzU2V0KG9iamVjdC5zdGFydFRpbWUpXG4gICAgICAgID8gTG9uZy5mcm9tU3RyaW5nKG9iamVjdC5zdGFydFRpbWUpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZW5kVGltZTogaXNTZXQob2JqZWN0LmVuZFRpbWUpXG4gICAgICAgID8gTG9uZy5mcm9tU3RyaW5nKG9iamVjdC5lbmRUaW1lKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBIaXN0b3J5UXVlcnkpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5wdWJTdWJUb3BpYyA9IG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzKSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzLm1hcCgoZSkgPT5cbiAgICAgICAgZSA/IENvbnRlbnRGaWx0ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouc3RhcnRUaW1lID0gKG1lc3NhZ2Uuc3RhcnRUaW1lIHx8IHVuZGVmaW5lZCkudG9TdHJpbmcoKSk7XG4gICAgbWVzc2FnZS5lbmRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZW5kVGltZSA9IChtZXNzYWdlLmVuZFRpbWUgfHwgdW5kZWZpbmVkKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UXVlcnk+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEhpc3RvcnlRdWVyeSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UXVlcnkoKTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gb2JqZWN0LnB1YlN1YlRvcGljID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzID1cbiAgICAgIG9iamVjdC5jb250ZW50RmlsdGVycz8ubWFwKChlKSA9PiBDb250ZW50RmlsdGVyLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPVxuICAgICAgb2JqZWN0LnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFnaW5nSW5mbyAhPT0gbnVsbFxuICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID1cbiAgICAgIG9iamVjdC5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3RhcnRUaW1lICE9PSBudWxsXG4gICAgICAgID8gTG9uZy5mcm9tVmFsdWUob2JqZWN0LnN0YXJ0VGltZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5lbmRUaW1lID1cbiAgICAgIG9iamVjdC5lbmRUaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmVuZFRpbWUgIT09IG51bGxcbiAgICAgICAgPyBMb25nLmZyb21WYWx1ZShvYmplY3QuZW5kVGltZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSGlzdG9yeVJlc3BvbnNlKCk6IEhpc3RvcnlSZXNwb25zZSB7XG4gIHJldHVybiB7IG1lc3NhZ2VzOiBbXSwgcGFnaW5nSW5mbzogdW5kZWZpbmVkLCBlcnJvcjogMCB9O1xufVxuXG5leHBvcnQgY29uc3QgSGlzdG9yeVJlc3BvbnNlID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogSGlzdG9yeVJlc3BvbnNlLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgIFdha3VNZXNzYWdlLmVuY29kZSh2ISwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBQYWdpbmdJbmZvLmVuY29kZShtZXNzYWdlLnBhZ2luZ0luZm8sIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQzMihtZXNzYWdlLmVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVJlc3BvbnNlKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzLnB1c2goV2FrdU1lc3NhZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVhZGVyLmludDMyKCkgYXMgYW55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlczogQXJyYXkuaXNBcnJheShvYmplY3Q/Lm1lc3NhZ2VzKVxuICAgICAgICA/IG9iamVjdC5tZXNzYWdlcy5tYXAoKGU6IGFueSkgPT4gV2FrdU1lc3NhZ2UuZnJvbUpTT04oZSkpXG4gICAgICAgIDogW10sXG4gICAgICBwYWdpbmdJbmZvOiBpc1NldChvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21KU09OKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpXG4gICAgICAgID8gaGlzdG9yeVJlc3BvbnNlX0Vycm9yRnJvbUpTT04ob2JqZWN0LmVycm9yKVxuICAgICAgICA6IDAsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogSGlzdG9yeVJlc3BvbnNlKTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBpZiAobWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgb2JqLm1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcy5tYXAoKGUpID0+XG4gICAgICAgIGUgPyBXYWt1TWVzc2FnZS50b0pTT04oZSkgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iai5tZXNzYWdlcyA9IFtdO1xuICAgIH1cbiAgICBtZXNzYWdlLnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5wYWdpbmdJbmZvID0gbWVzc2FnZS5wYWdpbmdJbmZvXG4gICAgICAgID8gUGFnaW5nSW5mby50b0pTT04obWVzc2FnZS5wYWdpbmdJbmZvKVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgbWVzc2FnZS5lcnJvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmVycm9yID0gaGlzdG9yeVJlc3BvbnNlX0Vycm9yVG9KU09OKG1lc3NhZ2UuZXJyb3IpKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UmVzcG9uc2U+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEhpc3RvcnlSZXNwb25zZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UmVzcG9uc2UoKTtcbiAgICBtZXNzYWdlLm1lc3NhZ2VzID1cbiAgICAgIG9iamVjdC5tZXNzYWdlcz8ubWFwKChlKSA9PiBXYWt1TWVzc2FnZS5mcm9tUGFydGlhbChlKSkgfHwgW107XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvID1cbiAgICAgIG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGxcbiAgICAgICAgPyBQYWdpbmdJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5wYWdpbmdJbmZvKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmVycm9yID0gb2JqZWN0LmVycm9yID8/IDA7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSGlzdG9yeVJQQygpOiBIaXN0b3J5UlBDIHtcbiAgcmV0dXJuIHsgcmVxdWVzdElkOiBcIlwiLCBxdWVyeTogdW5kZWZpbmVkLCByZXNwb25zZTogdW5kZWZpbmVkIH07XG59XG5cbmV4cG9ydCBjb25zdCBIaXN0b3J5UlBDID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogSGlzdG9yeVJQQyxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnJlcXVlc3RJZCAhPT0gXCJcIikge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSGlzdG9yeVF1ZXJ5LmVuY29kZShtZXNzYWdlLnF1ZXJ5LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBIaXN0b3J5UmVzcG9uc2UuZW5jb2RlKFxuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlLFxuICAgICAgICB3cml0ZXIudWludDMyKDI2KS5mb3JrKClcbiAgICAgICkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVJQQyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UlBDKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UucXVlcnkgPSBIaXN0b3J5UXVlcnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2UgPSBIaXN0b3J5UmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVJQQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3RJZDogaXNTZXQob2JqZWN0LnJlcXVlc3RJZCkgPyBTdHJpbmcob2JqZWN0LnJlcXVlc3RJZCkgOiBcIlwiLFxuICAgICAgcXVlcnk6IGlzU2V0KG9iamVjdC5xdWVyeSlcbiAgICAgICAgPyBIaXN0b3J5UXVlcnkuZnJvbUpTT04ob2JqZWN0LnF1ZXJ5KVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIHJlc3BvbnNlOiBpc1NldChvYmplY3QucmVzcG9uc2UpXG4gICAgICAgID8gSGlzdG9yeVJlc3BvbnNlLmZyb21KU09OKG9iamVjdC5yZXNwb25zZSlcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogSGlzdG9yeVJQQyk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnJlcXVlc3RJZCA9IG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICBtZXNzYWdlLnF1ZXJ5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucXVlcnkgPSBtZXNzYWdlLnF1ZXJ5XG4gICAgICAgID8gSGlzdG9yeVF1ZXJ5LnRvSlNPTihtZXNzYWdlLnF1ZXJ5KVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgbWVzc2FnZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZVxuICAgICAgICA/IEhpc3RvcnlSZXNwb25zZS50b0pTT04obWVzc2FnZS5yZXNwb25zZSlcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPEhpc3RvcnlSUEM+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEhpc3RvcnlSUEMge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVJQQygpO1xuICAgIG1lc3NhZ2UucmVxdWVzdElkID0gb2JqZWN0LnJlcXVlc3RJZCA/PyBcIlwiO1xuICAgIG1lc3NhZ2UucXVlcnkgPVxuICAgICAgb2JqZWN0LnF1ZXJ5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnF1ZXJ5ICE9PSBudWxsXG4gICAgICAgID8gSGlzdG9yeVF1ZXJ5LmZyb21QYXJ0aWFsKG9iamVjdC5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5yZXNwb25zZSA9XG4gICAgICBvYmplY3QucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzcG9uc2UgIT09IG51bGxcbiAgICAgICAgPyBIaXN0b3J5UmVzcG9uc2UuZnJvbVBhcnRpYWwob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmRlY2xhcmUgdmFyIHNlbGY6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIHdpbmRvdzogYW55IHwgdW5kZWZpbmVkO1xuZGVjbGFyZSB2YXIgZ2xvYmFsOiBhbnkgfCB1bmRlZmluZWQ7XG52YXIgZ2xvYmFsVGhpczogYW55ID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsO1xuICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcblxuY29uc3QgYXRvYjogKGI2NDogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYmluID0gYXRvYihiNjQpO1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5jb25zdCBidG9hOiAoYmluOiBzdHJpbmcpID0+IHN0cmluZyA9XG4gIGdsb2JhbFRoaXMuYnRvYSB8fFxuICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBjb25zdCBiaW46IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBhcnIpIHtcbiAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIExvbmdcbiAgPyBzdHJpbmcgfCBudW1iZXIgfCBMb25nXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxudHlwZSBLZXlzT2ZVbmlvbjxUPiA9IFQgZXh0ZW5kcyBUID8ga2V5b2YgVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRXhhY3Q8UCwgSSBleHRlbmRzIFA+ID0gUCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBQXG4gIDogUCAmIHsgW0sgaW4ga2V5b2YgUF06IEV4YWN0PFBbS10sIElbS10+IH0gJiBSZWNvcmQ8XG4gICAgICAgIEV4Y2x1ZGU8a2V5b2YgSSwgS2V5c09mVW5pb248UD4+LFxuICAgICAgICBuZXZlclxuICAgICAgPjtcblxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgX20wLnV0aWwuTG9uZyA9IExvbmcgYXMgYW55O1xuICBfbTAuY29uZmlndXJlKCk7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kTyA9IHt9OyIsInZhciBkZWZlcnJlZCA9IFtdO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5PID0gKHJlc3VsdCwgY2h1bmtJZHMsIGZuLCBwcmlvcml0eSkgPT4ge1xuXHRpZihjaHVua0lkcykge1xuXHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRmb3IodmFyIGkgPSBkZWZlcnJlZC5sZW5ndGg7IGkgPiAwICYmIGRlZmVycmVkW2kgLSAxXVsyXSA+IHByaW9yaXR5OyBpLS0pIGRlZmVycmVkW2ldID0gZGVmZXJyZWRbaSAtIDFdO1xuXHRcdGRlZmVycmVkW2ldID0gW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldO1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgbm90RnVsZmlsbGVkID0gSW5maW5pdHk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldID0gZGVmZXJyZWRbaV07XG5cdFx0dmFyIGZ1bGZpbGxlZCA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjaHVua0lkcy5sZW5ndGg7IGorKykge1xuXHRcdFx0aWYgKChwcmlvcml0eSAmIDEgPT09IDAgfHwgbm90RnVsZmlsbGVkID49IHByaW9yaXR5KSAmJiBPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLk8pLmV2ZXJ5KChrZXkpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fLk9ba2V5XShjaHVua0lkc1tqXSkpKSkge1xuXHRcdFx0XHRjaHVua0lkcy5zcGxpY2Uoai0tLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZihwcmlvcml0eSA8IG5vdEZ1bGZpbGxlZCkgbm90RnVsZmlsbGVkID0gcHJpb3JpdHk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGZ1bGZpbGxlZCkge1xuXHRcdFx0ZGVmZXJyZWQuc3BsaWNlKGktLSwgMSlcblx0XHRcdHZhciByID0gZm4oKTtcblx0XHRcdGlmIChyICE9PSB1bmRlZmluZWQpIHJlc3VsdCA9IHI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcImpzLXdha3VcIjogMFxufTtcblxuLy8gbm8gY2h1bmsgb24gZGVtYW5kIGxvYWRpbmdcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5PLmogPSAoY2h1bmtJZCkgPT4gKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9PT0gMCk7XG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSB0aGlzW1wid2VicGFja0NodW5ranN3YWt1XCJdID0gdGhpc1tcIndlYnBhY2tDaHVua2pzd2FrdVwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBkZXBlbmRzIG9uIG90aGVyIGxvYWRlZCBjaHVua3MgYW5kIGV4ZWN1dGlvbiBuZWVkIHRvIGJlIGRlbGF5ZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1widmVuZG9yc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKSkpXG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKF9fd2VicGFja19leHBvcnRzX18pO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9